// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_packets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packets_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packets_2eproto;
namespace ai {
namespace inworld {
namespace packets {
class Actor;
struct ActorDefaultTypeInternal;
extern ActorDefaultTypeInternal _Actor_default_instance_;
class AdditionalPhonemeInfo;
struct AdditionalPhonemeInfoDefaultTypeInternal;
extern AdditionalPhonemeInfoDefaultTypeInternal _AdditionalPhonemeInfo_default_instance_;
class AudioChunk;
struct AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class CancelResponsesEvent;
struct CancelResponsesEventDefaultTypeInternal;
extern CancelResponsesEventDefaultTypeInternal _CancelResponsesEvent_default_instance_;
class ControlEvent;
struct ControlEventDefaultTypeInternal;
extern ControlEventDefaultTypeInternal _ControlEvent_default_instance_;
class CustomEvent;
struct CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class DataChunk;
struct DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class EmotionEvent;
struct EmotionEventDefaultTypeInternal;
extern EmotionEventDefaultTypeInternal _EmotionEvent_default_instance_;
class GestureEvent;
struct GestureEventDefaultTypeInternal;
extern GestureEventDefaultTypeInternal _GestureEvent_default_instance_;
class InworldPacket;
struct InworldPacketDefaultTypeInternal;
extern InworldPacketDefaultTypeInternal _InworldPacket_default_instance_;
class PacketId;
struct PacketIdDefaultTypeInternal;
extern PacketIdDefaultTypeInternal _PacketId_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class TextEvent;
struct TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
}  // namespace packets
}  // namespace inworld
}  // namespace ai
PROTOBUF_NAMESPACE_OPEN
template<> ::ai::inworld::packets::Actor* Arena::CreateMaybeMessage<::ai::inworld::packets::Actor>(Arena*);
template<> ::ai::inworld::packets::AdditionalPhonemeInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::AdditionalPhonemeInfo>(Arena*);
template<> ::ai::inworld::packets::AudioChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::AudioChunk>(Arena*);
template<> ::ai::inworld::packets::CancelResponsesEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponsesEvent>(Arena*);
template<> ::ai::inworld::packets::ControlEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ControlEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent>(Arena*);
template<> ::ai::inworld::packets::DataChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::DataChunk>(Arena*);
template<> ::ai::inworld::packets::EmotionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::EmotionEvent>(Arena*);
template<> ::ai::inworld::packets::GestureEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::GestureEvent>(Arena*);
template<> ::ai::inworld::packets::InworldPacket* Arena::CreateMaybeMessage<::ai::inworld::packets::InworldPacket>(Arena*);
template<> ::ai::inworld::packets::PacketId* Arena::CreateMaybeMessage<::ai::inworld::packets::PacketId>(Arena*);
template<> ::ai::inworld::packets::Routing* Arena::CreateMaybeMessage<::ai::inworld::packets::Routing>(Arena*);
template<> ::ai::inworld::packets::TextEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ai {
namespace inworld {
namespace packets {

enum Actor_Type : int {
  Actor_Type_UNKNOWN = 0,
  Actor_Type_PLAYER = 1,
  Actor_Type_AGENT = 2,
  Actor_Type_Actor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Actor_Type_Actor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Actor_Type_IsValid(int value);
constexpr Actor_Type Actor_Type_Type_MIN = Actor_Type_UNKNOWN;
constexpr Actor_Type Actor_Type_Type_MAX = Actor_Type_AGENT;
constexpr int Actor_Type_Type_ARRAYSIZE = Actor_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Actor_Type_descriptor();
template<typename T>
inline const std::string& Actor_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Actor_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Actor_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Actor_Type_descriptor(), enum_t_value);
}
inline bool Actor_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Actor_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Actor_Type>(
    Actor_Type_descriptor(), name, value);
}
enum TextEvent_SourceType : int {
  TextEvent_SourceType_UNKNOWN = 0,
  TextEvent_SourceType_SPEECH_TO_TEXT = 1,
  TextEvent_SourceType_TYPED_IN = 2,
  TextEvent_SourceType_GENERATED = 3,
  TextEvent_SourceType_FILLER = 4,
  TextEvent_SourceType_TextEvent_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TextEvent_SourceType_TextEvent_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TextEvent_SourceType_IsValid(int value);
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MIN = TextEvent_SourceType_UNKNOWN;
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MAX = TextEvent_SourceType_FILLER;
constexpr int TextEvent_SourceType_SourceType_ARRAYSIZE = TextEvent_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextEvent_SourceType_descriptor();
template<typename T>
inline const std::string& TextEvent_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextEvent_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextEvent_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextEvent_SourceType_descriptor(), enum_t_value);
}
inline bool TextEvent_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextEvent_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextEvent_SourceType>(
    TextEvent_SourceType_descriptor(), name, value);
}
enum ControlEvent_Action : int {
  ControlEvent_Action_UNKNOWN = 0,
  ControlEvent_Action_AUDIO_SESSION_START = 1,
  ControlEvent_Action_AUDIO_SESSION_END = 2,
  ControlEvent_Action_INTERACTION_END = 3,
  ControlEvent_Action_TTS_PLAYBACK_START = 4,
  ControlEvent_Action_TTS_PLAYBACK_END = 5,
  ControlEvent_Action_ControlEvent_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ControlEvent_Action_ControlEvent_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ControlEvent_Action_IsValid(int value);
constexpr ControlEvent_Action ControlEvent_Action_Action_MIN = ControlEvent_Action_UNKNOWN;
constexpr ControlEvent_Action ControlEvent_Action_Action_MAX = ControlEvent_Action_TTS_PLAYBACK_END;
constexpr int ControlEvent_Action_Action_ARRAYSIZE = ControlEvent_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlEvent_Action_descriptor();
template<typename T>
inline const std::string& ControlEvent_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlEvent_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlEvent_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlEvent_Action_descriptor(), enum_t_value);
}
inline bool ControlEvent_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlEvent_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlEvent_Action>(
    ControlEvent_Action_descriptor(), name, value);
}
enum GestureEvent_Type : int {
  GestureEvent_Type_GREETING = 0,
  GestureEvent_Type_FAREWELL = 1,
  GestureEvent_Type_AGREEMENT = 2,
  GestureEvent_Type_DISAGREEMENT = 3,
  GestureEvent_Type_GRATITUDE = 4,
  GestureEvent_Type_CELEBRATION = 5,
  GestureEvent_Type_BOREDOM = 6,
  GestureEvent_Type_UNCERTAINTY = 7,
  GestureEvent_Type_GestureEvent_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GestureEvent_Type_GestureEvent_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GestureEvent_Type_IsValid(int value);
constexpr GestureEvent_Type GestureEvent_Type_Type_MIN = GestureEvent_Type_GREETING;
constexpr GestureEvent_Type GestureEvent_Type_Type_MAX = GestureEvent_Type_UNCERTAINTY;
constexpr int GestureEvent_Type_Type_ARRAYSIZE = GestureEvent_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GestureEvent_Type_descriptor();
template<typename T>
inline const std::string& GestureEvent_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GestureEvent_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GestureEvent_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GestureEvent_Type_descriptor(), enum_t_value);
}
inline bool GestureEvent_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GestureEvent_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GestureEvent_Type>(
    GestureEvent_Type_descriptor(), name, value);
}
enum EmotionEvent_SpaffCode : int {
  EmotionEvent_SpaffCode_NEUTRAL = 0,
  EmotionEvent_SpaffCode_DISGUST = 1,
  EmotionEvent_SpaffCode_CONTEMPT = 2,
  EmotionEvent_SpaffCode_BELLIGERENCE = 3,
  EmotionEvent_SpaffCode_DOMINEERING = 4,
  EmotionEvent_SpaffCode_CRITICISM = 5,
  EmotionEvent_SpaffCode_ANGER = 6,
  EmotionEvent_SpaffCode_TENSION = 7,
  EmotionEvent_SpaffCode_TENSE_HUMOR = 8,
  EmotionEvent_SpaffCode_DEFENSIVENESS = 9,
  EmotionEvent_SpaffCode_WHINING = 10,
  EmotionEvent_SpaffCode_SADNESS = 11,
  EmotionEvent_SpaffCode_STONEWALLING = 12,
  EmotionEvent_SpaffCode_INTEREST = 13,
  EmotionEvent_SpaffCode_VALIDATION = 14,
  EmotionEvent_SpaffCode_AFFECTION = 15,
  EmotionEvent_SpaffCode_HUMOR = 16,
  EmotionEvent_SpaffCode_SURPRISE = 17,
  EmotionEvent_SpaffCode_JOY = 18,
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EmotionEvent_SpaffCode_IsValid(int value);
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MIN = EmotionEvent_SpaffCode_NEUTRAL;
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MAX = EmotionEvent_SpaffCode_JOY;
constexpr int EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE = EmotionEvent_SpaffCode_SpaffCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_SpaffCode_descriptor();
template<typename T>
inline const std::string& EmotionEvent_SpaffCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_SpaffCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_SpaffCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_SpaffCode_descriptor(), enum_t_value);
}
inline bool EmotionEvent_SpaffCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_SpaffCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_SpaffCode>(
    EmotionEvent_SpaffCode_descriptor(), name, value);
}
enum EmotionEvent_Strength : int {
  EmotionEvent_Strength_UNSPECIFIED = 0,
  EmotionEvent_Strength_WEAK = 1,
  EmotionEvent_Strength_STRONG = 2,
  EmotionEvent_Strength_NORMAL = 3,
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EmotionEvent_Strength_IsValid(int value);
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MIN = EmotionEvent_Strength_UNSPECIFIED;
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MAX = EmotionEvent_Strength_NORMAL;
constexpr int EmotionEvent_Strength_Strength_ARRAYSIZE = EmotionEvent_Strength_Strength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_Strength_descriptor();
template<typename T>
inline const std::string& EmotionEvent_Strength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_Strength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_Strength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_Strength_descriptor(), enum_t_value);
}
inline bool EmotionEvent_Strength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_Strength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_Strength>(
    EmotionEvent_Strength_descriptor(), name, value);
}
enum DataChunk_DataType : int {
  DataChunk_DataType_UNSPECIFIED = 0,
  DataChunk_DataType_AUDIO = 1,
  DataChunk_DataType_ANIMATION = 2,
  DataChunk_DataType_SILENCE = 3,
  DataChunk_DataType_DataChunk_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataChunk_DataType_DataChunk_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataChunk_DataType_IsValid(int value);
constexpr DataChunk_DataType DataChunk_DataType_DataType_MIN = DataChunk_DataType_UNSPECIFIED;
constexpr DataChunk_DataType DataChunk_DataType_DataType_MAX = DataChunk_DataType_SILENCE;
constexpr int DataChunk_DataType_DataType_ARRAYSIZE = DataChunk_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_DataType_descriptor();
template<typename T>
inline const std::string& DataChunk_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_DataType_descriptor(), enum_t_value);
}
inline bool DataChunk_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_DataType>(
    DataChunk_DataType_descriptor(), name, value);
}
enum Playback : int {
  UNSPECIFIED = 0,
  INTERACTION = 1,
  INTERACTION_END = 2,
  UTTERANCE = 3,
  Playback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Playback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Playback_IsValid(int value);
constexpr Playback Playback_MIN = UNSPECIFIED;
constexpr Playback Playback_MAX = UTTERANCE;
constexpr int Playback_ARRAYSIZE = Playback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Playback_descriptor();
template<typename T>
inline const std::string& Playback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Playback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Playback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Playback_descriptor(), enum_t_value);
}
inline bool Playback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Playback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Playback>(
    Playback_descriptor(), name, value);
}
// ===================================================================

class Actor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Actor) */ {
 public:
  inline Actor() : Actor(nullptr) {}
  ~Actor() override;
  explicit PROTOBUF_CONSTEXPR Actor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Actor(const Actor& from);
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actor& operator=(Actor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Actor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }
  inline void Swap(Actor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Actor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Actor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Actor& from) {
    Actor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Actor";
  }
  protected:
  explicit Actor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Actor_Type Type;
  static constexpr Type UNKNOWN =
    Actor_Type_UNKNOWN;
  static constexpr Type PLAYER =
    Actor_Type_PLAYER;
  static constexpr Type AGENT =
    Actor_Type_AGENT;
  static inline bool Type_IsValid(int value) {
    return Actor_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Actor_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Actor_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Actor_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Actor_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Actor_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Actor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Actor.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::Actor_Type type() const;
  void set_type(::ai::inworld::packets::Actor_Type value);
  private:
  ::ai::inworld::packets::Actor_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::Actor_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Actor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class Routing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  explicit PROTOBUF_CONSTEXPR Routing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Routing& from) {
    Routing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // .ai.inworld.packets.Actor source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::ai::inworld::packets::Actor& source() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_source();
  ::ai::inworld::packets::Actor* mutable_source();
  void set_allocated_source(::ai::inworld::packets::Actor* source);
  private:
  const ::ai::inworld::packets::Actor& _internal_source() const;
  ::ai::inworld::packets::Actor* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::ai::inworld::packets::Actor* source);
  ::ai::inworld::packets::Actor* unsafe_arena_release_source();

  // .ai.inworld.packets.Actor target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::ai::inworld::packets::Actor& target() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_target();
  ::ai::inworld::packets::Actor* mutable_target();
  void set_allocated_target(::ai::inworld::packets::Actor* target);
  private:
  const ::ai::inworld::packets::Actor& _internal_target() const;
  ::ai::inworld::packets::Actor* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::ai::inworld::packets::Actor* target);
  ::ai::inworld::packets::Actor* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Routing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::packets::Actor* source_;
    ::ai::inworld::packets::Actor* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class PacketId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PacketId) */ {
 public:
  inline PacketId() : PacketId(nullptr) {}
  ~PacketId() override;
  explicit PROTOBUF_CONSTEXPR PacketId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketId(const PacketId& from);
  PacketId(PacketId&& from) noexcept
    : PacketId() {
    *this = ::std::move(from);
  }

  inline PacketId& operator=(const PacketId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketId& operator=(PacketId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketId* internal_default_instance() {
    return reinterpret_cast<const PacketId*>(
               &_PacketId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketId& a, PacketId& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketId& from) {
    PacketId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PacketId";
  }
  protected:
  explicit PacketId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 3,
  };
  // string packet_id = 1;
  void clear_packet_id();
  const std::string& packet_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packet_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packet_id();
  PROTOBUF_NODISCARD std::string* release_packet_id();
  void set_allocated_packet_id(std::string* packet_id);
  private:
  const std::string& _internal_packet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_id(const std::string& value);
  std::string* _internal_mutable_packet_id();
  public:

  // string utterance_id = 2;
  void clear_utterance_id();
  const std::string& utterance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utterance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utterance_id();
  PROTOBUF_NODISCARD std::string* release_utterance_id();
  void set_allocated_utterance_id(std::string* utterance_id);
  private:
  const std::string& _internal_utterance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utterance_id(const std::string& value);
  std::string* _internal_mutable_utterance_id();
  public:

  // string interaction_id = 3;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PacketId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utterance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class InworldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.InworldPacket) */ {
 public:
  inline InworldPacket() : InworldPacket(nullptr) {}
  ~InworldPacket() override;
  explicit PROTOBUF_CONSTEXPR InworldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InworldPacket(const InworldPacket& from);
  InworldPacket(InworldPacket&& from) noexcept
    : InworldPacket() {
    *this = ::std::move(from);
  }

  inline InworldPacket& operator=(const InworldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InworldPacket& operator=(InworldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InworldPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kText = 2,
    kControl = 3,
    kAudioChunk = 4,
    kGesture = 5,
    kCustom = 8,
    kCancelResponses = 10,
    kEmotion = 11,
    kDataChunk = 12,
    PACKET_NOT_SET = 0,
  };

  static inline const InworldPacket* internal_default_instance() {
    return reinterpret_cast<const InworldPacket*>(
               &_InworldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InworldPacket& a, InworldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InworldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InworldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InworldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InworldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InworldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InworldPacket& from) {
    InworldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InworldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.InworldPacket";
  }
  protected:
  explicit InworldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPacketIdFieldNumber = 7,
    kTimestampFieldNumber = 1,
    kRoutingFieldNumber = 6,
    kPacketIdFieldNumber = 9,
    kTextFieldNumber = 2,
    kControlFieldNumber = 3,
    kAudioChunkFieldNumber = 4,
    kGestureFieldNumber = 5,
    kCustomFieldNumber = 8,
    kCancelResponsesFieldNumber = 10,
    kEmotionFieldNumber = 11,
    kDataChunkFieldNumber = 12,
  };
  // string old_packet_id = 7;
  void clear_old_packet_id();
  const std::string& old_packet_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_packet_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_packet_id();
  PROTOBUF_NODISCARD std::string* release_old_packet_id();
  void set_allocated_old_packet_id(std::string* old_packet_id);
  private:
  const std::string& _internal_old_packet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_packet_id(const std::string& value);
  std::string* _internal_mutable_old_packet_id();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .ai.inworld.packets.Routing routing = 6;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::ai::inworld::packets::Routing& routing() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Routing* release_routing();
  ::ai::inworld::packets::Routing* mutable_routing();
  void set_allocated_routing(::ai::inworld::packets::Routing* routing);
  private:
  const ::ai::inworld::packets::Routing& _internal_routing() const;
  ::ai::inworld::packets::Routing* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::ai::inworld::packets::Routing* routing);
  ::ai::inworld::packets::Routing* unsafe_arena_release_routing();

  // .ai.inworld.packets.PacketId packet_id = 9;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // .ai.inworld.packets.TextEvent text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::ai::inworld::packets::TextEvent& text() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::TextEvent* release_text();
  ::ai::inworld::packets::TextEvent* mutable_text();
  void set_allocated_text(::ai::inworld::packets::TextEvent* text);
  private:
  const ::ai::inworld::packets::TextEvent& _internal_text() const;
  ::ai::inworld::packets::TextEvent* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::ai::inworld::packets::TextEvent* text);
  ::ai::inworld::packets::TextEvent* unsafe_arena_release_text();

  // .ai.inworld.packets.ControlEvent control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::ai::inworld::packets::ControlEvent& control() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ControlEvent* release_control();
  ::ai::inworld::packets::ControlEvent* mutable_control();
  void set_allocated_control(::ai::inworld::packets::ControlEvent* control);
  private:
  const ::ai::inworld::packets::ControlEvent& _internal_control() const;
  ::ai::inworld::packets::ControlEvent* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::ai::inworld::packets::ControlEvent* control);
  ::ai::inworld::packets::ControlEvent* unsafe_arena_release_control();

  // .ai.inworld.packets.AudioChunk audio_chunk = 4;
  bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  void clear_audio_chunk();
  const ::ai::inworld::packets::AudioChunk& audio_chunk() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::AudioChunk* release_audio_chunk();
  ::ai::inworld::packets::AudioChunk* mutable_audio_chunk();
  void set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk);
  private:
  const ::ai::inworld::packets::AudioChunk& _internal_audio_chunk() const;
  ::ai::inworld::packets::AudioChunk* _internal_mutable_audio_chunk();
  public:
  void unsafe_arena_set_allocated_audio_chunk(
      ::ai::inworld::packets::AudioChunk* audio_chunk);
  ::ai::inworld::packets::AudioChunk* unsafe_arena_release_audio_chunk();

  // .ai.inworld.packets.GestureEvent gesture = 5;
  bool has_gesture() const;
  private:
  bool _internal_has_gesture() const;
  public:
  void clear_gesture();
  const ::ai::inworld::packets::GestureEvent& gesture() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::GestureEvent* release_gesture();
  ::ai::inworld::packets::GestureEvent* mutable_gesture();
  void set_allocated_gesture(::ai::inworld::packets::GestureEvent* gesture);
  private:
  const ::ai::inworld::packets::GestureEvent& _internal_gesture() const;
  ::ai::inworld::packets::GestureEvent* _internal_mutable_gesture();
  public:
  void unsafe_arena_set_allocated_gesture(
      ::ai::inworld::packets::GestureEvent* gesture);
  ::ai::inworld::packets::GestureEvent* unsafe_arena_release_gesture();

  // .ai.inworld.packets.CustomEvent custom = 8;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::ai::inworld::packets::CustomEvent& custom() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CustomEvent* release_custom();
  ::ai::inworld::packets::CustomEvent* mutable_custom();
  void set_allocated_custom(::ai::inworld::packets::CustomEvent* custom);
  private:
  const ::ai::inworld::packets::CustomEvent& _internal_custom() const;
  ::ai::inworld::packets::CustomEvent* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::ai::inworld::packets::CustomEvent* custom);
  ::ai::inworld::packets::CustomEvent* unsafe_arena_release_custom();

  // .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10;
  bool has_cancelresponses() const;
  private:
  bool _internal_has_cancelresponses() const;
  public:
  void clear_cancelresponses();
  const ::ai::inworld::packets::CancelResponsesEvent& cancelresponses() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CancelResponsesEvent* release_cancelresponses();
  ::ai::inworld::packets::CancelResponsesEvent* mutable_cancelresponses();
  void set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  private:
  const ::ai::inworld::packets::CancelResponsesEvent& _internal_cancelresponses() const;
  ::ai::inworld::packets::CancelResponsesEvent* _internal_mutable_cancelresponses();
  public:
  void unsafe_arena_set_allocated_cancelresponses(
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  ::ai::inworld::packets::CancelResponsesEvent* unsafe_arena_release_cancelresponses();

  // .ai.inworld.packets.EmotionEvent emotion = 11;
  bool has_emotion() const;
  private:
  bool _internal_has_emotion() const;
  public:
  void clear_emotion();
  const ::ai::inworld::packets::EmotionEvent& emotion() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::EmotionEvent* release_emotion();
  ::ai::inworld::packets::EmotionEvent* mutable_emotion();
  void set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion);
  private:
  const ::ai::inworld::packets::EmotionEvent& _internal_emotion() const;
  ::ai::inworld::packets::EmotionEvent* _internal_mutable_emotion();
  public:
  void unsafe_arena_set_allocated_emotion(
      ::ai::inworld::packets::EmotionEvent* emotion);
  ::ai::inworld::packets::EmotionEvent* unsafe_arena_release_emotion();

  // .ai.inworld.packets.DataChunk data_chunk = 12;
  bool has_data_chunk() const;
  private:
  bool _internal_has_data_chunk() const;
  public:
  void clear_data_chunk();
  const ::ai::inworld::packets::DataChunk& data_chunk() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DataChunk* release_data_chunk();
  ::ai::inworld::packets::DataChunk* mutable_data_chunk();
  void set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk);
  private:
  const ::ai::inworld::packets::DataChunk& _internal_data_chunk() const;
  ::ai::inworld::packets::DataChunk* _internal_mutable_data_chunk();
  public:
  void unsafe_arena_set_allocated_data_chunk(
      ::ai::inworld::packets::DataChunk* data_chunk);
  ::ai::inworld::packets::DataChunk* unsafe_arena_release_data_chunk();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.InworldPacket)
 private:
  class _Internal;
  void set_has_text();
  void set_has_control();
  void set_has_audio_chunk();
  void set_has_gesture();
  void set_has_custom();
  void set_has_cancelresponses();
  void set_has_emotion();
  void set_has_data_chunk();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_packet_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::ai::inworld::packets::Routing* routing_;
    ::ai::inworld::packets::PacketId* packet_id_;
    union PacketUnion {
      constexpr PacketUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::TextEvent* text_;
      ::ai::inworld::packets::ControlEvent* control_;
      ::ai::inworld::packets::AudioChunk* audio_chunk_;
      ::ai::inworld::packets::GestureEvent* gesture_;
      ::ai::inworld::packets::CustomEvent* custom_;
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses_;
      ::ai::inworld::packets::EmotionEvent* emotion_;
      ::ai::inworld::packets::DataChunk* data_chunk_;
    } packet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  ~TextEvent() override;
  explicit PROTOBUF_CONSTEXPR TextEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextEvent(const TextEvent& from);
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextEvent& from) {
    TextEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent";
  }
  protected:
  explicit TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextEvent_SourceType SourceType;
  static constexpr SourceType UNKNOWN =
    TextEvent_SourceType_UNKNOWN;
  static constexpr SourceType SPEECH_TO_TEXT =
    TextEvent_SourceType_SPEECH_TO_TEXT;
  static constexpr SourceType TYPED_IN =
    TextEvent_SourceType_TYPED_IN;
  static constexpr SourceType GENERATED =
    TextEvent_SourceType_GENERATED;
  static constexpr SourceType FILLER =
    TextEvent_SourceType_FILLER;
  static inline bool SourceType_IsValid(int value) {
    return TextEvent_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    TextEvent_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    TextEvent_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    TextEvent_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return TextEvent_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return TextEvent_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return TextEvent_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kSourceTypeFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.TextEvent.SourceType source_type = 2;
  void clear_source_type();
  ::ai::inworld::packets::TextEvent_SourceType source_type() const;
  void set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  private:
  ::ai::inworld::packets::TextEvent_SourceType _internal_source_type() const;
  void _internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  public:

  // bool final = 3;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int source_type_;
    bool final_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ControlEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ControlEvent) */ {
 public:
  inline ControlEvent() : ControlEvent(nullptr) {}
  ~ControlEvent() override;
  explicit PROTOBUF_CONSTEXPR ControlEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlEvent(const ControlEvent& from);
  ControlEvent(ControlEvent&& from) noexcept
    : ControlEvent() {
    *this = ::std::move(from);
  }

  inline ControlEvent& operator=(const ControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlEvent& operator=(ControlEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlEvent* internal_default_instance() {
    return reinterpret_cast<const ControlEvent*>(
               &_ControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControlEvent& a, ControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlEvent& from) {
    ControlEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ControlEvent";
  }
  protected:
  explicit ControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControlEvent_Action Action;
  static constexpr Action UNKNOWN =
    ControlEvent_Action_UNKNOWN;
  static constexpr Action AUDIO_SESSION_START =
    ControlEvent_Action_AUDIO_SESSION_START;
  static constexpr Action AUDIO_SESSION_END =
    ControlEvent_Action_AUDIO_SESSION_END;
  static constexpr Action INTERACTION_END =
    ControlEvent_Action_INTERACTION_END;
  static constexpr Action TTS_PLAYBACK_START =
    ControlEvent_Action_TTS_PLAYBACK_START;
  static constexpr Action TTS_PLAYBACK_END =
    ControlEvent_Action_TTS_PLAYBACK_END;
  static inline bool Action_IsValid(int value) {
    return ControlEvent_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ControlEvent_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ControlEvent_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ControlEvent_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return ControlEvent_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ControlEvent_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ControlEvent_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // .ai.inworld.packets.ControlEvent.Action action = 1;
  void clear_action();
  ::ai::inworld::packets::ControlEvent_Action action() const;
  void set_action(::ai::inworld::packets::ControlEvent_Action value);
  private:
  ::ai::inworld::packets::ControlEvent_Action _internal_action() const;
  void _internal_set_action(::ai::inworld::packets::ControlEvent_Action value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ControlEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class AudioChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  ~AudioChunk() override;
  explicit PROTOBUF_CONSTEXPR AudioChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioChunk(const AudioChunk& from);
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioChunk& from) {
    AudioChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AudioChunk";
  }
  protected:
  explicit AudioChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AudioChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class GestureEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.GestureEvent) */ {
 public:
  inline GestureEvent() : GestureEvent(nullptr) {}
  ~GestureEvent() override;
  explicit PROTOBUF_CONSTEXPR GestureEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GestureEvent(const GestureEvent& from);
  GestureEvent(GestureEvent&& from) noexcept
    : GestureEvent() {
    *this = ::std::move(from);
  }

  inline GestureEvent& operator=(const GestureEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GestureEvent& operator=(GestureEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GestureEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GestureEvent* internal_default_instance() {
    return reinterpret_cast<const GestureEvent*>(
               &_GestureEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GestureEvent& a, GestureEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(GestureEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GestureEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GestureEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GestureEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GestureEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GestureEvent& from) {
    GestureEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GestureEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.GestureEvent";
  }
  protected:
  explicit GestureEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GestureEvent_Type Type;
  static constexpr Type GREETING =
    GestureEvent_Type_GREETING;
  static constexpr Type FAREWELL =
    GestureEvent_Type_FAREWELL;
  static constexpr Type AGREEMENT =
    GestureEvent_Type_AGREEMENT;
  static constexpr Type DISAGREEMENT =
    GestureEvent_Type_DISAGREEMENT;
  static constexpr Type GRATITUDE =
    GestureEvent_Type_GRATITUDE;
  static constexpr Type CELEBRATION =
    GestureEvent_Type_CELEBRATION;
  static constexpr Type BOREDOM =
    GestureEvent_Type_BOREDOM;
  static constexpr Type UNCERTAINTY =
    GestureEvent_Type_UNCERTAINTY;
  static inline bool Type_IsValid(int value) {
    return GestureEvent_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    GestureEvent_Type_Type_MIN;
  static constexpr Type Type_MAX =
    GestureEvent_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    GestureEvent_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return GestureEvent_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return GestureEvent_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return GestureEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlaybackFieldNumber = 2,
  };
  // .ai.inworld.packets.GestureEvent.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::GestureEvent_Type type() const;
  void set_type(::ai::inworld::packets::GestureEvent_Type value);
  private:
  ::ai::inworld::packets::GestureEvent_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::GestureEvent_Type value);
  public:

  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.GestureEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    int playback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  ~CustomEvent() override;
  explicit PROTOBUF_CONSTEXPR CustomEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomEvent(const CustomEvent& from);
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomEvent& from) {
    CustomEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent";
  }
  protected:
  explicit CustomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPlaybackFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int playback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponsesEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponsesEvent) */ {
 public:
  inline CancelResponsesEvent() : CancelResponsesEvent(nullptr) {}
  ~CancelResponsesEvent() override;
  explicit PROTOBUF_CONSTEXPR CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelResponsesEvent(const CancelResponsesEvent& from);
  CancelResponsesEvent(CancelResponsesEvent&& from) noexcept
    : CancelResponsesEvent() {
    *this = ::std::move(from);
  }

  inline CancelResponsesEvent& operator=(const CancelResponsesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponsesEvent& operator=(CancelResponsesEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponsesEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponsesEvent* internal_default_instance() {
    return reinterpret_cast<const CancelResponsesEvent*>(
               &_CancelResponsesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CancelResponsesEvent& a, CancelResponsesEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponsesEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponsesEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponsesEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponsesEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelResponsesEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelResponsesEvent& from) {
    CancelResponsesEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponsesEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponsesEvent";
  }
  protected:
  explicit CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponsesEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class EmotionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.EmotionEvent) */ {
 public:
  inline EmotionEvent() : EmotionEvent(nullptr) {}
  ~EmotionEvent() override;
  explicit PROTOBUF_CONSTEXPR EmotionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmotionEvent(const EmotionEvent& from);
  EmotionEvent(EmotionEvent&& from) noexcept
    : EmotionEvent() {
    *this = ::std::move(from);
  }

  inline EmotionEvent& operator=(const EmotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionEvent& operator=(EmotionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionEvent* internal_default_instance() {
    return reinterpret_cast<const EmotionEvent*>(
               &_EmotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EmotionEvent& a, EmotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmotionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmotionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmotionEvent& from) {
    EmotionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.EmotionEvent";
  }
  protected:
  explicit EmotionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EmotionEvent_SpaffCode SpaffCode;
  static constexpr SpaffCode NEUTRAL =
    EmotionEvent_SpaffCode_NEUTRAL;
  static constexpr SpaffCode DISGUST =
    EmotionEvent_SpaffCode_DISGUST;
  static constexpr SpaffCode CONTEMPT =
    EmotionEvent_SpaffCode_CONTEMPT;
  static constexpr SpaffCode BELLIGERENCE =
    EmotionEvent_SpaffCode_BELLIGERENCE;
  static constexpr SpaffCode DOMINEERING =
    EmotionEvent_SpaffCode_DOMINEERING;
  static constexpr SpaffCode CRITICISM =
    EmotionEvent_SpaffCode_CRITICISM;
  static constexpr SpaffCode ANGER =
    EmotionEvent_SpaffCode_ANGER;
  static constexpr SpaffCode TENSION =
    EmotionEvent_SpaffCode_TENSION;
  static constexpr SpaffCode TENSE_HUMOR =
    EmotionEvent_SpaffCode_TENSE_HUMOR;
  static constexpr SpaffCode DEFENSIVENESS =
    EmotionEvent_SpaffCode_DEFENSIVENESS;
  static constexpr SpaffCode WHINING =
    EmotionEvent_SpaffCode_WHINING;
  static constexpr SpaffCode SADNESS =
    EmotionEvent_SpaffCode_SADNESS;
  static constexpr SpaffCode STONEWALLING =
    EmotionEvent_SpaffCode_STONEWALLING;
  static constexpr SpaffCode INTEREST =
    EmotionEvent_SpaffCode_INTEREST;
  static constexpr SpaffCode VALIDATION =
    EmotionEvent_SpaffCode_VALIDATION;
  static constexpr SpaffCode AFFECTION =
    EmotionEvent_SpaffCode_AFFECTION;
  static constexpr SpaffCode HUMOR =
    EmotionEvent_SpaffCode_HUMOR;
  static constexpr SpaffCode SURPRISE =
    EmotionEvent_SpaffCode_SURPRISE;
  static constexpr SpaffCode JOY =
    EmotionEvent_SpaffCode_JOY;
  static inline bool SpaffCode_IsValid(int value) {
    return EmotionEvent_SpaffCode_IsValid(value);
  }
  static constexpr SpaffCode SpaffCode_MIN =
    EmotionEvent_SpaffCode_SpaffCode_MIN;
  static constexpr SpaffCode SpaffCode_MAX =
    EmotionEvent_SpaffCode_SpaffCode_MAX;
  static constexpr int SpaffCode_ARRAYSIZE =
    EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaffCode_descriptor() {
    return EmotionEvent_SpaffCode_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaffCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaffCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaffCode_Name.");
    return EmotionEvent_SpaffCode_Name(enum_t_value);
  }
  static inline bool SpaffCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SpaffCode* value) {
    return EmotionEvent_SpaffCode_Parse(name, value);
  }

  typedef EmotionEvent_Strength Strength;
  static constexpr Strength UNSPECIFIED =
    EmotionEvent_Strength_UNSPECIFIED;
  static constexpr Strength WEAK =
    EmotionEvent_Strength_WEAK;
  static constexpr Strength STRONG =
    EmotionEvent_Strength_STRONG;
  static constexpr Strength NORMAL =
    EmotionEvent_Strength_NORMAL;
  static inline bool Strength_IsValid(int value) {
    return EmotionEvent_Strength_IsValid(value);
  }
  static constexpr Strength Strength_MIN =
    EmotionEvent_Strength_Strength_MIN;
  static constexpr Strength Strength_MAX =
    EmotionEvent_Strength_Strength_MAX;
  static constexpr int Strength_ARRAYSIZE =
    EmotionEvent_Strength_Strength_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Strength_descriptor() {
    return EmotionEvent_Strength_descriptor();
  }
  template<typename T>
  static inline const std::string& Strength_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Strength>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Strength_Name.");
    return EmotionEvent_Strength_Name(enum_t_value);
  }
  static inline bool Strength_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Strength* value) {
    return EmotionEvent_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJoyFieldNumber = 1,
    kFearFieldNumber = 2,
    kTrustFieldNumber = 3,
    kSurpriseFieldNumber = 4,
    kBehaviorFieldNumber = 5,
    kStrengthFieldNumber = 6,
  };
  // float joy = 1;
  void clear_joy();
  float joy() const;
  void set_joy(float value);
  private:
  float _internal_joy() const;
  void _internal_set_joy(float value);
  public:

  // float fear = 2;
  void clear_fear();
  float fear() const;
  void set_fear(float value);
  private:
  float _internal_fear() const;
  void _internal_set_fear(float value);
  public:

  // float trust = 3;
  void clear_trust();
  float trust() const;
  void set_trust(float value);
  private:
  float _internal_trust() const;
  void _internal_set_trust(float value);
  public:

  // float surprise = 4;
  void clear_surprise();
  float surprise() const;
  void set_surprise(float value);
  private:
  float _internal_surprise() const;
  void _internal_set_surprise(float value);
  public:

  // .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
  void clear_behavior();
  ::ai::inworld::packets::EmotionEvent_SpaffCode behavior() const;
  void set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  private:
  ::ai::inworld::packets::EmotionEvent_SpaffCode _internal_behavior() const;
  void _internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  public:

  // .ai.inworld.packets.EmotionEvent.Strength strength = 6;
  void clear_strength();
  ::ai::inworld::packets::EmotionEvent_Strength strength() const;
  void set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  private:
  ::ai::inworld::packets::EmotionEvent_Strength _internal_strength() const;
  void _internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.EmotionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float joy_;
    float fear_;
    float trust_;
    float surprise_;
    int behavior_;
    int strength_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class DataChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  ~DataChunk() override;
  explicit PROTOBUF_CONSTEXPR DataChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChunk& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kChunk = 1,
    kDurationMs = 3,
    DATA_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataChunk& from) {
    DataChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataChunk_DataType DataType;
  static constexpr DataType UNSPECIFIED =
    DataChunk_DataType_UNSPECIFIED;
  static constexpr DataType AUDIO =
    DataChunk_DataType_AUDIO;
  static constexpr DataType ANIMATION =
    DataChunk_DataType_ANIMATION;
  static constexpr DataType SILENCE =
    DataChunk_DataType_SILENCE;
  static inline bool DataType_IsValid(int value) {
    return DataChunk_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    DataChunk_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    DataChunk_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    DataChunk_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return DataChunk_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return DataChunk_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return DataChunk_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPhonemeInfoFieldNumber = 4,
    kTypeFieldNumber = 2,
    kChunkFieldNumber = 1,
    kDurationMsFieldNumber = 3,
  };
  // repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
  int additional_phoneme_info_size() const;
  private:
  int _internal_additional_phoneme_info_size() const;
  public:
  void clear_additional_phoneme_info();
  ::ai::inworld::packets::AdditionalPhonemeInfo* mutable_additional_phoneme_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
      mutable_additional_phoneme_info();
  private:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& _internal_additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* _internal_add_additional_phoneme_info();
  public:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* add_additional_phoneme_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
      additional_phoneme_info() const;

  // .ai.inworld.packets.DataChunk.DataType type = 2;
  void clear_type();
  ::ai::inworld::packets::DataChunk_DataType type() const;
  void set_type(::ai::inworld::packets::DataChunk_DataType value);
  private:
  ::ai::inworld::packets::DataChunk_DataType _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::DataChunk_DataType value);
  public:

  // bytes chunk = 1;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // int64 duration_ms = 3;
  bool has_duration_ms() const;
  private:
  bool _internal_has_duration_ms() const;
  public:
  void clear_duration_ms();
  int64_t duration_ms() const;
  void set_duration_ms(int64_t value);
  private:
  int64_t _internal_duration_ms() const;
  void _internal_set_duration_ms(int64_t value);
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DataChunk)
 private:
  class _Internal;
  void set_has_chunk();
  void set_has_duration_ms();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo > additional_phoneme_info_;
    int type_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
      int64_t duration_ms_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class AdditionalPhonemeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AdditionalPhonemeInfo) */ {
 public:
  inline AdditionalPhonemeInfo() : AdditionalPhonemeInfo(nullptr) {}
  ~AdditionalPhonemeInfo() override;
  explicit PROTOBUF_CONSTEXPR AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdditionalPhonemeInfo(const AdditionalPhonemeInfo& from);
  AdditionalPhonemeInfo(AdditionalPhonemeInfo&& from) noexcept
    : AdditionalPhonemeInfo() {
    *this = ::std::move(from);
  }

  inline AdditionalPhonemeInfo& operator=(const AdditionalPhonemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPhonemeInfo& operator=(AdditionalPhonemeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdditionalPhonemeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdditionalPhonemeInfo* internal_default_instance() {
    return reinterpret_cast<const AdditionalPhonemeInfo*>(
               &_AdditionalPhonemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AdditionalPhonemeInfo& a, AdditionalPhonemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalPhonemeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdditionalPhonemeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdditionalPhonemeInfo& from) {
    AdditionalPhonemeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalPhonemeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AdditionalPhonemeInfo";
  }
  protected:
  explicit AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonemeFieldNumber = 1,
    kStartOffsetFieldNumber = 2,
  };
  // string phoneme = 1;
  void clear_phoneme();
  const std::string& phoneme() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phoneme(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phoneme();
  PROTOBUF_NODISCARD std::string* release_phoneme();
  void set_allocated_phoneme(std::string* phoneme);
  private:
  const std::string& _internal_phoneme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phoneme(const std::string& value);
  std::string* _internal_mutable_phoneme();
  public:

  // .google.protobuf.Duration start_offset = 2;
  bool has_start_offset() const;
  private:
  bool _internal_has_start_offset() const;
  public:
  void clear_start_offset();
  const ::PROTOBUF_NAMESPACE_ID::Duration& start_offset() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_start_offset();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_start_offset();
  void set_allocated_start_offset(::PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_start_offset() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_start_offset();
  public:
  void unsafe_arena_set_allocated_start_offset(
      ::PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_start_offset();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AdditionalPhonemeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phoneme_;
    ::PROTOBUF_NAMESPACE_ID::Duration* start_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Actor

// .ai.inworld.packets.Actor.Type type = 1;
inline void Actor::clear_type() {
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::Actor_Type Actor::_internal_type() const {
  return static_cast< ::ai::inworld::packets::Actor_Type >(_impl_.type_);
}
inline ::ai::inworld::packets::Actor_Type Actor::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.type)
  return _internal_type();
}
inline void Actor::_internal_set_type(::ai::inworld::packets::Actor_Type value) {
  
  _impl_.type_ = value;
}
inline void Actor::set_type(::ai::inworld::packets::Actor_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.type)
}

// string name = 2;
inline void Actor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Actor::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Actor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Actor.name)
  return _s;
}
inline const std::string& Actor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Actor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Actor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Actor::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Actor.name)
  return _impl_.name_.Release();
}
inline void Actor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Actor.name)
}

// -------------------------------------------------------------------

// Routing

// .ai.inworld.packets.Actor source = 1;
inline bool Routing::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Routing::has_source() const {
  return _internal_has_source();
}
inline void Routing::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_source() const {
  const ::ai::inworld::packets::Actor* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::source() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.source)
  return _internal_source();
}
inline void Routing::unsafe_arena_set_allocated_source(
    ::ai::inworld::packets::Actor* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.source)
}
inline ::ai::inworld::packets::Actor* Routing::release_source() {
  
  ::ai::inworld::packets::Actor* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.source)
  
  ::ai::inworld::packets::Actor* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_source() {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.source)
  return _msg;
}
inline void Routing::set_allocated_source(::ai::inworld::packets::Actor* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.source)
}

// .ai.inworld.packets.Actor target = 2;
inline bool Routing::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool Routing::has_target() const {
  return _internal_has_target();
}
inline void Routing::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_target() const {
  const ::ai::inworld::packets::Actor* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::target() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.target)
  return _internal_target();
}
inline void Routing::unsafe_arena_set_allocated_target(
    ::ai::inworld::packets::Actor* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.target)
}
inline ::ai::inworld::packets::Actor* Routing::release_target() {
  
  ::ai::inworld::packets::Actor* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.target)
  
  ::ai::inworld::packets::Actor* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_target() {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.target)
  return _msg;
}
inline void Routing::set_allocated_target(::ai::inworld::packets::Actor* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.target)
}

// -------------------------------------------------------------------

// PacketId

// string packet_id = 1;
inline void PacketId::clear_packet_id() {
  _impl_.packet_id_.ClearToEmpty();
}
inline const std::string& PacketId::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.packet_id)
  return _internal_packet_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_packet_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.packet_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::mutable_packet_id() {
  std::string* _s = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.packet_id)
  return _s;
}
inline const std::string& PacketId::_internal_packet_id() const {
  return _impl_.packet_id_.Get();
}
inline void PacketId::_internal_set_packet_id(const std::string& value) {
  
  _impl_.packet_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_packet_id() {
  
  return _impl_.packet_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.packet_id)
  return _impl_.packet_id_.Release();
}
inline void PacketId::set_allocated_packet_id(std::string* packet_id) {
  if (packet_id != nullptr) {
    
  } else {
    
  }
  _impl_.packet_id_.SetAllocated(packet_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packet_id_.IsDefault()) {
    _impl_.packet_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.packet_id)
}

// string utterance_id = 2;
inline void PacketId::clear_utterance_id() {
  _impl_.utterance_id_.ClearToEmpty();
}
inline const std::string& PacketId::utterance_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.utterance_id)
  return _internal_utterance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_utterance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utterance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::mutable_utterance_id() {
  std::string* _s = _internal_mutable_utterance_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.utterance_id)
  return _s;
}
inline const std::string& PacketId::_internal_utterance_id() const {
  return _impl_.utterance_id_.Get();
}
inline void PacketId::_internal_set_utterance_id(const std::string& value) {
  
  _impl_.utterance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_utterance_id() {
  
  return _impl_.utterance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_utterance_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.utterance_id)
  return _impl_.utterance_id_.Release();
}
inline void PacketId::set_allocated_utterance_id(std::string* utterance_id) {
  if (utterance_id != nullptr) {
    
  } else {
    
  }
  _impl_.utterance_id_.SetAllocated(utterance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utterance_id_.IsDefault()) {
    _impl_.utterance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.utterance_id)
}

// string interaction_id = 3;
inline void PacketId::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& PacketId::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.interaction_id)
  return _s;
}
inline const std::string& PacketId::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void PacketId::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void PacketId::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.interaction_id)
}

// -------------------------------------------------------------------

// InworldPacket

// .google.protobuf.Timestamp timestamp = 1;
inline bool InworldPacket::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool InworldPacket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_timestamp();
}
inline void InworldPacket::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.timestamp)
  return _msg;
}
inline void InworldPacket::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}

// .ai.inworld.packets.Routing routing = 6;
inline bool InworldPacket::_internal_has_routing() const {
  return this != internal_default_instance() && _impl_.routing_ != nullptr;
}
inline bool InworldPacket::has_routing() const {
  return _internal_has_routing();
}
inline void InworldPacket::clear_routing() {
  if (GetArenaForAllocation() == nullptr && _impl_.routing_ != nullptr) {
    delete _impl_.routing_;
  }
  _impl_.routing_ = nullptr;
}
inline const ::ai::inworld::packets::Routing& InworldPacket::_internal_routing() const {
  const ::ai::inworld::packets::Routing* p = _impl_.routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Routing&>(
      ::ai::inworld::packets::_Routing_default_instance_);
}
inline const ::ai::inworld::packets::Routing& InworldPacket::routing() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.routing)
  return _internal_routing();
}
inline void InworldPacket::unsafe_arena_set_allocated_routing(
    ::ai::inworld::packets::Routing* routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_);
  }
  _impl_.routing_ = routing;
  if (routing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.routing)
}
inline ::ai::inworld::packets::Routing* InworldPacket::release_routing() {
  
  ::ai::inworld::packets::Routing* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.routing)
  
  ::ai::inworld::packets::Routing* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::_internal_mutable_routing() {
  
  if (_impl_.routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Routing>(GetArenaForAllocation());
    _impl_.routing_ = p;
  }
  return _impl_.routing_;
}
inline ::ai::inworld::packets::Routing* InworldPacket::mutable_routing() {
  ::ai::inworld::packets::Routing* _msg = _internal_mutable_routing();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.routing)
  return _msg;
}
inline void InworldPacket::set_allocated_routing(::ai::inworld::packets::Routing* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routing_;
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routing);
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.routing)
}

// string old_packet_id = 7;
inline void InworldPacket::clear_old_packet_id() {
  _impl_.old_packet_id_.ClearToEmpty();
}
inline const std::string& InworldPacket::old_packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.old_packet_id)
  return _internal_old_packet_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InworldPacket::set_old_packet_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_packet_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.InworldPacket.old_packet_id)
}
inline std::string* InworldPacket::mutable_old_packet_id() {
  std::string* _s = _internal_mutable_old_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.old_packet_id)
  return _s;
}
inline const std::string& InworldPacket::_internal_old_packet_id() const {
  return _impl_.old_packet_id_.Get();
}
inline void InworldPacket::_internal_set_old_packet_id(const std::string& value) {
  
  _impl_.old_packet_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InworldPacket::_internal_mutable_old_packet_id() {
  
  return _impl_.old_packet_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InworldPacket::release_old_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.old_packet_id)
  return _impl_.old_packet_id_.Release();
}
inline void InworldPacket::set_allocated_old_packet_id(std::string* old_packet_id) {
  if (old_packet_id != nullptr) {
    
  } else {
    
  }
  _impl_.old_packet_id_.SetAllocated(old_packet_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_packet_id_.IsDefault()) {
    _impl_.old_packet_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.old_packet_id)
}

// .ai.inworld.packets.PacketId packet_id = 9;
inline bool InworldPacket::_internal_has_packet_id() const {
  return this != internal_default_instance() && _impl_.packet_id_ != nullptr;
}
inline bool InworldPacket::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void InworldPacket::clear_packet_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_id_ != nullptr) {
    delete _impl_.packet_id_;
  }
  _impl_.packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_packet_id();
}
inline void InworldPacket::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}
inline ::ai::inworld::packets::PacketId* InworldPacket::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::_internal_mutable_packet_id() {
  
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArenaForAllocation());
    _impl_.packet_id_ = p;
  }
  return _impl_.packet_id_;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::mutable_packet_id() {
  ::ai::inworld::packets::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.packet_id)
  return _msg;
}
inline void InworldPacket::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}

// .ai.inworld.packets.TextEvent text = 2;
inline bool InworldPacket::_internal_has_text() const {
  return packet_case() == kText;
}
inline bool InworldPacket::has_text() const {
  return _internal_has_text();
}
inline void InworldPacket::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void InworldPacket::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.text_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = _impl_.packet_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::_internal_text() const {
  return _internal_has_text()
      ? *_impl_.packet_.text_
      : reinterpret_cast< ::ai::inworld::packets::TextEvent&>(::ai::inworld::packets::_TextEvent_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.text)
  return _internal_text();
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = _impl_.packet_.text_;
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* text) {
  clear_packet();
  if (text) {
    set_has_text();
    _impl_.packet_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.text)
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_packet();
    set_has_text();
    _impl_.packet_.text_ = CreateMaybeMessage< ::ai::inworld::packets::TextEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.text_;
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::mutable_text() {
  ::ai::inworld::packets::TextEvent* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.text)
  return _msg;
}

// .ai.inworld.packets.ControlEvent control = 3;
inline bool InworldPacket::_internal_has_control() const {
  return packet_case() == kControl;
}
inline bool InworldPacket::has_control() const {
  return _internal_has_control();
}
inline void InworldPacket::set_has_control() {
  _impl_._oneof_case_[0] = kControl;
}
inline void InworldPacket::clear_control() {
  if (_internal_has_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::release_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = _impl_.packet_.control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::_internal_control() const {
  return _internal_has_control()
      ? *_impl_.packet_.control_
      : reinterpret_cast< ::ai::inworld::packets::ControlEvent&>(::ai::inworld::packets::_ControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::control() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.control)
  return _internal_control();
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = _impl_.packet_.control_;
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* control) {
  clear_packet();
  if (control) {
    set_has_control();
    _impl_.packet_.control_ = control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.control)
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::_internal_mutable_control() {
  if (!_internal_has_control()) {
    clear_packet();
    set_has_control();
    _impl_.packet_.control_ = CreateMaybeMessage< ::ai::inworld::packets::ControlEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.control_;
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::mutable_control() {
  ::ai::inworld::packets::ControlEvent* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.control)
  return _msg;
}

// .ai.inworld.packets.AudioChunk audio_chunk = 4;
inline bool InworldPacket::_internal_has_audio_chunk() const {
  return packet_case() == kAudioChunk;
}
inline bool InworldPacket::has_audio_chunk() const {
  return _internal_has_audio_chunk();
}
inline void InworldPacket::set_has_audio_chunk() {
  _impl_._oneof_case_[0] = kAudioChunk;
}
inline void InworldPacket::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.audio_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::AudioChunk* temp = _impl_.packet_.audio_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::_internal_audio_chunk() const {
  return _internal_has_audio_chunk()
      ? *_impl_.packet_.audio_chunk_
      : reinterpret_cast< ::ai::inworld::packets::AudioChunk&>(::ai::inworld::packets::_AudioChunk_default_instance_);
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::audio_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_audio_chunk();
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::unsafe_arena_release_audio_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::AudioChunk* temp = _impl_.packet_.audio_chunk_;
    _impl_.packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk) {
  clear_packet();
  if (audio_chunk) {
    set_has_audio_chunk();
    _impl_.packet_.audio_chunk_ = audio_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.audio_chunk)
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_packet();
    set_has_audio_chunk();
    _impl_.packet_.audio_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::AudioChunk >(GetArenaForAllocation());
  }
  return _impl_.packet_.audio_chunk_;
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::mutable_audio_chunk() {
  ::ai::inworld::packets::AudioChunk* _msg = _internal_mutable_audio_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.audio_chunk)
  return _msg;
}

// .ai.inworld.packets.GestureEvent gesture = 5;
inline bool InworldPacket::_internal_has_gesture() const {
  return packet_case() == kGesture;
}
inline bool InworldPacket::has_gesture() const {
  return _internal_has_gesture();
}
inline void InworldPacket::set_has_gesture() {
  _impl_._oneof_case_[0] = kGesture;
}
inline void InworldPacket::clear_gesture() {
  if (_internal_has_gesture()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.gesture_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::GestureEvent* InworldPacket::release_gesture() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.gesture)
  if (_internal_has_gesture()) {
    clear_has_packet();
    ::ai::inworld::packets::GestureEvent* temp = _impl_.packet_.gesture_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.gesture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::GestureEvent& InworldPacket::_internal_gesture() const {
  return _internal_has_gesture()
      ? *_impl_.packet_.gesture_
      : reinterpret_cast< ::ai::inworld::packets::GestureEvent&>(::ai::inworld::packets::_GestureEvent_default_instance_);
}
inline const ::ai::inworld::packets::GestureEvent& InworldPacket::gesture() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.gesture)
  return _internal_gesture();
}
inline ::ai::inworld::packets::GestureEvent* InworldPacket::unsafe_arena_release_gesture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.gesture)
  if (_internal_has_gesture()) {
    clear_has_packet();
    ::ai::inworld::packets::GestureEvent* temp = _impl_.packet_.gesture_;
    _impl_.packet_.gesture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_gesture(::ai::inworld::packets::GestureEvent* gesture) {
  clear_packet();
  if (gesture) {
    set_has_gesture();
    _impl_.packet_.gesture_ = gesture;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.gesture)
}
inline ::ai::inworld::packets::GestureEvent* InworldPacket::_internal_mutable_gesture() {
  if (!_internal_has_gesture()) {
    clear_packet();
    set_has_gesture();
    _impl_.packet_.gesture_ = CreateMaybeMessage< ::ai::inworld::packets::GestureEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.gesture_;
}
inline ::ai::inworld::packets::GestureEvent* InworldPacket::mutable_gesture() {
  ::ai::inworld::packets::GestureEvent* _msg = _internal_mutable_gesture();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.gesture)
  return _msg;
}

// .ai.inworld.packets.CustomEvent custom = 8;
inline bool InworldPacket::_internal_has_custom() const {
  return packet_case() == kCustom;
}
inline bool InworldPacket::has_custom() const {
  return _internal_has_custom();
}
inline void InworldPacket::set_has_custom() {
  _impl_._oneof_case_[0] = kCustom;
}
inline void InworldPacket::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.custom_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::release_custom() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = _impl_.packet_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::_internal_custom() const {
  return _internal_has_custom()
      ? *_impl_.packet_.custom_
      : reinterpret_cast< ::ai::inworld::packets::CustomEvent&>(::ai::inworld::packets::_CustomEvent_default_instance_);
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::custom() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.custom)
  return _internal_custom();
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = _impl_.packet_.custom_;
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* custom) {
  clear_packet();
  if (custom) {
    set_has_custom();
    _impl_.packet_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.custom)
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_packet();
    set_has_custom();
    _impl_.packet_.custom_ = CreateMaybeMessage< ::ai::inworld::packets::CustomEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.custom_;
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::mutable_custom() {
  ::ai::inworld::packets::CustomEvent* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.custom)
  return _msg;
}

// .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10;
inline bool InworldPacket::_internal_has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline bool InworldPacket::has_cancelresponses() const {
  return _internal_has_cancelresponses();
}
inline void InworldPacket::set_has_cancelresponses() {
  _impl_._oneof_case_[0] = kCancelResponses;
}
inline void InworldPacket::clear_cancelresponses() {
  if (_internal_has_cancelresponses()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.cancelresponses_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::release_cancelresponses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = _impl_.packet_.cancelresponses_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::_internal_cancelresponses() const {
  return _internal_has_cancelresponses()
      ? *_impl_.packet_.cancelresponses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponsesEvent&>(::ai::inworld::packets::_CancelResponsesEvent_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::cancelresponses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_cancelresponses();
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::unsafe_arena_release_cancelresponses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = _impl_.packet_.cancelresponses_;
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses) {
  clear_packet();
  if (cancelresponses) {
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = cancelresponses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.cancelResponses)
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::_internal_mutable_cancelresponses() {
  if (!_internal_has_cancelresponses()) {
    clear_packet();
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponsesEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.cancelresponses_;
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::mutable_cancelresponses() {
  ::ai::inworld::packets::CancelResponsesEvent* _msg = _internal_mutable_cancelresponses();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.cancelResponses)
  return _msg;
}

// .ai.inworld.packets.EmotionEvent emotion = 11;
inline bool InworldPacket::_internal_has_emotion() const {
  return packet_case() == kEmotion;
}
inline bool InworldPacket::has_emotion() const {
  return _internal_has_emotion();
}
inline void InworldPacket::set_has_emotion() {
  _impl_._oneof_case_[0] = kEmotion;
}
inline void InworldPacket::clear_emotion() {
  if (_internal_has_emotion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.emotion_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::release_emotion() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = _impl_.packet_.emotion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::_internal_emotion() const {
  return _internal_has_emotion()
      ? *_impl_.packet_.emotion_
      : reinterpret_cast< ::ai::inworld::packets::EmotionEvent&>(::ai::inworld::packets::_EmotionEvent_default_instance_);
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::emotion() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.emotion)
  return _internal_emotion();
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::unsafe_arena_release_emotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = _impl_.packet_.emotion_;
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion) {
  clear_packet();
  if (emotion) {
    set_has_emotion();
    _impl_.packet_.emotion_ = emotion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.emotion)
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::_internal_mutable_emotion() {
  if (!_internal_has_emotion()) {
    clear_packet();
    set_has_emotion();
    _impl_.packet_.emotion_ = CreateMaybeMessage< ::ai::inworld::packets::EmotionEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.emotion_;
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::mutable_emotion() {
  ::ai::inworld::packets::EmotionEvent* _msg = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.emotion)
  return _msg;
}

// .ai.inworld.packets.DataChunk data_chunk = 12;
inline bool InworldPacket::_internal_has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline bool InworldPacket::has_data_chunk() const {
  return _internal_has_data_chunk();
}
inline void InworldPacket::set_has_data_chunk() {
  _impl_._oneof_case_[0] = kDataChunk;
}
inline void InworldPacket::clear_data_chunk() {
  if (_internal_has_data_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.data_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::release_data_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = _impl_.packet_.data_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::_internal_data_chunk() const {
  return _internal_has_data_chunk()
      ? *_impl_.packet_.data_chunk_
      : reinterpret_cast< ::ai::inworld::packets::DataChunk&>(::ai::inworld::packets::_DataChunk_default_instance_);
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::data_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_data_chunk();
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::unsafe_arena_release_data_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = _impl_.packet_.data_chunk_;
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk) {
  clear_packet();
  if (data_chunk) {
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = data_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.data_chunk)
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::_internal_mutable_data_chunk() {
  if (!_internal_has_data_chunk()) {
    clear_packet();
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::DataChunk >(GetArenaForAllocation());
  }
  return _impl_.packet_.data_chunk_;
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::mutable_data_chunk() {
  ::ai::inworld::packets::DataChunk* _msg = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.data_chunk)
  return _msg;
}

inline bool InworldPacket::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void InworldPacket::clear_has_packet() {
  _impl_._oneof_case_[0] = PACKET_NOT_SET;
}
inline InworldPacket::PacketCase InworldPacket::packet_case() const {
  return InworldPacket::PacketCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextEvent::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.text)
  return _s;
}
inline const std::string& TextEvent::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextEvent::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextEvent::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.text)
  return _impl_.text_.Release();
}
inline void TextEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.text)
}

// .ai.inworld.packets.TextEvent.SourceType source_type = 2;
inline void TextEvent::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::_internal_source_type() const {
  return static_cast< ::ai::inworld::packets::TextEvent_SourceType >(_impl_.source_type_);
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::source_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.source_type)
  return _internal_source_type();
}
inline void TextEvent::_internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  
  _impl_.source_type_ = value;
}
inline void TextEvent::set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.source_type)
}

// bool final = 3;
inline void TextEvent::clear_final() {
  _impl_.final_ = false;
}
inline bool TextEvent::_internal_final() const {
  return _impl_.final_;
}
inline bool TextEvent::final() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.final)
  return _internal_final();
}
inline void TextEvent::_internal_set_final(bool value) {
  
  _impl_.final_ = value;
}
inline void TextEvent::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.final)
}

// -------------------------------------------------------------------

// ControlEvent

// .ai.inworld.packets.ControlEvent.Action action = 1;
inline void ControlEvent::clear_action() {
  _impl_.action_ = 0;
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::_internal_action() const {
  return static_cast< ::ai::inworld::packets::ControlEvent_Action >(_impl_.action_);
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.action)
  return _internal_action();
}
inline void ControlEvent::_internal_set_action(::ai::inworld::packets::ControlEvent_Action value) {
  
  _impl_.action_ = value;
}
inline void ControlEvent::set_action(::ai::inworld::packets::ControlEvent_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.action)
}

// -------------------------------------------------------------------

// AudioChunk

// bytes chunk = 1;
inline void AudioChunk::clear_chunk() {
  _impl_.chunk_.ClearToEmpty();
}
inline const std::string& AudioChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chunk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AudioChunk.chunk)
  return _s;
}
inline const std::string& AudioChunk::_internal_chunk() const {
  return _impl_.chunk_.Get();
}
inline void AudioChunk::_internal_set_chunk(const std::string& value) {
  
  _impl_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioChunk::_internal_mutable_chunk() {
  
  return _impl_.chunk_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AudioChunk.chunk)
  return _impl_.chunk_.Release();
}
inline void AudioChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  _impl_.chunk_.SetAllocated(chunk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chunk_.IsDefault()) {
    _impl_.chunk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AudioChunk.chunk)
}

// -------------------------------------------------------------------

// GestureEvent

// .ai.inworld.packets.GestureEvent.Type type = 1;
inline void GestureEvent::clear_type() {
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::GestureEvent_Type GestureEvent::_internal_type() const {
  return static_cast< ::ai::inworld::packets::GestureEvent_Type >(_impl_.type_);
}
inline ::ai::inworld::packets::GestureEvent_Type GestureEvent::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.GestureEvent.type)
  return _internal_type();
}
inline void GestureEvent::_internal_set_type(::ai::inworld::packets::GestureEvent_Type value) {
  
  _impl_.type_ = value;
}
inline void GestureEvent::set_type(::ai::inworld::packets::GestureEvent_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.GestureEvent.type)
}

// .ai.inworld.packets.Playback playback = 2;
inline void GestureEvent::clear_playback() {
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback GestureEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(_impl_.playback_);
}
inline ::ai::inworld::packets::Playback GestureEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.GestureEvent.playback)
  return _internal_playback();
}
inline void GestureEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  _impl_.playback_ = value;
}
inline void GestureEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.GestureEvent.playback)
}

// -------------------------------------------------------------------

// CustomEvent

// string name = 1;
inline void CustomEvent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.name)
  return _s;
}
inline const std::string& CustomEvent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.name)
  return _impl_.name_.Release();
}
inline void CustomEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.name)
}

// .ai.inworld.packets.Playback playback = 2;
inline void CustomEvent::clear_playback() {
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback CustomEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(_impl_.playback_);
}
inline ::ai::inworld::packets::Playback CustomEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.playback)
  return _internal_playback();
}
inline void CustomEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  _impl_.playback_ = value;
}
inline void CustomEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.playback)
}

// -------------------------------------------------------------------

// CancelResponsesEvent

// string interaction_id = 1;
inline void CancelResponsesEvent::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponsesEvent::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelResponsesEvent::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void CancelResponsesEvent::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelResponsesEvent::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelResponsesEvent::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void CancelResponsesEvent::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponsesEvent::_internal_utterance_id_size() const {
  return _impl_.utterance_id_.size();
}
inline int CancelResponsesEvent::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponsesEvent::clear_utterance_id() {
  _impl_.utterance_id_.Clear();
}
inline std::string* CancelResponsesEvent::add_utterance_id() {
  std::string* _s = _internal_add_utterance_id();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::_internal_utterance_id(int index) const {
  return _impl_.utterance_id_.Get(index);
}
inline const std::string& CancelResponsesEvent::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponsesEvent::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _impl_.utterance_id_.Mutable(index);
}
inline void CancelResponsesEvent::set_utterance_id(int index, const std::string& value) {
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, std::string&& value) {
  _impl_.utterance_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value, size_t size) {
  _impl_.utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline std::string* CancelResponsesEvent::_internal_add_utterance_id() {
  return _impl_.utterance_id_.Add();
}
inline void CancelResponsesEvent::add_utterance_id(const std::string& value) {
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(std::string&& value) {
  _impl_.utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value, size_t size) {
  _impl_.utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponsesEvent::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _impl_.utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponsesEvent::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return &_impl_.utterance_id_;
}

// -------------------------------------------------------------------

// EmotionEvent

// float joy = 1;
inline void EmotionEvent::clear_joy() {
  _impl_.joy_ = 0;
}
inline float EmotionEvent::_internal_joy() const {
  return _impl_.joy_;
}
inline float EmotionEvent::joy() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.joy)
  return _internal_joy();
}
inline void EmotionEvent::_internal_set_joy(float value) {
  
  _impl_.joy_ = value;
}
inline void EmotionEvent::set_joy(float value) {
  _internal_set_joy(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.joy)
}

// float fear = 2;
inline void EmotionEvent::clear_fear() {
  _impl_.fear_ = 0;
}
inline float EmotionEvent::_internal_fear() const {
  return _impl_.fear_;
}
inline float EmotionEvent::fear() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.fear)
  return _internal_fear();
}
inline void EmotionEvent::_internal_set_fear(float value) {
  
  _impl_.fear_ = value;
}
inline void EmotionEvent::set_fear(float value) {
  _internal_set_fear(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.fear)
}

// float trust = 3;
inline void EmotionEvent::clear_trust() {
  _impl_.trust_ = 0;
}
inline float EmotionEvent::_internal_trust() const {
  return _impl_.trust_;
}
inline float EmotionEvent::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.trust)
  return _internal_trust();
}
inline void EmotionEvent::_internal_set_trust(float value) {
  
  _impl_.trust_ = value;
}
inline void EmotionEvent::set_trust(float value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.trust)
}

// float surprise = 4;
inline void EmotionEvent::clear_surprise() {
  _impl_.surprise_ = 0;
}
inline float EmotionEvent::_internal_surprise() const {
  return _impl_.surprise_;
}
inline float EmotionEvent::surprise() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.surprise)
  return _internal_surprise();
}
inline void EmotionEvent::_internal_set_surprise(float value) {
  
  _impl_.surprise_ = value;
}
inline void EmotionEvent::set_surprise(float value) {
  _internal_set_surprise(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.surprise)
}

// .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
inline void EmotionEvent::clear_behavior() {
  _impl_.behavior_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::_internal_behavior() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_SpaffCode >(_impl_.behavior_);
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::behavior() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.behavior)
  return _internal_behavior();
}
inline void EmotionEvent::_internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  
  _impl_.behavior_ = value;
}
inline void EmotionEvent::set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.behavior)
}

// .ai.inworld.packets.EmotionEvent.Strength strength = 6;
inline void EmotionEvent::clear_strength() {
  _impl_.strength_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::_internal_strength() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_Strength >(_impl_.strength_);
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::strength() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.strength)
  return _internal_strength();
}
inline void EmotionEvent::_internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  
  _impl_.strength_ = value;
}
inline void EmotionEvent::set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.strength)
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk = 1;
inline bool DataChunk::_internal_has_chunk() const {
  return data_case() == kChunk;
}
inline bool DataChunk::has_chunk() const {
  return _internal_has_chunk();
}
inline void DataChunk::set_has_chunk() {
  _impl_._oneof_case_[0] = kChunk;
}
inline void DataChunk::clear_chunk() {
  if (_internal_has_chunk()) {
    _impl_.data_.chunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& DataChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline void DataChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.chunk)
  return _s;
}
inline const std::string& DataChunk::_internal_chunk() const {
  if (_internal_has_chunk()) {
    return _impl_.data_.chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataChunk::_internal_set_chunk(const std::string& value) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* DataChunk::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  return _impl_.data_.chunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DataChunk.chunk)
  if (_internal_has_chunk()) {
    clear_has_data();
    return _impl_.data_.chunk_.Release();
  } else {
    return nullptr;
  }
}
inline void DataChunk::set_allocated_chunk(std::string* chunk) {
  if (has_data()) {
    clear_data();
  }
  if (chunk != nullptr) {
    set_has_chunk();
    _impl_.data_.chunk_.InitAllocated(chunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DataChunk.chunk)
}

// int64 duration_ms = 3;
inline bool DataChunk::_internal_has_duration_ms() const {
  return data_case() == kDurationMs;
}
inline bool DataChunk::has_duration_ms() const {
  return _internal_has_duration_ms();
}
inline void DataChunk::set_has_duration_ms() {
  _impl_._oneof_case_[0] = kDurationMs;
}
inline void DataChunk::clear_duration_ms() {
  if (_internal_has_duration_ms()) {
    _impl_.data_.duration_ms_ = int64_t{0};
    clear_has_data();
  }
}
inline int64_t DataChunk::_internal_duration_ms() const {
  if (_internal_has_duration_ms()) {
    return _impl_.data_.duration_ms_;
  }
  return int64_t{0};
}
inline void DataChunk::_internal_set_duration_ms(int64_t value) {
  if (!_internal_has_duration_ms()) {
    clear_data();
    set_has_duration_ms();
  }
  _impl_.data_.duration_ms_ = value;
}
inline int64_t DataChunk::duration_ms() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.duration_ms)
  return _internal_duration_ms();
}
inline void DataChunk::set_duration_ms(int64_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.duration_ms)
}

// .ai.inworld.packets.DataChunk.DataType type = 2;
inline void DataChunk::clear_type() {
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::_internal_type() const {
  return static_cast< ::ai::inworld::packets::DataChunk_DataType >(_impl_.type_);
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.type)
  return _internal_type();
}
inline void DataChunk::_internal_set_type(::ai::inworld::packets::DataChunk_DataType value) {
  
  _impl_.type_ = value;
}
inline void DataChunk::set_type(::ai::inworld::packets::DataChunk_DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.type)
}

// repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
inline int DataChunk::_internal_additional_phoneme_info_size() const {
  return _impl_.additional_phoneme_info_.size();
}
inline int DataChunk::additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info_size();
}
inline void DataChunk::clear_additional_phoneme_info() {
  _impl_.additional_phoneme_info_.Clear();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::mutable_additional_phoneme_info(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _impl_.additional_phoneme_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
DataChunk::mutable_additional_phoneme_info() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return &_impl_.additional_phoneme_info_;
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::_internal_additional_phoneme_info(int index) const {
  return _impl_.additional_phoneme_info_.Get(index);
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::additional_phoneme_info(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info(index);
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::_internal_add_additional_phoneme_info() {
  return _impl_.additional_phoneme_info_.Add();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::add_additional_phoneme_info() {
  ::ai::inworld::packets::AdditionalPhonemeInfo* _add = _internal_add_additional_phoneme_info();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
DataChunk::additional_phoneme_info() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _impl_.additional_phoneme_info_;
}

inline bool DataChunk::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void DataChunk::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline DataChunk::DataCase DataChunk::data_case() const {
  return DataChunk::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdditionalPhonemeInfo

// string phoneme = 1;
inline void AdditionalPhonemeInfo::clear_phoneme() {
  _impl_.phoneme_.ClearToEmpty();
}
inline const std::string& AdditionalPhonemeInfo::phoneme() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_phoneme();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdditionalPhonemeInfo::set_phoneme(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phoneme_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::mutable_phoneme() {
  std::string* _s = _internal_mutable_phoneme();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _s;
}
inline const std::string& AdditionalPhonemeInfo::_internal_phoneme() const {
  return _impl_.phoneme_.Get();
}
inline void AdditionalPhonemeInfo::_internal_set_phoneme(const std::string& value) {
  
  _impl_.phoneme_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalPhonemeInfo::_internal_mutable_phoneme() {
  
  return _impl_.phoneme_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalPhonemeInfo::release_phoneme() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _impl_.phoneme_.Release();
}
inline void AdditionalPhonemeInfo::set_allocated_phoneme(std::string* phoneme) {
  if (phoneme != nullptr) {
    
  } else {
    
  }
  _impl_.phoneme_.SetAllocated(phoneme, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phoneme_.IsDefault()) {
    _impl_.phoneme_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}

// .google.protobuf.Duration start_offset = 2;
inline bool AdditionalPhonemeInfo::_internal_has_start_offset() const {
  return this != internal_default_instance() && _impl_.start_offset_ != nullptr;
}
inline bool AdditionalPhonemeInfo::has_start_offset() const {
  return _internal_has_start_offset();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::_internal_start_offset() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.start_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::start_offset() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_start_offset();
}
inline void AdditionalPhonemeInfo::unsafe_arena_set_allocated_start_offset(
    ::PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_offset_);
  }
  _impl_.start_offset_ = start_offset;
  if (start_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::release_start_offset() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::unsafe_arena_release_start_offset() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::_internal_mutable_start_offset() {
  
  if (_impl_.start_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.start_offset_ = p;
  }
  return _impl_.start_offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::mutable_start_offset() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_start_offset();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _msg;
}
inline void AdditionalPhonemeInfo::set_allocated_start_offset(::PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_offset_);
  }
  if (start_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset));
    if (message_arena != submessage_arena) {
      start_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_offset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_offset_ = start_offset;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace inworld
}  // namespace ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ai::inworld::packets::Actor_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Actor_Type>() {
  return ::ai::inworld::packets::Actor_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::TextEvent_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::TextEvent_SourceType>() {
  return ::ai::inworld::packets::TextEvent_SourceType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ControlEvent_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ControlEvent_Action>() {
  return ::ai::inworld::packets::ControlEvent_Action_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::GestureEvent_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::GestureEvent_Type>() {
  return ::ai::inworld::packets::GestureEvent_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_SpaffCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_SpaffCode>() {
  return ::ai::inworld::packets::EmotionEvent_SpaffCode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_Strength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_Strength>() {
  return ::ai::inworld::packets::EmotionEvent_Strength_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_DataType>() {
  return ::ai::inworld::packets::DataChunk_DataType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::Playback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Playback>() {
  return ::ai::inworld::packets::Playback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
