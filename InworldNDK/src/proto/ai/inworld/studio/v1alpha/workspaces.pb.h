// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ai/inworld/studio/v1alpha/workspaces.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/field_mask.pb.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
namespace ai {
namespace inworld {
namespace studio {
namespace v1alpha {
class CreateWorkspaceRequest;
struct CreateWorkspaceRequestDefaultTypeInternal;
extern CreateWorkspaceRequestDefaultTypeInternal _CreateWorkspaceRequest_default_instance_;
class DeleteWorkspaceRequest;
struct DeleteWorkspaceRequestDefaultTypeInternal;
extern DeleteWorkspaceRequestDefaultTypeInternal _DeleteWorkspaceRequest_default_instance_;
class GenerateResourceNameRequest;
struct GenerateResourceNameRequestDefaultTypeInternal;
extern GenerateResourceNameRequestDefaultTypeInternal _GenerateResourceNameRequest_default_instance_;
class GenerateResourceNameResponse;
struct GenerateResourceNameResponseDefaultTypeInternal;
extern GenerateResourceNameResponseDefaultTypeInternal _GenerateResourceNameResponse_default_instance_;
class GetWorkspaceBillingInfoRequest;
struct GetWorkspaceBillingInfoRequestDefaultTypeInternal;
extern GetWorkspaceBillingInfoRequestDefaultTypeInternal _GetWorkspaceBillingInfoRequest_default_instance_;
class GetWorkspaceLimitInfoRequest;
struct GetWorkspaceLimitInfoRequestDefaultTypeInternal;
extern GetWorkspaceLimitInfoRequestDefaultTypeInternal _GetWorkspaceLimitInfoRequest_default_instance_;
class GetWorkspaceRequest;
struct GetWorkspaceRequestDefaultTypeInternal;
extern GetWorkspaceRequestDefaultTypeInternal _GetWorkspaceRequest_default_instance_;
class GetWorkspaceShareInfoRequest;
struct GetWorkspaceShareInfoRequestDefaultTypeInternal;
extern GetWorkspaceShareInfoRequestDefaultTypeInternal _GetWorkspaceShareInfoRequest_default_instance_;
class ListWorkspacesRequest;
struct ListWorkspacesRequestDefaultTypeInternal;
extern ListWorkspacesRequestDefaultTypeInternal _ListWorkspacesRequest_default_instance_;
class ListWorkspacesResponse;
struct ListWorkspacesResponseDefaultTypeInternal;
extern ListWorkspacesResponseDefaultTypeInternal _ListWorkspacesResponse_default_instance_;
class ShareWorkspaceRequest;
struct ShareWorkspaceRequestDefaultTypeInternal;
extern ShareWorkspaceRequestDefaultTypeInternal _ShareWorkspaceRequest_default_instance_;
class UpdateWorkspaceRequest;
struct UpdateWorkspaceRequestDefaultTypeInternal;
extern UpdateWorkspaceRequestDefaultTypeInternal _UpdateWorkspaceRequest_default_instance_;
class Workspace;
struct WorkspaceDefaultTypeInternal;
extern WorkspaceDefaultTypeInternal _Workspace_default_instance_;
class WorkspaceBillingInfo;
struct WorkspaceBillingInfoDefaultTypeInternal;
extern WorkspaceBillingInfoDefaultTypeInternal _WorkspaceBillingInfo_default_instance_;
class WorkspaceBillingInfo_QuotaDetails;
struct WorkspaceBillingInfo_QuotaDetailsDefaultTypeInternal;
extern WorkspaceBillingInfo_QuotaDetailsDefaultTypeInternal _WorkspaceBillingInfo_QuotaDetails_default_instance_;
class WorkspaceLimitInfo;
struct WorkspaceLimitInfoDefaultTypeInternal;
extern WorkspaceLimitInfoDefaultTypeInternal _WorkspaceLimitInfo_default_instance_;
class WorkspaceLimitInfo_BillingAccountLimit;
struct WorkspaceLimitInfo_BillingAccountLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_BillingAccountLimitDefaultTypeInternal _WorkspaceLimitInfo_BillingAccountLimit_default_instance_;
class WorkspaceLimitInfo_CharacterLimit;
struct WorkspaceLimitInfo_CharacterLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CharacterLimitDefaultTypeInternal _WorkspaceLimitInfo_CharacterLimit_default_instance_;
class WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit;
struct WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimitDefaultTypeInternal _WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_;
class WorkspaceLimitInfo_CommonKnowledgeLimit;
struct WorkspaceLimitInfo_CommonKnowledgeLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CommonKnowledgeLimitDefaultTypeInternal _WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_;
class WorkspaceLimitInfo_SceneLimit;
struct WorkspaceLimitInfo_SceneLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_SceneLimitDefaultTypeInternal _WorkspaceLimitInfo_SceneLimit_default_instance_;
class WorkspaceLimitInfo_TextListLimit;
struct WorkspaceLimitInfo_TextListLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_TextListLimitDefaultTypeInternal _WorkspaceLimitInfo_TextListLimit_default_instance_;
class WorkspaceLimitInfo_WorkspaceLimit;
struct WorkspaceLimitInfo_WorkspaceLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_WorkspaceLimitDefaultTypeInternal _WorkspaceLimitInfo_WorkspaceLimit_default_instance_;
class WorkspaceShareInfo;
struct WorkspaceShareInfoDefaultTypeInternal;
extern WorkspaceShareInfoDefaultTypeInternal _WorkspaceShareInfo_default_instance_;
class Workspace_Meta;
struct Workspace_MetaDefaultTypeInternal;
extern Workspace_MetaDefaultTypeInternal _Workspace_Meta_default_instance_;
}  // namespace v1alpha
}  // namespace studio
}  // namespace inworld
}  // namespace ai
PROTOBUF_NAMESPACE_OPEN
template<> ::ai::inworld::studio::v1alpha::CreateWorkspaceRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::CreateWorkspaceRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::DeleteWorkspaceRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::DeleteWorkspaceRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GenerateResourceNameRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GenerateResourceNameResponse* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GenerateResourceNameResponse>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GetWorkspaceBillingInfoRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GetWorkspaceBillingInfoRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GetWorkspaceLimitInfoRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GetWorkspaceLimitInfoRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GetWorkspaceRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GetWorkspaceRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::GetWorkspaceShareInfoRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::GetWorkspaceShareInfoRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::ListWorkspacesRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::ListWorkspacesRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::ListWorkspacesResponse* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::ListWorkspacesResponse>(Arena*);
template<> ::ai::inworld::studio::v1alpha::ShareWorkspaceRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::ShareWorkspaceRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::UpdateWorkspaceRequest* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::UpdateWorkspaceRequest>(Arena*);
template<> ::ai::inworld::studio::v1alpha::Workspace* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceBillingInfo>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit>(Arena*);
template<> ::ai::inworld::studio::v1alpha::WorkspaceShareInfo* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceShareInfo>(Arena*);
template<> ::ai::inworld::studio::v1alpha::Workspace_Meta* Arena::CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace_Meta>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ai {
namespace inworld {
namespace studio {
namespace v1alpha {

enum GenerateResourceNameRequest_ResourceType : int {
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_UNSPECIFIED = 0,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_WORKSPACE = 1,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_CHARACTER = 2,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_SCENE = 3,
  GenerateResourceNameRequest_ResourceType_GenerateResourceNameRequest_ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GenerateResourceNameRequest_ResourceType_GenerateResourceNameRequest_ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GenerateResourceNameRequest_ResourceType_IsValid(int value);
constexpr GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest_ResourceType_ResourceType_MIN = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_UNSPECIFIED;
constexpr GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest_ResourceType_ResourceType_MAX = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_SCENE;
constexpr int GenerateResourceNameRequest_ResourceType_ResourceType_ARRAYSIZE = GenerateResourceNameRequest_ResourceType_ResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GenerateResourceNameRequest_ResourceType_descriptor();
template<typename T>
inline const std::string& GenerateResourceNameRequest_ResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GenerateResourceNameRequest_ResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GenerateResourceNameRequest_ResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GenerateResourceNameRequest_ResourceType_descriptor(), enum_t_value);
}
inline bool GenerateResourceNameRequest_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GenerateResourceNameRequest_ResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GenerateResourceNameRequest_ResourceType>(
    GenerateResourceNameRequest_ResourceType_descriptor(), name, value);
}
enum WorkspaceBillingInfo_QuotaSource : int {
  WorkspaceBillingInfo_QuotaSource_QUOTA_SOURCE_UNSPECIFIED = 0,
  WorkspaceBillingInfo_QuotaSource_NO_SOURCES = 1,
  WorkspaceBillingInfo_QuotaSource_SUBSCRIPTION = 2,
  WorkspaceBillingInfo_QuotaSource_CREDITS = 3,
  WorkspaceBillingInfo_QuotaSource_OVERAGE = 4,
  WorkspaceBillingInfo_QuotaSource_WorkspaceBillingInfo_QuotaSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorkspaceBillingInfo_QuotaSource_WorkspaceBillingInfo_QuotaSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorkspaceBillingInfo_QuotaSource_IsValid(int value);
constexpr WorkspaceBillingInfo_QuotaSource WorkspaceBillingInfo_QuotaSource_QuotaSource_MIN = WorkspaceBillingInfo_QuotaSource_QUOTA_SOURCE_UNSPECIFIED;
constexpr WorkspaceBillingInfo_QuotaSource WorkspaceBillingInfo_QuotaSource_QuotaSource_MAX = WorkspaceBillingInfo_QuotaSource_OVERAGE;
constexpr int WorkspaceBillingInfo_QuotaSource_QuotaSource_ARRAYSIZE = WorkspaceBillingInfo_QuotaSource_QuotaSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkspaceBillingInfo_QuotaSource_descriptor();
template<typename T>
inline const std::string& WorkspaceBillingInfo_QuotaSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkspaceBillingInfo_QuotaSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkspaceBillingInfo_QuotaSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkspaceBillingInfo_QuotaSource_descriptor(), enum_t_value);
}
inline bool WorkspaceBillingInfo_QuotaSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkspaceBillingInfo_QuotaSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkspaceBillingInfo_QuotaSource>(
    WorkspaceBillingInfo_QuotaSource_descriptor(), name, value);
}
enum WorkspaceItemView : int {
  WORKSPACE_ITEM_VIEW_UNSPECIFIED = 0,
  WORKSPACE_ITEM_VIEW_DEFAULT = 1,
  WORKSPACE_ITEM_VIEW_WITH_META = 2,
  WorkspaceItemView_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorkspaceItemView_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorkspaceItemView_IsValid(int value);
constexpr WorkspaceItemView WorkspaceItemView_MIN = WORKSPACE_ITEM_VIEW_UNSPECIFIED;
constexpr WorkspaceItemView WorkspaceItemView_MAX = WORKSPACE_ITEM_VIEW_WITH_META;
constexpr int WorkspaceItemView_ARRAYSIZE = WorkspaceItemView_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkspaceItemView_descriptor();
template<typename T>
inline const std::string& WorkspaceItemView_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkspaceItemView>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkspaceItemView_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkspaceItemView_descriptor(), enum_t_value);
}
inline bool WorkspaceItemView_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkspaceItemView* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkspaceItemView>(
    WorkspaceItemView_descriptor(), name, value);
}
// ===================================================================

class GetWorkspaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceRequest) */ {
 public:
  inline GetWorkspaceRequest() : GetWorkspaceRequest(nullptr) {}
  ~GetWorkspaceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkspaceRequest(const GetWorkspaceRequest& from);
  GetWorkspaceRequest(GetWorkspaceRequest&& from) noexcept
    : GetWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceRequest& operator=(const GetWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceRequest& operator=(GetWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceRequest*>(
               &_GetWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetWorkspaceRequest& a, GetWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceRequest& from) {
    GetWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkspaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceRequest";
  }
  protected:
  explicit GetWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kViewFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.studio.v1alpha.WorkspaceItemView view = 2;
  void clear_view();
  ::ai::inworld::studio::v1alpha::WorkspaceItemView view() const;
  void set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value);
  private:
  ::ai::inworld::studio::v1alpha::WorkspaceItemView _internal_view() const;
  void _internal_set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int view_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class ListWorkspacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ListWorkspacesRequest) */ {
 public:
  inline ListWorkspacesRequest() : ListWorkspacesRequest(nullptr) {}
  ~ListWorkspacesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListWorkspacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListWorkspacesRequest(const ListWorkspacesRequest& from);
  ListWorkspacesRequest(ListWorkspacesRequest&& from) noexcept
    : ListWorkspacesRequest() {
    *this = ::std::move(from);
  }

  inline ListWorkspacesRequest& operator=(const ListWorkspacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkspacesRequest& operator=(ListWorkspacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkspacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkspacesRequest* internal_default_instance() {
    return reinterpret_cast<const ListWorkspacesRequest*>(
               &_ListWorkspacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListWorkspacesRequest& a, ListWorkspacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkspacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkspacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkspacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkspacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListWorkspacesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListWorkspacesRequest& from) {
    ListWorkspacesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListWorkspacesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.ListWorkspacesRequest";
  }
  protected:
  explicit ListWorkspacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ListWorkspacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class CreateWorkspaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.CreateWorkspaceRequest) */ {
 public:
  inline CreateWorkspaceRequest() : CreateWorkspaceRequest(nullptr) {}
  ~CreateWorkspaceRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateWorkspaceRequest(const CreateWorkspaceRequest& from);
  CreateWorkspaceRequest(CreateWorkspaceRequest&& from) noexcept
    : CreateWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline CreateWorkspaceRequest& operator=(const CreateWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateWorkspaceRequest& operator=(CreateWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateWorkspaceRequest*>(
               &_CreateWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateWorkspaceRequest& a, CreateWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateWorkspaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateWorkspaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateWorkspaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateWorkspaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateWorkspaceRequest& from) {
    CreateWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWorkspaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.CreateWorkspaceRequest";
  }
  protected:
  explicit CreateWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
  };
  // .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_workspace() const;
  private:
  bool _internal_has_workspace() const;
  public:
  void clear_workspace();
  const ::ai::inworld::studio::v1alpha::Workspace& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace* release_workspace();
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* workspace);
  private:
  const ::ai::inworld::studio::v1alpha::Workspace& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::Workspace* _internal_mutable_workspace();
  public:
  void unsafe_arena_set_allocated_workspace(
      ::ai::inworld::studio::v1alpha::Workspace* workspace);
  ::ai::inworld::studio::v1alpha::Workspace* unsafe_arena_release_workspace();

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.CreateWorkspaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::Workspace* workspace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkspaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest) */ {
 public:
  inline UpdateWorkspaceRequest() : UpdateWorkspaceRequest(nullptr) {}
  ~UpdateWorkspaceRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateWorkspaceRequest(const UpdateWorkspaceRequest& from);
  UpdateWorkspaceRequest(UpdateWorkspaceRequest&& from) noexcept
    : UpdateWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateWorkspaceRequest& operator=(const UpdateWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkspaceRequest& operator=(UpdateWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkspaceRequest*>(
               &_UpdateWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateWorkspaceRequest& a, UpdateWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkspaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkspaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkspaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateWorkspaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateWorkspaceRequest& from) {
    UpdateWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkspaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.UpdateWorkspaceRequest";
  }
  protected:
  explicit UpdateWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_workspace() const;
  private:
  bool _internal_has_workspace() const;
  public:
  void clear_workspace();
  const ::ai::inworld::studio::v1alpha::Workspace& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace* release_workspace();
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* workspace);
  private:
  const ::ai::inworld::studio::v1alpha::Workspace& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::Workspace* _internal_mutable_workspace();
  public:
  void unsafe_arena_set_allocated_workspace(
      ::ai::inworld::studio::v1alpha::Workspace* workspace);
  ::ai::inworld::studio::v1alpha::Workspace* unsafe_arena_release_workspace();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::Workspace* workspace_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class DeleteWorkspaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest) */ {
 public:
  inline DeleteWorkspaceRequest() : DeleteWorkspaceRequest(nullptr) {}
  ~DeleteWorkspaceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteWorkspaceRequest(const DeleteWorkspaceRequest& from);
  DeleteWorkspaceRequest(DeleteWorkspaceRequest&& from) noexcept
    : DeleteWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteWorkspaceRequest& operator=(const DeleteWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteWorkspaceRequest& operator=(DeleteWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteWorkspaceRequest*>(
               &_DeleteWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteWorkspaceRequest& a, DeleteWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteWorkspaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteWorkspaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteWorkspaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteWorkspaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteWorkspaceRequest& from) {
    DeleteWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteWorkspaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.DeleteWorkspaceRequest";
  }
  protected:
  explicit DeleteWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kForceFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class Workspace_Meta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.Workspace.Meta) */ {
 public:
  inline Workspace_Meta() : Workspace_Meta(nullptr) {}
  ~Workspace_Meta() override;
  explicit PROTOBUF_CONSTEXPR Workspace_Meta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Workspace_Meta(const Workspace_Meta& from);
  Workspace_Meta(Workspace_Meta&& from) noexcept
    : Workspace_Meta() {
    *this = ::std::move(from);
  }

  inline Workspace_Meta& operator=(const Workspace_Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workspace_Meta& operator=(Workspace_Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workspace_Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workspace_Meta* internal_default_instance() {
    return reinterpret_cast<const Workspace_Meta*>(
               &_Workspace_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Workspace_Meta& a, Workspace_Meta& b) {
    a.Swap(&b);
  }
  inline void Swap(Workspace_Meta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workspace_Meta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workspace_Meta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Workspace_Meta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Workspace_Meta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Workspace_Meta& from) {
    Workspace_Meta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Workspace_Meta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.Workspace.Meta";
  }
  protected:
  explicit Workspace_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalCharactersFieldNumber = 1,
    kTotalScenesFieldNumber = 2,
    kTotalTriggersFieldNumber = 3,
    kTotalCommonKnowledgeFieldNumber = 4,
  };
  // int32 total_characters = 1;
  void clear_total_characters();
  int32_t total_characters() const;
  void set_total_characters(int32_t value);
  private:
  int32_t _internal_total_characters() const;
  void _internal_set_total_characters(int32_t value);
  public:

  // int32 total_scenes = 2;
  void clear_total_scenes();
  int32_t total_scenes() const;
  void set_total_scenes(int32_t value);
  private:
  int32_t _internal_total_scenes() const;
  void _internal_set_total_scenes(int32_t value);
  public:

  // int32 total_triggers = 3;
  void clear_total_triggers();
  int32_t total_triggers() const;
  void set_total_triggers(int32_t value);
  private:
  int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(int32_t value);
  public:

  // int32 total_common_knowledge = 4;
  void clear_total_common_knowledge();
  int32_t total_common_knowledge() const;
  void set_total_common_knowledge(int32_t value);
  private:
  int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.Workspace.Meta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t total_characters_;
    int32_t total_scenes_;
    int32_t total_triggers_;
    int32_t total_common_knowledge_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class Workspace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.Workspace) */ {
 public:
  inline Workspace() : Workspace(nullptr) {}
  ~Workspace() override;
  explicit PROTOBUF_CONSTEXPR Workspace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Workspace(const Workspace& from);
  Workspace(Workspace&& from) noexcept
    : Workspace() {
    *this = ::std::move(from);
  }

  inline Workspace& operator=(const Workspace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workspace& operator=(Workspace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workspace& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workspace* internal_default_instance() {
    return reinterpret_cast<const Workspace*>(
               &_Workspace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Workspace& a, Workspace& b) {
    a.Swap(&b);
  }
  inline void Swap(Workspace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workspace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workspace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Workspace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Workspace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Workspace& from) {
    Workspace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Workspace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.Workspace";
  }
  protected:
  explicit Workspace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Workspace_Meta Meta;

  // accessors -------------------------------------------------------

  enum : int {
    kExperimentalFeaturesFieldNumber = 3,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kBillingAccountFieldNumber = 4,
    kMetaFieldNumber = 5,
  };
  // repeated string experimental_features = 3;
  int experimental_features_size() const;
  private:
  int _internal_experimental_features_size() const;
  public:
  void clear_experimental_features();
  const std::string& experimental_features(int index) const;
  std::string* mutable_experimental_features(int index);
  void set_experimental_features(int index, const std::string& value);
  void set_experimental_features(int index, std::string&& value);
  void set_experimental_features(int index, const char* value);
  void set_experimental_features(int index, const char* value, size_t size);
  std::string* add_experimental_features();
  void add_experimental_features(const std::string& value);
  void add_experimental_features(std::string&& value);
  void add_experimental_features(const char* value);
  void add_experimental_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& experimental_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_experimental_features();
  private:
  const std::string& _internal_experimental_features(int index) const;
  std::string* _internal_add_experimental_features();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.ai.inworld.options.examples) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string billing_account = 4 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_billing_account();
  const std::string& billing_account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_billing_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_billing_account();
  PROTOBUF_NODISCARD std::string* release_billing_account();
  void set_allocated_billing_account(std::string* billing_account);
  private:
  const std::string& _internal_billing_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_account(const std::string& value);
  std::string* _internal_mutable_billing_account();
  public:

  // .ai.inworld.studio.v1alpha.Workspace.Meta meta = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::ai::inworld::studio::v1alpha::Workspace_Meta& meta() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace_Meta* release_meta();
  ::ai::inworld::studio::v1alpha::Workspace_Meta* mutable_meta();
  void set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* meta);
  private:
  const ::ai::inworld::studio::v1alpha::Workspace_Meta& _internal_meta() const;
  ::ai::inworld::studio::v1alpha::Workspace_Meta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::ai::inworld::studio::v1alpha::Workspace_Meta* meta);
  ::ai::inworld::studio::v1alpha::Workspace_Meta* unsafe_arena_release_meta();

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.Workspace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> experimental_features_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_account_;
    ::ai::inworld::studio::v1alpha::Workspace_Meta* meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class ListWorkspacesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ListWorkspacesResponse) */ {
 public:
  inline ListWorkspacesResponse() : ListWorkspacesResponse(nullptr) {}
  ~ListWorkspacesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListWorkspacesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListWorkspacesResponse(const ListWorkspacesResponse& from);
  ListWorkspacesResponse(ListWorkspacesResponse&& from) noexcept
    : ListWorkspacesResponse() {
    *this = ::std::move(from);
  }

  inline ListWorkspacesResponse& operator=(const ListWorkspacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkspacesResponse& operator=(ListWorkspacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkspacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkspacesResponse* internal_default_instance() {
    return reinterpret_cast<const ListWorkspacesResponse*>(
               &_ListWorkspacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListWorkspacesResponse& a, ListWorkspacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkspacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkspacesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkspacesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkspacesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListWorkspacesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListWorkspacesResponse& from) {
    ListWorkspacesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListWorkspacesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.ListWorkspacesResponse";
  }
  protected:
  explicit ListWorkspacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .ai.inworld.studio.v1alpha.Workspace workspaces = 1;
  int workspaces_size() const;
  private:
  int _internal_workspaces_size() const;
  public:
  void clear_workspaces();
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >*
      mutable_workspaces();
  private:
  const ::ai::inworld::studio::v1alpha::Workspace& _internal_workspaces(int index) const;
  ::ai::inworld::studio::v1alpha::Workspace* _internal_add_workspaces();
  public:
  const ::ai::inworld::studio::v1alpha::Workspace& workspaces(int index) const;
  ::ai::inworld::studio::v1alpha::Workspace* add_workspaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >&
      workspaces() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ListWorkspacesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace > workspaces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class ShareWorkspaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ShareWorkspaceRequest) */ {
 public:
  inline ShareWorkspaceRequest() : ShareWorkspaceRequest(nullptr) {}
  ~ShareWorkspaceRequest() override;
  explicit PROTOBUF_CONSTEXPR ShareWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareWorkspaceRequest(const ShareWorkspaceRequest& from);
  ShareWorkspaceRequest(ShareWorkspaceRequest&& from) noexcept
    : ShareWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline ShareWorkspaceRequest& operator=(const ShareWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareWorkspaceRequest& operator=(ShareWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const ShareWorkspaceRequest*>(
               &_ShareWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ShareWorkspaceRequest& a, ShareWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareWorkspaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareWorkspaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareWorkspaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareWorkspaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareWorkspaceRequest& from) {
    ShareWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareWorkspaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.ShareWorkspaceRequest";
  }
  protected:
  explicit ShareWorkspaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated string emails = 2 [(.ai.inworld.options.examples) = {
  int emails_size() const;
  private:
  int _internal_emails_size() const;
  public:
  void clear_emails();
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, size_t size);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& emails() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_emails();
  private:
  const std::string& _internal_emails(int index) const;
  std::string* _internal_add_emails();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ShareWorkspaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> emails_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class GenerateResourceNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GenerateResourceNameRequest) */ {
 public:
  inline GenerateResourceNameRequest() : GenerateResourceNameRequest(nullptr) {}
  ~GenerateResourceNameRequest() override;
  explicit PROTOBUF_CONSTEXPR GenerateResourceNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateResourceNameRequest(const GenerateResourceNameRequest& from);
  GenerateResourceNameRequest(GenerateResourceNameRequest&& from) noexcept
    : GenerateResourceNameRequest() {
    *this = ::std::move(from);
  }

  inline GenerateResourceNameRequest& operator=(const GenerateResourceNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateResourceNameRequest& operator=(GenerateResourceNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateResourceNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateResourceNameRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateResourceNameRequest*>(
               &_GenerateResourceNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GenerateResourceNameRequest& a, GenerateResourceNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateResourceNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateResourceNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateResourceNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateResourceNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateResourceNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateResourceNameRequest& from) {
    GenerateResourceNameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateResourceNameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GenerateResourceNameRequest";
  }
  protected:
  explicit GenerateResourceNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GenerateResourceNameRequest_ResourceType ResourceType;
  static constexpr ResourceType RESOURCE_TYPE_UNSPECIFIED =
    GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_UNSPECIFIED;
  static constexpr ResourceType RESOURCE_TYPE_WORKSPACE =
    GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_WORKSPACE;
  static constexpr ResourceType RESOURCE_TYPE_CHARACTER =
    GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_CHARACTER;
  static constexpr ResourceType RESOURCE_TYPE_SCENE =
    GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_SCENE;
  static inline bool ResourceType_IsValid(int value) {
    return GenerateResourceNameRequest_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN =
    GenerateResourceNameRequest_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX =
    GenerateResourceNameRequest_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE =
    GenerateResourceNameRequest_ResourceType_ResourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResourceType_descriptor() {
    return GenerateResourceNameRequest_ResourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ResourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResourceType_Name.");
    return GenerateResourceNameRequest_ResourceType_Name(enum_t_value);
  }
  static inline bool ResourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResourceType* value) {
    return GenerateResourceNameRequest_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
  };
  // string workspace = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_workspace();
  const std::string& workspace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workspace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workspace();
  PROTOBUF_NODISCARD std::string* release_workspace();
  void set_allocated_workspace(std::string* workspace);
  private:
  const std::string& _internal_workspace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workspace(const std::string& value);
  std::string* _internal_mutable_workspace();
  public:

  // string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .ai.inworld.studio.v1alpha.GenerateResourceNameRequest.ResourceType resource_type = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_resource_type();
  ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType resource_type() const;
  void set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value);
  private:
  ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GenerateResourceNameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workspace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    int resource_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class GenerateResourceNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GenerateResourceNameResponse) */ {
 public:
  inline GenerateResourceNameResponse() : GenerateResourceNameResponse(nullptr) {}
  ~GenerateResourceNameResponse() override;
  explicit PROTOBUF_CONSTEXPR GenerateResourceNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateResourceNameResponse(const GenerateResourceNameResponse& from);
  GenerateResourceNameResponse(GenerateResourceNameResponse&& from) noexcept
    : GenerateResourceNameResponse() {
    *this = ::std::move(from);
  }

  inline GenerateResourceNameResponse& operator=(const GenerateResourceNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateResourceNameResponse& operator=(GenerateResourceNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateResourceNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateResourceNameResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateResourceNameResponse*>(
               &_GenerateResourceNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GenerateResourceNameResponse& a, GenerateResourceNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateResourceNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateResourceNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateResourceNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateResourceNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateResourceNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateResourceNameResponse& from) {
    GenerateResourceNameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateResourceNameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GenerateResourceNameResponse";
  }
  protected:
  explicit GenerateResourceNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceFieldNumber = 1,
  };
  // string resource = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GenerateResourceNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class GetWorkspaceShareInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest) */ {
 public:
  inline GetWorkspaceShareInfoRequest() : GetWorkspaceShareInfoRequest(nullptr) {}
  ~GetWorkspaceShareInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetWorkspaceShareInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkspaceShareInfoRequest(const GetWorkspaceShareInfoRequest& from);
  GetWorkspaceShareInfoRequest(GetWorkspaceShareInfoRequest&& from) noexcept
    : GetWorkspaceShareInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceShareInfoRequest& operator=(const GetWorkspaceShareInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceShareInfoRequest& operator=(GetWorkspaceShareInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceShareInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceShareInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceShareInfoRequest*>(
               &_GetWorkspaceShareInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetWorkspaceShareInfoRequest& a, GetWorkspaceShareInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceShareInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceShareInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceShareInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceShareInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceShareInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceShareInfoRequest& from) {
    GetWorkspaceShareInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkspaceShareInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest";
  }
  protected:
  explicit GetWorkspaceShareInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceShareInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceShareInfo) */ {
 public:
  inline WorkspaceShareInfo() : WorkspaceShareInfo(nullptr) {}
  ~WorkspaceShareInfo() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceShareInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceShareInfo(const WorkspaceShareInfo& from);
  WorkspaceShareInfo(WorkspaceShareInfo&& from) noexcept
    : WorkspaceShareInfo() {
    *this = ::std::move(from);
  }

  inline WorkspaceShareInfo& operator=(const WorkspaceShareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceShareInfo& operator=(WorkspaceShareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceShareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceShareInfo* internal_default_instance() {
    return reinterpret_cast<const WorkspaceShareInfo*>(
               &_WorkspaceShareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WorkspaceShareInfo& a, WorkspaceShareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceShareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceShareInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceShareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceShareInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceShareInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceShareInfo& from) {
    WorkspaceShareInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceShareInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceShareInfo";
  }
  protected:
  explicit WorkspaceShareInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 1,
  };
  // repeated string emails = 1;
  int emails_size() const;
  private:
  int _internal_emails_size() const;
  public:
  void clear_emails();
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, size_t size);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& emails() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_emails();
  private:
  const std::string& _internal_emails(int index) const;
  std::string* _internal_add_emails();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceShareInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> emails_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class GetWorkspaceLimitInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest) */ {
 public:
  inline GetWorkspaceLimitInfoRequest() : GetWorkspaceLimitInfoRequest(nullptr) {}
  ~GetWorkspaceLimitInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetWorkspaceLimitInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkspaceLimitInfoRequest(const GetWorkspaceLimitInfoRequest& from);
  GetWorkspaceLimitInfoRequest(GetWorkspaceLimitInfoRequest&& from) noexcept
    : GetWorkspaceLimitInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceLimitInfoRequest& operator=(const GetWorkspaceLimitInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceLimitInfoRequest& operator=(GetWorkspaceLimitInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceLimitInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceLimitInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceLimitInfoRequest*>(
               &_GetWorkspaceLimitInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetWorkspaceLimitInfoRequest& a, GetWorkspaceLimitInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceLimitInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceLimitInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceLimitInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceLimitInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceLimitInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceLimitInfoRequest& from) {
    GetWorkspaceLimitInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkspaceLimitInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest";
  }
  protected:
  explicit GetWorkspaceLimitInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_TextListLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit) */ {
 public:
  inline WorkspaceLimitInfo_TextListLimit() : WorkspaceLimitInfo_TextListLimit(nullptr) {}
  ~WorkspaceLimitInfo_TextListLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_TextListLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_TextListLimit(const WorkspaceLimitInfo_TextListLimit& from);
  WorkspaceLimitInfo_TextListLimit(WorkspaceLimitInfo_TextListLimit&& from) noexcept
    : WorkspaceLimitInfo_TextListLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_TextListLimit& operator=(const WorkspaceLimitInfo_TextListLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_TextListLimit& operator=(WorkspaceLimitInfo_TextListLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_TextListLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_TextListLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_TextListLimit*>(
               &_WorkspaceLimitInfo_TextListLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WorkspaceLimitInfo_TextListLimit& a, WorkspaceLimitInfo_TextListLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_TextListLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_TextListLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_TextListLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_TextListLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_TextListLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_TextListLimit& from) {
    WorkspaceLimitInfo_TextListLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_TextListLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_TextListLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemMaxLengthFieldNumber = 1,
    kTotalItemsFieldNumber = 2,
  };
  // int32 item_max_length = 1;
  void clear_item_max_length();
  int32_t item_max_length() const;
  void set_item_max_length(int32_t value);
  private:
  int32_t _internal_item_max_length() const;
  void _internal_set_item_max_length(int32_t value);
  public:

  // int32 total_items = 2;
  void clear_total_items();
  int32_t total_items() const;
  void set_total_items(int32_t value);
  private:
  int32_t _internal_total_items() const;
  void _internal_set_total_items(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_max_length_;
    int32_t total_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit) */ {
 public:
  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() : WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(nullptr) {}
  ~WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from);
  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&& from) noexcept
    : WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& operator=(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& operator=(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(
               &_WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& a, WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from) {
    WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHobbyOrInterestsFieldNumber = 5,
    kNicknamesFieldNumber = 6,
    kPersonalityAdjectivesFieldNumber = 7,
    kCoreMaxLengthFieldNumber = 1,
    kExampleDialogMaxLengthFieldNumber = 2,
    kMotivationMaxLengthFieldNumber = 3,
    kCharacterRoleMaxLengthFieldNumber = 4,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit hobby_or_interests = 5;
  bool has_hobby_or_interests() const;
  private:
  bool _internal_has_hobby_or_interests() const;
  public:
  void clear_hobby_or_interests();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& hobby_or_interests() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_hobby_or_interests();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_hobby_or_interests();
  void set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_hobby_or_interests() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_hobby_or_interests();
  public:
  void unsafe_arena_set_allocated_hobby_or_interests(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_hobby_or_interests();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit nicknames = 6;
  bool has_nicknames() const;
  private:
  bool _internal_has_nicknames() const;
  public:
  void clear_nicknames();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& nicknames() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_nicknames();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_nicknames();
  void set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_nicknames() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_nicknames();
  public:
  void unsafe_arena_set_allocated_nicknames(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_nicknames();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit personality_adjectives = 7;
  bool has_personality_adjectives() const;
  private:
  bool _internal_has_personality_adjectives() const;
  public:
  void clear_personality_adjectives();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& personality_adjectives() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_personality_adjectives();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_personality_adjectives();
  void set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_personality_adjectives() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_personality_adjectives();
  public:
  void unsafe_arena_set_allocated_personality_adjectives(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_personality_adjectives();

  // int32 core_max_length = 1;
  void clear_core_max_length();
  int32_t core_max_length() const;
  void set_core_max_length(int32_t value);
  private:
  int32_t _internal_core_max_length() const;
  void _internal_set_core_max_length(int32_t value);
  public:

  // int32 example_dialog_max_length = 2;
  void clear_example_dialog_max_length();
  int32_t example_dialog_max_length() const;
  void set_example_dialog_max_length(int32_t value);
  private:
  int32_t _internal_example_dialog_max_length() const;
  void _internal_set_example_dialog_max_length(int32_t value);
  public:

  // int32 motivation_max_length = 3;
  void clear_motivation_max_length();
  int32_t motivation_max_length() const;
  void set_motivation_max_length(int32_t value);
  private:
  int32_t _internal_motivation_max_length() const;
  void _internal_set_motivation_max_length(int32_t value);
  public:

  // int32 character_role_max_length = 4;
  void clear_character_role_max_length();
  int32_t character_role_max_length() const;
  void set_character_role_max_length(int32_t value);
  private:
  int32_t _internal_character_role_max_length() const;
  void _internal_set_character_role_max_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives_;
    int32_t core_max_length_;
    int32_t example_dialog_max_length_;
    int32_t motivation_max_length_;
    int32_t character_role_max_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_CharacterLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit) */ {
 public:
  inline WorkspaceLimitInfo_CharacterLimit() : WorkspaceLimitInfo_CharacterLimit(nullptr) {}
  ~WorkspaceLimitInfo_CharacterLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CharacterLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_CharacterLimit(const WorkspaceLimitInfo_CharacterLimit& from);
  WorkspaceLimitInfo_CharacterLimit(WorkspaceLimitInfo_CharacterLimit&& from) noexcept
    : WorkspaceLimitInfo_CharacterLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CharacterLimit& operator=(const WorkspaceLimitInfo_CharacterLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CharacterLimit& operator=(WorkspaceLimitInfo_CharacterLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CharacterLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CharacterLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CharacterLimit*>(
               &_WorkspaceLimitInfo_CharacterLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WorkspaceLimitInfo_CharacterLimit& a, WorkspaceLimitInfo_CharacterLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CharacterLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CharacterLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CharacterLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CharacterLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CharacterLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CharacterLimit& from) {
    WorkspaceLimitInfo_CharacterLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_CharacterLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CharacterLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit CharacterDescriptionLimit;

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterDescriptionFieldNumber = 4,
    kNameMaxLengthFieldNumber = 1,
    kTotalTriggersFieldNumber = 2,
    kTotalCommonKnowledgeFieldNumber = 3,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit character_description = 4;
  bool has_character_description() const;
  private:
  bool _internal_has_character_description() const;
  public:
  void clear_character_description();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& character_description() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* release_character_description();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* mutable_character_description();
  void set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& _internal_character_description() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* _internal_mutable_character_description();
  public:
  void unsafe_arena_set_allocated_character_description(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* unsafe_arena_release_character_description();

  // int32 name_max_length = 1;
  void clear_name_max_length();
  int32_t name_max_length() const;
  void set_name_max_length(int32_t value);
  private:
  int32_t _internal_name_max_length() const;
  void _internal_set_name_max_length(int32_t value);
  public:

  // int32 total_triggers = 2;
  void clear_total_triggers();
  int32_t total_triggers() const;
  void set_total_triggers(int32_t value);
  private:
  int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(int32_t value);
  public:

  // int32 total_common_knowledge = 3;
  void clear_total_common_knowledge();
  int32_t total_common_knowledge() const;
  void set_total_common_knowledge(int32_t value);
  private:
  int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description_;
    int32_t name_max_length_;
    int32_t total_triggers_;
    int32_t total_common_knowledge_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_SceneLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit) */ {
 public:
  inline WorkspaceLimitInfo_SceneLimit() : WorkspaceLimitInfo_SceneLimit(nullptr) {}
  ~WorkspaceLimitInfo_SceneLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_SceneLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_SceneLimit(const WorkspaceLimitInfo_SceneLimit& from);
  WorkspaceLimitInfo_SceneLimit(WorkspaceLimitInfo_SceneLimit&& from) noexcept
    : WorkspaceLimitInfo_SceneLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_SceneLimit& operator=(const WorkspaceLimitInfo_SceneLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_SceneLimit& operator=(WorkspaceLimitInfo_SceneLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_SceneLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_SceneLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_SceneLimit*>(
               &_WorkspaceLimitInfo_SceneLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WorkspaceLimitInfo_SceneLimit& a, WorkspaceLimitInfo_SceneLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_SceneLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_SceneLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_SceneLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_SceneLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_SceneLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_SceneLimit& from) {
    WorkspaceLimitInfo_SceneLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_SceneLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_SceneLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionMaxLengthFieldNumber = 1,
    kTotalCharactersFieldNumber = 2,
    kTotalTriggersFieldNumber = 3,
    kDisplayNameMaxLengthFieldNumber = 4,
  };
  // int32 description_max_length = 1;
  void clear_description_max_length();
  int32_t description_max_length() const;
  void set_description_max_length(int32_t value);
  private:
  int32_t _internal_description_max_length() const;
  void _internal_set_description_max_length(int32_t value);
  public:

  // int32 total_characters = 2;
  void clear_total_characters();
  int32_t total_characters() const;
  void set_total_characters(int32_t value);
  private:
  int32_t _internal_total_characters() const;
  void _internal_set_total_characters(int32_t value);
  public:

  // int32 total_triggers = 3;
  void clear_total_triggers();
  int32_t total_triggers() const;
  void set_total_triggers(int32_t value);
  private:
  int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(int32_t value);
  public:

  // int32 display_name_max_length = 4;
  void clear_display_name_max_length();
  int32_t display_name_max_length() const;
  void set_display_name_max_length(int32_t value);
  private:
  int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t description_max_length_;
    int32_t total_characters_;
    int32_t total_triggers_;
    int32_t display_name_max_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_WorkspaceLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit) */ {
 public:
  inline WorkspaceLimitInfo_WorkspaceLimit() : WorkspaceLimitInfo_WorkspaceLimit(nullptr) {}
  ~WorkspaceLimitInfo_WorkspaceLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_WorkspaceLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_WorkspaceLimit(const WorkspaceLimitInfo_WorkspaceLimit& from);
  WorkspaceLimitInfo_WorkspaceLimit(WorkspaceLimitInfo_WorkspaceLimit&& from) noexcept
    : WorkspaceLimitInfo_WorkspaceLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_WorkspaceLimit& operator=(const WorkspaceLimitInfo_WorkspaceLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_WorkspaceLimit& operator=(WorkspaceLimitInfo_WorkspaceLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_WorkspaceLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_WorkspaceLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_WorkspaceLimit*>(
               &_WorkspaceLimitInfo_WorkspaceLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WorkspaceLimitInfo_WorkspaceLimit& a, WorkspaceLimitInfo_WorkspaceLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_WorkspaceLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_WorkspaceLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_WorkspaceLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_WorkspaceLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_WorkspaceLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_WorkspaceLimit& from) {
    WorkspaceLimitInfo_WorkspaceLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_WorkspaceLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_WorkspaceLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameMaxLengthFieldNumber = 1,
    kTotalCharactersFieldNumber = 2,
    kTotalScenesFieldNumber = 3,
    kTotalTriggersFieldNumber = 4,
    kTotalVoicesFieldNumber = 5,
    kTotalCommonKnowledgeFieldNumber = 6,
  };
  // int32 display_name_max_length = 1;
  void clear_display_name_max_length();
  int32_t display_name_max_length() const;
  void set_display_name_max_length(int32_t value);
  private:
  int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(int32_t value);
  public:

  // int32 total_characters = 2;
  void clear_total_characters();
  int32_t total_characters() const;
  void set_total_characters(int32_t value);
  private:
  int32_t _internal_total_characters() const;
  void _internal_set_total_characters(int32_t value);
  public:

  // int32 total_scenes = 3;
  void clear_total_scenes();
  int32_t total_scenes() const;
  void set_total_scenes(int32_t value);
  private:
  int32_t _internal_total_scenes() const;
  void _internal_set_total_scenes(int32_t value);
  public:

  // int32 total_triggers = 4;
  void clear_total_triggers();
  int32_t total_triggers() const;
  void set_total_triggers(int32_t value);
  private:
  int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(int32_t value);
  public:

  // int32 total_voices = 5;
  void clear_total_voices();
  int32_t total_voices() const;
  void set_total_voices(int32_t value);
  private:
  int32_t _internal_total_voices() const;
  void _internal_set_total_voices(int32_t value);
  public:

  // int32 total_common_knowledge = 6;
  void clear_total_common_knowledge();
  int32_t total_common_knowledge() const;
  void set_total_common_knowledge(int32_t value);
  private:
  int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t display_name_max_length_;
    int32_t total_characters_;
    int32_t total_scenes_;
    int32_t total_triggers_;
    int32_t total_voices_;
    int32_t total_common_knowledge_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_BillingAccountLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit) */ {
 public:
  inline WorkspaceLimitInfo_BillingAccountLimit() : WorkspaceLimitInfo_BillingAccountLimit(nullptr) {}
  ~WorkspaceLimitInfo_BillingAccountLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_BillingAccountLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_BillingAccountLimit(const WorkspaceLimitInfo_BillingAccountLimit& from);
  WorkspaceLimitInfo_BillingAccountLimit(WorkspaceLimitInfo_BillingAccountLimit&& from) noexcept
    : WorkspaceLimitInfo_BillingAccountLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_BillingAccountLimit& operator=(const WorkspaceLimitInfo_BillingAccountLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_BillingAccountLimit& operator=(WorkspaceLimitInfo_BillingAccountLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_BillingAccountLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_BillingAccountLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_BillingAccountLimit*>(
               &_WorkspaceLimitInfo_BillingAccountLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WorkspaceLimitInfo_BillingAccountLimit& a, WorkspaceLimitInfo_BillingAccountLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_BillingAccountLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_BillingAccountLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_BillingAccountLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_BillingAccountLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_BillingAccountLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_BillingAccountLimit& from) {
    WorkspaceLimitInfo_BillingAccountLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_BillingAccountLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_BillingAccountLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalWorkspacesFieldNumber = 1,
  };
  // int32 total_workspaces = 1;
  void clear_total_workspaces();
  int32_t total_workspaces() const;
  void set_total_workspaces(int32_t value);
  private:
  int32_t _internal_total_workspaces() const;
  void _internal_set_total_workspaces(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t total_workspaces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo_CommonKnowledgeLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit) */ {
 public:
  inline WorkspaceLimitInfo_CommonKnowledgeLimit() : WorkspaceLimitInfo_CommonKnowledgeLimit(nullptr) {}
  ~WorkspaceLimitInfo_CommonKnowledgeLimit() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CommonKnowledgeLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo_CommonKnowledgeLimit(const WorkspaceLimitInfo_CommonKnowledgeLimit& from);
  WorkspaceLimitInfo_CommonKnowledgeLimit(WorkspaceLimitInfo_CommonKnowledgeLimit&& from) noexcept
    : WorkspaceLimitInfo_CommonKnowledgeLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CommonKnowledgeLimit& operator=(const WorkspaceLimitInfo_CommonKnowledgeLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CommonKnowledgeLimit& operator=(WorkspaceLimitInfo_CommonKnowledgeLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CommonKnowledgeLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CommonKnowledgeLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CommonKnowledgeLimit*>(
               &_WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WorkspaceLimitInfo_CommonKnowledgeLimit& a, WorkspaceLimitInfo_CommonKnowledgeLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CommonKnowledgeLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CommonKnowledgeLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CommonKnowledgeLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CommonKnowledgeLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CommonKnowledgeLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CommonKnowledgeLimit& from) {
    WorkspaceLimitInfo_CommonKnowledgeLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo_CommonKnowledgeLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CommonKnowledgeLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryRecordsFieldNumber = 3,
    kDisplayNameMaxLengthFieldNumber = 1,
    kDescriptionMaxLengthFieldNumber = 2,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit memory_records = 3;
  bool has_memory_records() const;
  private:
  bool _internal_has_memory_records() const;
  public:
  void clear_memory_records();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& memory_records() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_memory_records();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_memory_records();
  void set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_memory_records() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_memory_records();
  public:
  void unsafe_arena_set_allocated_memory_records(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_memory_records();

  // int32 display_name_max_length = 1;
  void clear_display_name_max_length();
  int32_t display_name_max_length() const;
  void set_display_name_max_length(int32_t value);
  private:
  int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(int32_t value);
  public:

  // int32 description_max_length = 2;
  void clear_description_max_length();
  int32_t description_max_length() const;
  void set_description_max_length(int32_t value);
  private:
  int32_t _internal_description_max_length() const;
  void _internal_set_description_max_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records_;
    int32_t display_name_max_length_;
    int32_t description_max_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceLimitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo) */ {
 public:
  inline WorkspaceLimitInfo() : WorkspaceLimitInfo(nullptr) {}
  ~WorkspaceLimitInfo() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceLimitInfo(const WorkspaceLimitInfo& from);
  WorkspaceLimitInfo(WorkspaceLimitInfo&& from) noexcept
    : WorkspaceLimitInfo() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo& operator=(const WorkspaceLimitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo& operator=(WorkspaceLimitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo*>(
               &_WorkspaceLimitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WorkspaceLimitInfo& a, WorkspaceLimitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo& from) {
    WorkspaceLimitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceLimitInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo";
  }
  protected:
  explicit WorkspaceLimitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WorkspaceLimitInfo_TextListLimit TextListLimit;
  typedef WorkspaceLimitInfo_CharacterLimit CharacterLimit;
  typedef WorkspaceLimitInfo_SceneLimit SceneLimit;
  typedef WorkspaceLimitInfo_WorkspaceLimit WorkspaceLimit;
  typedef WorkspaceLimitInfo_BillingAccountLimit BillingAccountLimit;
  typedef WorkspaceLimitInfo_CommonKnowledgeLimit CommonKnowledgeLimit;

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterFieldNumber = 1,
    kSceneFieldNumber = 2,
    kWorkspaceFieldNumber = 3,
    kBillingAccountFieldNumber = 4,
    kCommonKnowledgeFieldNumber = 5,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit character = 1;
  bool has_character() const;
  private:
  bool _internal_has_character() const;
  public:
  void clear_character();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& character() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* release_character();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* mutable_character();
  void set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& _internal_character() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* _internal_mutable_character();
  public:
  void unsafe_arena_set_allocated_character(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* unsafe_arena_release_character();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit scene = 2;
  bool has_scene() const;
  private:
  bool _internal_has_scene() const;
  public:
  void clear_scene();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& scene() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* release_scene();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* mutable_scene();
  void set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& _internal_scene() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* _internal_mutable_scene();
  public:
  void unsafe_arena_set_allocated_scene(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* unsafe_arena_release_scene();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit workspace = 3;
  bool has_workspace() const;
  private:
  bool _internal_has_workspace() const;
  public:
  void clear_workspace();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* release_workspace();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* _internal_mutable_workspace();
  public:
  void unsafe_arena_set_allocated_workspace(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* unsafe_arena_release_workspace();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit billing_account = 4;
  bool has_billing_account() const;
  private:
  bool _internal_has_billing_account() const;
  public:
  void clear_billing_account();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& billing_account() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* release_billing_account();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* mutable_billing_account();
  void set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& _internal_billing_account() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* _internal_mutable_billing_account();
  public:
  void unsafe_arena_set_allocated_billing_account(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* unsafe_arena_release_billing_account();

  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit common_knowledge = 5;
  bool has_common_knowledge() const;
  private:
  bool _internal_has_common_knowledge() const;
  public:
  void clear_common_knowledge();
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& common_knowledge() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* release_common_knowledge();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* mutable_common_knowledge();
  void set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& _internal_common_knowledge() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* _internal_mutable_common_knowledge();
  public:
  void unsafe_arena_set_allocated_common_knowledge(
      ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* unsafe_arena_release_common_knowledge();

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class GetWorkspaceBillingInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest) */ {
 public:
  inline GetWorkspaceBillingInfoRequest() : GetWorkspaceBillingInfoRequest(nullptr) {}
  ~GetWorkspaceBillingInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetWorkspaceBillingInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWorkspaceBillingInfoRequest(const GetWorkspaceBillingInfoRequest& from);
  GetWorkspaceBillingInfoRequest(GetWorkspaceBillingInfoRequest&& from) noexcept
    : GetWorkspaceBillingInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceBillingInfoRequest& operator=(const GetWorkspaceBillingInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceBillingInfoRequest& operator=(GetWorkspaceBillingInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceBillingInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceBillingInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceBillingInfoRequest*>(
               &_GetWorkspaceBillingInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetWorkspaceBillingInfoRequest& a, GetWorkspaceBillingInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceBillingInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceBillingInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceBillingInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceBillingInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceBillingInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceBillingInfoRequest& from) {
    GetWorkspaceBillingInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkspaceBillingInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest";
  }
  protected:
  explicit GetWorkspaceBillingInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceBillingInfo_QuotaDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails) */ {
 public:
  inline WorkspaceBillingInfo_QuotaDetails() : WorkspaceBillingInfo_QuotaDetails(nullptr) {}
  ~WorkspaceBillingInfo_QuotaDetails() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceBillingInfo_QuotaDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceBillingInfo_QuotaDetails(const WorkspaceBillingInfo_QuotaDetails& from);
  WorkspaceBillingInfo_QuotaDetails(WorkspaceBillingInfo_QuotaDetails&& from) noexcept
    : WorkspaceBillingInfo_QuotaDetails() {
    *this = ::std::move(from);
  }

  inline WorkspaceBillingInfo_QuotaDetails& operator=(const WorkspaceBillingInfo_QuotaDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceBillingInfo_QuotaDetails& operator=(WorkspaceBillingInfo_QuotaDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceBillingInfo_QuotaDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceBillingInfo_QuotaDetails* internal_default_instance() {
    return reinterpret_cast<const WorkspaceBillingInfo_QuotaDetails*>(
               &_WorkspaceBillingInfo_QuotaDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkspaceBillingInfo_QuotaDetails& a, WorkspaceBillingInfo_QuotaDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceBillingInfo_QuotaDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceBillingInfo_QuotaDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceBillingInfo_QuotaDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceBillingInfo_QuotaDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceBillingInfo_QuotaDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceBillingInfo_QuotaDetails& from) {
    WorkspaceBillingInfo_QuotaDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceBillingInfo_QuotaDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails";
  }
  protected:
  explicit WorkspaceBillingInfo_QuotaDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasCreditsFieldNumber = 1,
    kHasPaidSubscriptionFieldNumber = 2,
    kCurrentSourceFieldNumber = 3,
  };
  // bool has_credits = 1;
  void clear_has_credits();
  bool has_credits() const;
  void set_has_credits(bool value);
  private:
  bool _internal_has_credits() const;
  void _internal_set_has_credits(bool value);
  public:

  // bool has_paid_subscription = 2;
  void clear_has_paid_subscription();
  bool has_paid_subscription() const;
  void set_has_paid_subscription(bool value);
  private:
  bool _internal_has_paid_subscription() const;
  void _internal_set_has_paid_subscription(bool value);
  public:

  // .ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaSource current_source = 3;
  void clear_current_source();
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource current_source() const;
  void set_current_source(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource value);
  private:
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource _internal_current_source() const;
  void _internal_set_current_source(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool has_credits_;
    bool has_paid_subscription_;
    int current_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// -------------------------------------------------------------------

class WorkspaceBillingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceBillingInfo) */ {
 public:
  inline WorkspaceBillingInfo() : WorkspaceBillingInfo(nullptr) {}
  ~WorkspaceBillingInfo() override;
  explicit PROTOBUF_CONSTEXPR WorkspaceBillingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkspaceBillingInfo(const WorkspaceBillingInfo& from);
  WorkspaceBillingInfo(WorkspaceBillingInfo&& from) noexcept
    : WorkspaceBillingInfo() {
    *this = ::std::move(from);
  }

  inline WorkspaceBillingInfo& operator=(const WorkspaceBillingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceBillingInfo& operator=(WorkspaceBillingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceBillingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceBillingInfo* internal_default_instance() {
    return reinterpret_cast<const WorkspaceBillingInfo*>(
               &_WorkspaceBillingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WorkspaceBillingInfo& a, WorkspaceBillingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceBillingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceBillingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceBillingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceBillingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkspaceBillingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkspaceBillingInfo& from) {
    WorkspaceBillingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkspaceBillingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceBillingInfo";
  }
  protected:
  explicit WorkspaceBillingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WorkspaceBillingInfo_QuotaDetails QuotaDetails;

  typedef WorkspaceBillingInfo_QuotaSource QuotaSource;
  static constexpr QuotaSource QUOTA_SOURCE_UNSPECIFIED =
    WorkspaceBillingInfo_QuotaSource_QUOTA_SOURCE_UNSPECIFIED;
  static constexpr QuotaSource NO_SOURCES =
    WorkspaceBillingInfo_QuotaSource_NO_SOURCES;
  static constexpr QuotaSource SUBSCRIPTION =
    WorkspaceBillingInfo_QuotaSource_SUBSCRIPTION;
  static constexpr QuotaSource CREDITS =
    WorkspaceBillingInfo_QuotaSource_CREDITS;
  static constexpr QuotaSource OVERAGE =
    WorkspaceBillingInfo_QuotaSource_OVERAGE;
  static inline bool QuotaSource_IsValid(int value) {
    return WorkspaceBillingInfo_QuotaSource_IsValid(value);
  }
  static constexpr QuotaSource QuotaSource_MIN =
    WorkspaceBillingInfo_QuotaSource_QuotaSource_MIN;
  static constexpr QuotaSource QuotaSource_MAX =
    WorkspaceBillingInfo_QuotaSource_QuotaSource_MAX;
  static constexpr int QuotaSource_ARRAYSIZE =
    WorkspaceBillingInfo_QuotaSource_QuotaSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QuotaSource_descriptor() {
    return WorkspaceBillingInfo_QuotaSource_descriptor();
  }
  template<typename T>
  static inline const std::string& QuotaSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QuotaSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QuotaSource_Name.");
    return WorkspaceBillingInfo_QuotaSource_Name(enum_t_value);
  }
  static inline bool QuotaSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QuotaSource* value) {
    return WorkspaceBillingInfo_QuotaSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kQuotaDetailsFieldNumber = 4,
    kIsBillingOwnerFieldNumber = 2,
    kHasUsableQuotaFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails quota_details = 4;
  bool has_quota_details() const;
  private:
  bool _internal_has_quota_details() const;
  public:
  void clear_quota_details();
  const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails& quota_details() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* release_quota_details();
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* mutable_quota_details();
  void set_allocated_quota_details(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* quota_details);
  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails& _internal_quota_details() const;
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* _internal_mutable_quota_details();
  public:
  void unsafe_arena_set_allocated_quota_details(
      ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* quota_details);
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* unsafe_arena_release_quota_details();

  // bool is_billing_owner = 2;
  void clear_is_billing_owner();
  bool is_billing_owner() const;
  void set_is_billing_owner(bool value);
  private:
  bool _internal_is_billing_owner() const;
  void _internal_set_is_billing_owner(bool value);
  public:

  // bool has_usable_quota = 3;
  void clear_has_usable_quota();
  bool has_usable_quota() const;
  void set_has_usable_quota(bool value);
  private:
  bool _internal_has_usable_quota() const;
  void _internal_set_has_usable_quota(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceBillingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* quota_details_;
    bool is_billing_owner_;
    bool has_usable_quota_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkspaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
}
inline std::string* GetWorkspaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetWorkspaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkspaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkspaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
}

// .ai.inworld.studio.v1alpha.WorkspaceItemView view = 2;
inline void GetWorkspaceRequest::clear_view() {
  _impl_.view_ = 0;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceItemView GetWorkspaceRequest::_internal_view() const {
  return static_cast< ::ai::inworld::studio::v1alpha::WorkspaceItemView >(_impl_.view_);
}
inline ::ai::inworld::studio::v1alpha::WorkspaceItemView GetWorkspaceRequest::view() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceRequest.view)
  return _internal_view();
}
inline void GetWorkspaceRequest::_internal_set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value) {
  
  _impl_.view_ = value;
}
inline void GetWorkspaceRequest::set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceRequest.view)
}

// -------------------------------------------------------------------

// ListWorkspacesRequest

// int32 page_size = 1;
inline void ListWorkspacesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListWorkspacesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListWorkspacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_size)
  return _internal_page_size();
}
inline void ListWorkspacesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListWorkspacesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_size)
}

// string page_token = 2;
inline void ListWorkspacesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListWorkspacesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListWorkspacesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
}
inline std::string* ListWorkspacesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _s;
}
inline const std::string& ListWorkspacesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListWorkspacesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListWorkspacesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListWorkspacesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListWorkspacesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
}

// -------------------------------------------------------------------

// CreateWorkspaceRequest

// .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateWorkspaceRequest::_internal_has_workspace() const {
  return this != internal_default_instance() && _impl_.workspace_ != nullptr;
}
inline bool CreateWorkspaceRequest::has_workspace() const {
  return _internal_has_workspace();
}
inline void CreateWorkspaceRequest::clear_workspace() {
  if (GetArenaForAllocation() == nullptr && _impl_.workspace_ != nullptr) {
    delete _impl_.workspace_;
  }
  _impl_.workspace_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::Workspace& CreateWorkspaceRequest::_internal_workspace() const {
  const ::ai::inworld::studio::v1alpha::Workspace* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace&>(
      ::ai::inworld::studio::v1alpha::_Workspace_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace& CreateWorkspaceRequest::workspace() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
  return _internal_workspace();
}
inline void CreateWorkspaceRequest::unsafe_arena_set_allocated_workspace(
    ::ai::inworld::studio::v1alpha::Workspace* workspace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = workspace;
  if (workspace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::release_workspace() {
  
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::unsafe_arena_release_workspace() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
  
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::_internal_mutable_workspace() {
  
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace>(GetArenaForAllocation());
    _impl_.workspace_ = p;
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::mutable_workspace() {
  ::ai::inworld::studio::v1alpha::Workspace* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
  return _msg;
}
inline void CreateWorkspaceRequest::set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* workspace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.workspace_;
  }
  if (workspace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(workspace);
    if (message_arena != submessage_arena) {
      workspace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workspace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.workspace_ = workspace;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
}

// -------------------------------------------------------------------

// UpdateWorkspaceRequest

// .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateWorkspaceRequest::_internal_has_workspace() const {
  return this != internal_default_instance() && _impl_.workspace_ != nullptr;
}
inline bool UpdateWorkspaceRequest::has_workspace() const {
  return _internal_has_workspace();
}
inline void UpdateWorkspaceRequest::clear_workspace() {
  if (GetArenaForAllocation() == nullptr && _impl_.workspace_ != nullptr) {
    delete _impl_.workspace_;
  }
  _impl_.workspace_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::Workspace& UpdateWorkspaceRequest::_internal_workspace() const {
  const ::ai::inworld::studio::v1alpha::Workspace* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace&>(
      ::ai::inworld::studio::v1alpha::_Workspace_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace& UpdateWorkspaceRequest::workspace() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
  return _internal_workspace();
}
inline void UpdateWorkspaceRequest::unsafe_arena_set_allocated_workspace(
    ::ai::inworld::studio::v1alpha::Workspace* workspace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = workspace;
  if (workspace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::release_workspace() {
  
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::unsafe_arena_release_workspace() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
  
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::_internal_mutable_workspace() {
  
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace>(GetArenaForAllocation());
    _impl_.workspace_ = p;
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::mutable_workspace() {
  ::ai::inworld::studio::v1alpha::Workspace* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
  return _msg;
}
inline void UpdateWorkspaceRequest::set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* workspace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.workspace_;
  }
  if (workspace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(workspace);
    if (message_arena != submessage_arena) {
      workspace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workspace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.workspace_ = workspace;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateWorkspaceRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateWorkspaceRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateWorkspaceRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateWorkspaceRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateWorkspaceRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateWorkspaceRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateWorkspaceRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateWorkspaceRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateWorkspaceRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
  return _msg;
}
inline void UpdateWorkspaceRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteWorkspaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteWorkspaceRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteWorkspaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
}
inline std::string* DeleteWorkspaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _s;
}
inline const std::string& DeleteWorkspaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteWorkspaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteWorkspaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteWorkspaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteWorkspaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
}

// bool force = 2;
inline void DeleteWorkspaceRequest::clear_force() {
  _impl_.force_ = false;
}
inline bool DeleteWorkspaceRequest::_internal_force() const {
  return _impl_.force_;
}
inline bool DeleteWorkspaceRequest::force() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.force)
  return _internal_force();
}
inline void DeleteWorkspaceRequest::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void DeleteWorkspaceRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.force)
}

// -------------------------------------------------------------------

// Workspace_Meta

// int32 total_characters = 1;
inline void Workspace_Meta::clear_total_characters() {
  _impl_.total_characters_ = 0;
}
inline int32_t Workspace_Meta::_internal_total_characters() const {
  return _impl_.total_characters_;
}
inline int32_t Workspace_Meta::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_characters)
  return _internal_total_characters();
}
inline void Workspace_Meta::_internal_set_total_characters(int32_t value) {
  
  _impl_.total_characters_ = value;
}
inline void Workspace_Meta::set_total_characters(int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_characters)
}

// int32 total_scenes = 2;
inline void Workspace_Meta::clear_total_scenes() {
  _impl_.total_scenes_ = 0;
}
inline int32_t Workspace_Meta::_internal_total_scenes() const {
  return _impl_.total_scenes_;
}
inline int32_t Workspace_Meta::total_scenes() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_scenes)
  return _internal_total_scenes();
}
inline void Workspace_Meta::_internal_set_total_scenes(int32_t value) {
  
  _impl_.total_scenes_ = value;
}
inline void Workspace_Meta::set_total_scenes(int32_t value) {
  _internal_set_total_scenes(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_scenes)
}

// int32 total_triggers = 3;
inline void Workspace_Meta::clear_total_triggers() {
  _impl_.total_triggers_ = 0;
}
inline int32_t Workspace_Meta::_internal_total_triggers() const {
  return _impl_.total_triggers_;
}
inline int32_t Workspace_Meta::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_triggers)
  return _internal_total_triggers();
}
inline void Workspace_Meta::_internal_set_total_triggers(int32_t value) {
  
  _impl_.total_triggers_ = value;
}
inline void Workspace_Meta::set_total_triggers(int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_triggers)
}

// int32 total_common_knowledge = 4;
inline void Workspace_Meta::clear_total_common_knowledge() {
  _impl_.total_common_knowledge_ = 0;
}
inline int32_t Workspace_Meta::_internal_total_common_knowledge() const {
  return _impl_.total_common_knowledge_;
}
inline int32_t Workspace_Meta::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void Workspace_Meta::_internal_set_total_common_knowledge(int32_t value) {
  
  _impl_.total_common_knowledge_ = value;
}
inline void Workspace_Meta::set_total_common_knowledge(int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_common_knowledge)
}

// -------------------------------------------------------------------

// Workspace

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.ai.inworld.options.examples) = {
inline void Workspace::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Workspace::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workspace::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.name)
}
inline std::string* Workspace::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.name)
  return _s;
}
inline const std::string& Workspace::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Workspace::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Workspace::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Workspace::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.name)
  return _impl_.name_.Release();
}
inline void Workspace::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.name)
}

// string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
inline void Workspace::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Workspace::display_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workspace::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.display_name)
}
inline std::string* Workspace::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _s;
}
inline const std::string& Workspace::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Workspace::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Workspace::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Workspace::release_display_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _impl_.display_name_.Release();
}
inline void Workspace::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.display_name)
}

// repeated string experimental_features = 3;
inline int Workspace::_internal_experimental_features_size() const {
  return _impl_.experimental_features_.size();
}
inline int Workspace::experimental_features_size() const {
  return _internal_experimental_features_size();
}
inline void Workspace::clear_experimental_features() {
  _impl_.experimental_features_.Clear();
}
inline std::string* Workspace::add_experimental_features() {
  std::string* _s = _internal_add_experimental_features();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _s;
}
inline const std::string& Workspace::_internal_experimental_features(int index) const {
  return _impl_.experimental_features_.Get(index);
}
inline const std::string& Workspace::experimental_features(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _internal_experimental_features(index);
}
inline std::string* Workspace::mutable_experimental_features(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _impl_.experimental_features_.Mutable(index);
}
inline void Workspace::set_experimental_features(int index, const std::string& value) {
  _impl_.experimental_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, std::string&& value) {
  _impl_.experimental_features_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.experimental_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, const char* value, size_t size) {
  _impl_.experimental_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline std::string* Workspace::_internal_add_experimental_features() {
  return _impl_.experimental_features_.Add();
}
inline void Workspace::add_experimental_features(const std::string& value) {
  _impl_.experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(std::string&& value) {
  _impl_.experimental_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.experimental_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(const char* value, size_t size) {
  _impl_.experimental_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Workspace::experimental_features() const {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _impl_.experimental_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Workspace::mutable_experimental_features() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return &_impl_.experimental_features_;
}

// string billing_account = 4 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void Workspace::clear_billing_account() {
  _impl_.billing_account_.ClearToEmpty();
}
inline const std::string& Workspace::billing_account() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _internal_billing_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Workspace::set_billing_account(ArgT0&& arg0, ArgT... args) {
 
 _impl_.billing_account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.billing_account)
}
inline std::string* Workspace::mutable_billing_account() {
  std::string* _s = _internal_mutable_billing_account();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _s;
}
inline const std::string& Workspace::_internal_billing_account() const {
  return _impl_.billing_account_.Get();
}
inline void Workspace::_internal_set_billing_account(const std::string& value) {
  
  _impl_.billing_account_.Set(value, GetArenaForAllocation());
}
inline std::string* Workspace::_internal_mutable_billing_account() {
  
  return _impl_.billing_account_.Mutable(GetArenaForAllocation());
}
inline std::string* Workspace::release_billing_account() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _impl_.billing_account_.Release();
}
inline void Workspace::set_allocated_billing_account(std::string* billing_account) {
  if (billing_account != nullptr) {
    
  } else {
    
  }
  _impl_.billing_account_.SetAllocated(billing_account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.billing_account_.IsDefault()) {
    _impl_.billing_account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.billing_account)
}

// .ai.inworld.studio.v1alpha.Workspace.Meta meta = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Workspace::_internal_has_meta() const {
  return this != internal_default_instance() && _impl_.meta_ != nullptr;
}
inline bool Workspace::has_meta() const {
  return _internal_has_meta();
}
inline void Workspace::clear_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::Workspace_Meta& Workspace::_internal_meta() const {
  const ::ai::inworld::studio::v1alpha::Workspace_Meta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace_Meta&>(
      ::ai::inworld::studio::v1alpha::_Workspace_Meta_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace_Meta& Workspace::meta() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.meta)
  return _internal_meta();
}
inline void Workspace::unsafe_arena_set_allocated_meta(
    ::ai::inworld::studio::v1alpha::Workspace_Meta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.Workspace.meta)
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::release_meta() {
  
  ::ai::inworld::studio::v1alpha::Workspace_Meta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.meta)
  
  ::ai::inworld::studio::v1alpha::Workspace_Meta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::_internal_mutable_meta() {
  
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace_Meta>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::mutable_meta() {
  ::ai::inworld::studio::v1alpha::Workspace_Meta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.meta)
  return _msg;
}
inline void Workspace::set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.meta)
}

// -------------------------------------------------------------------

// ListWorkspacesResponse

// repeated .ai.inworld.studio.v1alpha.Workspace workspaces = 1;
inline int ListWorkspacesResponse::_internal_workspaces_size() const {
  return _impl_.workspaces_.size();
}
inline int ListWorkspacesResponse::workspaces_size() const {
  return _internal_workspaces_size();
}
inline void ListWorkspacesResponse::clear_workspaces() {
  _impl_.workspaces_.Clear();
}
inline ::ai::inworld::studio::v1alpha::Workspace* ListWorkspacesResponse::mutable_workspaces(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _impl_.workspaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >*
ListWorkspacesResponse::mutable_workspaces() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return &_impl_.workspaces_;
}
inline const ::ai::inworld::studio::v1alpha::Workspace& ListWorkspacesResponse::_internal_workspaces(int index) const {
  return _impl_.workspaces_.Get(index);
}
inline const ::ai::inworld::studio::v1alpha::Workspace& ListWorkspacesResponse::workspaces(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _internal_workspaces(index);
}
inline ::ai::inworld::studio::v1alpha::Workspace* ListWorkspacesResponse::_internal_add_workspaces() {
  return _impl_.workspaces_.Add();
}
inline ::ai::inworld::studio::v1alpha::Workspace* ListWorkspacesResponse::add_workspaces() {
  ::ai::inworld::studio::v1alpha::Workspace* _add = _internal_add_workspaces();
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >&
ListWorkspacesResponse::workspaces() const {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _impl_.workspaces_;
}

// string next_page_token = 2;
inline void ListWorkspacesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListWorkspacesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListWorkspacesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
}
inline std::string* ListWorkspacesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _s;
}
inline const std::string& ListWorkspacesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListWorkspacesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListWorkspacesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListWorkspacesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListWorkspacesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
}

// -------------------------------------------------------------------

// ShareWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ShareWorkspaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ShareWorkspaceRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareWorkspaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
}
inline std::string* ShareWorkspaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _s;
}
inline const std::string& ShareWorkspaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ShareWorkspaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareWorkspaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareWorkspaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void ShareWorkspaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
}

// repeated string emails = 2 [(.ai.inworld.options.examples) = {
inline int ShareWorkspaceRequest::_internal_emails_size() const {
  return _impl_.emails_.size();
}
inline int ShareWorkspaceRequest::emails_size() const {
  return _internal_emails_size();
}
inline void ShareWorkspaceRequest::clear_emails() {
  _impl_.emails_.Clear();
}
inline std::string* ShareWorkspaceRequest::add_emails() {
  std::string* _s = _internal_add_emails();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _s;
}
inline const std::string& ShareWorkspaceRequest::_internal_emails(int index) const {
  return _impl_.emails_.Get(index);
}
inline const std::string& ShareWorkspaceRequest::emails(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _internal_emails(index);
}
inline std::string* ShareWorkspaceRequest::mutable_emails(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _impl_.emails_.Mutable(index);
}
inline void ShareWorkspaceRequest::set_emails(int index, const std::string& value) {
  _impl_.emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, std::string&& value) {
  _impl_.emails_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, const char* value, size_t size) {
  _impl_.emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline std::string* ShareWorkspaceRequest::_internal_add_emails() {
  return _impl_.emails_.Add();
}
inline void ShareWorkspaceRequest::add_emails(const std::string& value) {
  _impl_.emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(std::string&& value) {
  _impl_.emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(const char* value, size_t size) {
  _impl_.emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShareWorkspaceRequest::emails() const {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _impl_.emails_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShareWorkspaceRequest::mutable_emails() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return &_impl_.emails_;
}

// -------------------------------------------------------------------

// GenerateResourceNameRequest

// string workspace = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GenerateResourceNameRequest::clear_workspace() {
  _impl_.workspace_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameRequest::workspace() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _internal_workspace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateResourceNameRequest::set_workspace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workspace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
}
inline std::string* GenerateResourceNameRequest::mutable_workspace() {
  std::string* _s = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _s;
}
inline const std::string& GenerateResourceNameRequest::_internal_workspace() const {
  return _impl_.workspace_.Get();
}
inline void GenerateResourceNameRequest::_internal_set_workspace(const std::string& value) {
  
  _impl_.workspace_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateResourceNameRequest::_internal_mutable_workspace() {
  
  return _impl_.workspace_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateResourceNameRequest::release_workspace() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _impl_.workspace_.Release();
}
inline void GenerateResourceNameRequest::set_allocated_workspace(std::string* workspace) {
  if (workspace != nullptr) {
    
  } else {
    
  }
  _impl_.workspace_.SetAllocated(workspace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workspace_.IsDefault()) {
    _impl_.workspace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
}

// string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameRequest::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameRequest::display_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateResourceNameRequest::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
}
inline std::string* GenerateResourceNameRequest::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _s;
}
inline const std::string& GenerateResourceNameRequest::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void GenerateResourceNameRequest::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateResourceNameRequest::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateResourceNameRequest::release_display_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void GenerateResourceNameRequest::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
}

// .ai.inworld.studio.v1alpha.GenerateResourceNameRequest.ResourceType resource_type = 3 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameRequest::clear_resource_type() {
  _impl_.resource_type_ = 0;
}
inline ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest::_internal_resource_type() const {
  return static_cast< ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType >(_impl_.resource_type_);
}
inline ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest::resource_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.resource_type)
  return _internal_resource_type();
}
inline void GenerateResourceNameRequest::_internal_set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value) {
  
  _impl_.resource_type_ = value;
}
inline void GenerateResourceNameRequest::set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.resource_type)
}

// -------------------------------------------------------------------

// GenerateResourceNameResponse

// string resource = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameResponse::clear_resource() {
  _impl_.resource_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameResponse::resource() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateResourceNameResponse::set_resource(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
}
inline std::string* GenerateResourceNameResponse::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _s;
}
inline const std::string& GenerateResourceNameResponse::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void GenerateResourceNameResponse::_internal_set_resource(const std::string& value) {
  
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateResourceNameResponse::_internal_mutable_resource() {
  
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateResourceNameResponse::release_resource() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _impl_.resource_.Release();
}
inline void GenerateResourceNameResponse::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
}

// -------------------------------------------------------------------

// GetWorkspaceShareInfoRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceShareInfoRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceShareInfoRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkspaceShareInfoRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
}
inline std::string* GetWorkspaceShareInfoRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceShareInfoRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetWorkspaceShareInfoRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkspaceShareInfoRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkspaceShareInfoRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceShareInfoRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
}

// -------------------------------------------------------------------

// WorkspaceShareInfo

// repeated string emails = 1;
inline int WorkspaceShareInfo::_internal_emails_size() const {
  return _impl_.emails_.size();
}
inline int WorkspaceShareInfo::emails_size() const {
  return _internal_emails_size();
}
inline void WorkspaceShareInfo::clear_emails() {
  _impl_.emails_.Clear();
}
inline std::string* WorkspaceShareInfo::add_emails() {
  std::string* _s = _internal_add_emails();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _s;
}
inline const std::string& WorkspaceShareInfo::_internal_emails(int index) const {
  return _impl_.emails_.Get(index);
}
inline const std::string& WorkspaceShareInfo::emails(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _internal_emails(index);
}
inline std::string* WorkspaceShareInfo::mutable_emails(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _impl_.emails_.Mutable(index);
}
inline void WorkspaceShareInfo::set_emails(int index, const std::string& value) {
  _impl_.emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, std::string&& value) {
  _impl_.emails_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, const char* value, size_t size) {
  _impl_.emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline std::string* WorkspaceShareInfo::_internal_add_emails() {
  return _impl_.emails_.Add();
}
inline void WorkspaceShareInfo::add_emails(const std::string& value) {
  _impl_.emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(std::string&& value) {
  _impl_.emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(const char* value, size_t size) {
  _impl_.emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WorkspaceShareInfo::emails() const {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _impl_.emails_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WorkspaceShareInfo::mutable_emails() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return &_impl_.emails_;
}

// -------------------------------------------------------------------

// GetWorkspaceLimitInfoRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceLimitInfoRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceLimitInfoRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkspaceLimitInfoRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
}
inline std::string* GetWorkspaceLimitInfoRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceLimitInfoRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetWorkspaceLimitInfoRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkspaceLimitInfoRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkspaceLimitInfoRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceLimitInfoRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_TextListLimit

// int32 item_max_length = 1;
inline void WorkspaceLimitInfo_TextListLimit::clear_item_max_length() {
  _impl_.item_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_TextListLimit::_internal_item_max_length() const {
  return _impl_.item_max_length_;
}
inline int32_t WorkspaceLimitInfo_TextListLimit::item_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.item_max_length)
  return _internal_item_max_length();
}
inline void WorkspaceLimitInfo_TextListLimit::_internal_set_item_max_length(int32_t value) {
  
  _impl_.item_max_length_ = value;
}
inline void WorkspaceLimitInfo_TextListLimit::set_item_max_length(int32_t value) {
  _internal_set_item_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.item_max_length)
}

// int32 total_items = 2;
inline void WorkspaceLimitInfo_TextListLimit::clear_total_items() {
  _impl_.total_items_ = 0;
}
inline int32_t WorkspaceLimitInfo_TextListLimit::_internal_total_items() const {
  return _impl_.total_items_;
}
inline int32_t WorkspaceLimitInfo_TextListLimit::total_items() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.total_items)
  return _internal_total_items();
}
inline void WorkspaceLimitInfo_TextListLimit::_internal_set_total_items(int32_t value) {
  
  _impl_.total_items_ = value;
}
inline void WorkspaceLimitInfo_TextListLimit::set_total_items(int32_t value) {
  _internal_set_total_items(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.total_items)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit

// int32 core_max_length = 1;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_core_max_length() {
  _impl_.core_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_core_max_length() const {
  return _impl_.core_max_length_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::core_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.core_max_length)
  return _internal_core_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_core_max_length(int32_t value) {
  
  _impl_.core_max_length_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_core_max_length(int32_t value) {
  _internal_set_core_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.core_max_length)
}

// int32 example_dialog_max_length = 2;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_example_dialog_max_length() {
  _impl_.example_dialog_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_example_dialog_max_length() const {
  return _impl_.example_dialog_max_length_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::example_dialog_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.example_dialog_max_length)
  return _internal_example_dialog_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_example_dialog_max_length(int32_t value) {
  
  _impl_.example_dialog_max_length_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_example_dialog_max_length(int32_t value) {
  _internal_set_example_dialog_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.example_dialog_max_length)
}

// int32 motivation_max_length = 3;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_motivation_max_length() {
  _impl_.motivation_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_motivation_max_length() const {
  return _impl_.motivation_max_length_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::motivation_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.motivation_max_length)
  return _internal_motivation_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_motivation_max_length(int32_t value) {
  
  _impl_.motivation_max_length_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_motivation_max_length(int32_t value) {
  _internal_set_motivation_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.motivation_max_length)
}

// int32 character_role_max_length = 4;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_character_role_max_length() {
  _impl_.character_role_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_character_role_max_length() const {
  return _impl_.character_role_max_length_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::character_role_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.character_role_max_length)
  return _internal_character_role_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_character_role_max_length(int32_t value) {
  
  _impl_.character_role_max_length_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_character_role_max_length(int32_t value) {
  _internal_set_character_role_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.character_role_max_length)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit hobby_or_interests = 5;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_has_hobby_or_interests() const {
  return this != internal_default_instance() && _impl_.hobby_or_interests_ != nullptr;
}
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_hobby_or_interests() const {
  return _internal_has_hobby_or_interests();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_hobby_or_interests() {
  if (GetArenaForAllocation() == nullptr && _impl_.hobby_or_interests_ != nullptr) {
    delete _impl_.hobby_or_interests_;
  }
  _impl_.hobby_or_interests_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_hobby_or_interests() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.hobby_or_interests_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::hobby_or_interests() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
  return _internal_hobby_or_interests();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_hobby_or_interests(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hobby_or_interests_);
  }
  _impl_.hobby_or_interests_ = hobby_or_interests;
  if (hobby_or_interests) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_hobby_or_interests() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.hobby_or_interests_;
  _impl_.hobby_or_interests_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_hobby_or_interests() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.hobby_or_interests_;
  _impl_.hobby_or_interests_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_hobby_or_interests() {
  
  if (_impl_.hobby_or_interests_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArenaForAllocation());
    _impl_.hobby_or_interests_ = p;
  }
  return _impl_.hobby_or_interests_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_hobby_or_interests() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_hobby_or_interests();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hobby_or_interests_;
  }
  if (hobby_or_interests) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hobby_or_interests);
    if (message_arena != submessage_arena) {
      hobby_or_interests = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hobby_or_interests, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hobby_or_interests_ = hobby_or_interests;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit nicknames = 6;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_has_nicknames() const {
  return this != internal_default_instance() && _impl_.nicknames_ != nullptr;
}
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_nicknames() const {
  return _internal_has_nicknames();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_nicknames() {
  if (GetArenaForAllocation() == nullptr && _impl_.nicknames_ != nullptr) {
    delete _impl_.nicknames_;
  }
  _impl_.nicknames_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_nicknames() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.nicknames_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::nicknames() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
  return _internal_nicknames();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_nicknames(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nicknames_);
  }
  _impl_.nicknames_ = nicknames;
  if (nicknames) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_nicknames() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.nicknames_;
  _impl_.nicknames_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_nicknames() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.nicknames_;
  _impl_.nicknames_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_nicknames() {
  
  if (_impl_.nicknames_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArenaForAllocation());
    _impl_.nicknames_ = p;
  }
  return _impl_.nicknames_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_nicknames() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_nicknames();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nicknames_;
  }
  if (nicknames) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nicknames);
    if (message_arena != submessage_arena) {
      nicknames = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nicknames, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nicknames_ = nicknames;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit personality_adjectives = 7;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_has_personality_adjectives() const {
  return this != internal_default_instance() && _impl_.personality_adjectives_ != nullptr;
}
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_personality_adjectives() const {
  return _internal_has_personality_adjectives();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_personality_adjectives() {
  if (GetArenaForAllocation() == nullptr && _impl_.personality_adjectives_ != nullptr) {
    delete _impl_.personality_adjectives_;
  }
  _impl_.personality_adjectives_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_personality_adjectives() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.personality_adjectives_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::personality_adjectives() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
  return _internal_personality_adjectives();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_personality_adjectives(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.personality_adjectives_);
  }
  _impl_.personality_adjectives_ = personality_adjectives;
  if (personality_adjectives) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_personality_adjectives() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.personality_adjectives_;
  _impl_.personality_adjectives_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_personality_adjectives() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.personality_adjectives_;
  _impl_.personality_adjectives_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_personality_adjectives() {
  
  if (_impl_.personality_adjectives_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArenaForAllocation());
    _impl_.personality_adjectives_ = p;
  }
  return _impl_.personality_adjectives_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_personality_adjectives() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_personality_adjectives();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.personality_adjectives_;
  }
  if (personality_adjectives) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(personality_adjectives);
    if (message_arena != submessage_arena) {
      personality_adjectives = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, personality_adjectives, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.personality_adjectives_ = personality_adjectives;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CharacterLimit

// int32 name_max_length = 1;
inline void WorkspaceLimitInfo_CharacterLimit::clear_name_max_length() {
  _impl_.name_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::_internal_name_max_length() const {
  return _impl_.name_max_length_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.name_max_length)
  return _internal_name_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_name_max_length(int32_t value) {
  
  _impl_.name_max_length_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit::set_name_max_length(int32_t value) {
  _internal_set_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.name_max_length)
}

// int32 total_triggers = 2;
inline void WorkspaceLimitInfo_CharacterLimit::clear_total_triggers() {
  _impl_.total_triggers_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::_internal_total_triggers() const {
  return _impl_.total_triggers_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_total_triggers(int32_t value) {
  
  _impl_.total_triggers_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit::set_total_triggers(int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_triggers)
}

// int32 total_common_knowledge = 3;
inline void WorkspaceLimitInfo_CharacterLimit::clear_total_common_knowledge() {
  _impl_.total_common_knowledge_ = 0;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::_internal_total_common_knowledge() const {
  return _impl_.total_common_knowledge_;
}
inline int32_t WorkspaceLimitInfo_CharacterLimit::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_total_common_knowledge(int32_t value) {
  
  _impl_.total_common_knowledge_ = value;
}
inline void WorkspaceLimitInfo_CharacterLimit::set_total_common_knowledge(int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_common_knowledge)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit character_description = 4;
inline bool WorkspaceLimitInfo_CharacterLimit::_internal_has_character_description() const {
  return this != internal_default_instance() && _impl_.character_description_ != nullptr;
}
inline bool WorkspaceLimitInfo_CharacterLimit::has_character_description() const {
  return _internal_has_character_description();
}
inline void WorkspaceLimitInfo_CharacterLimit::clear_character_description() {
  if (GetArenaForAllocation() == nullptr && _impl_.character_description_ != nullptr) {
    delete _impl_.character_description_;
  }
  _impl_.character_description_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& WorkspaceLimitInfo_CharacterLimit::_internal_character_description() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* p = _impl_.character_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& WorkspaceLimitInfo_CharacterLimit::character_description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
  return _internal_character_description();
}
inline void WorkspaceLimitInfo_CharacterLimit::unsafe_arena_set_allocated_character_description(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.character_description_);
  }
  _impl_.character_description_ = character_description;
  if (character_description) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::release_character_description() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* temp = _impl_.character_description_;
  _impl_.character_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::unsafe_arena_release_character_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* temp = _impl_.character_description_;
  _impl_.character_description_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::_internal_mutable_character_description() {
  
  if (_impl_.character_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit>(GetArenaForAllocation());
    _impl_.character_description_ = p;
  }
  return _impl_.character_description_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::mutable_character_description() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* _msg = _internal_mutable_character_description();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit::set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.character_description_;
  }
  if (character_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(character_description);
    if (message_arena != submessage_arena) {
      character_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character_description, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.character_description_ = character_description;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_SceneLimit

// int32 description_max_length = 1;
inline void WorkspaceLimitInfo_SceneLimit::clear_description_max_length() {
  _impl_.description_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::_internal_description_max_length() const {
  return _impl_.description_max_length_;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::description_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.description_max_length)
  return _internal_description_max_length();
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_description_max_length(int32_t value) {
  
  _impl_.description_max_length_ = value;
}
inline void WorkspaceLimitInfo_SceneLimit::set_description_max_length(int32_t value) {
  _internal_set_description_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.description_max_length)
}

// int32 total_characters = 2;
inline void WorkspaceLimitInfo_SceneLimit::clear_total_characters() {
  _impl_.total_characters_ = 0;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::_internal_total_characters() const {
  return _impl_.total_characters_;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_characters)
  return _internal_total_characters();
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_total_characters(int32_t value) {
  
  _impl_.total_characters_ = value;
}
inline void WorkspaceLimitInfo_SceneLimit::set_total_characters(int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_characters)
}

// int32 total_triggers = 3;
inline void WorkspaceLimitInfo_SceneLimit::clear_total_triggers() {
  _impl_.total_triggers_ = 0;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::_internal_total_triggers() const {
  return _impl_.total_triggers_;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_total_triggers(int32_t value) {
  
  _impl_.total_triggers_ = value;
}
inline void WorkspaceLimitInfo_SceneLimit::set_total_triggers(int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_triggers)
}

// int32 display_name_max_length = 4;
inline void WorkspaceLimitInfo_SceneLimit::clear_display_name_max_length() {
  _impl_.display_name_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::_internal_display_name_max_length() const {
  return _impl_.display_name_max_length_;
}
inline int32_t WorkspaceLimitInfo_SceneLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_display_name_max_length(int32_t value) {
  
  _impl_.display_name_max_length_ = value;
}
inline void WorkspaceLimitInfo_SceneLimit::set_display_name_max_length(int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.display_name_max_length)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_WorkspaceLimit

// int32 display_name_max_length = 1;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_display_name_max_length() {
  _impl_.display_name_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_display_name_max_length() const {
  return _impl_.display_name_max_length_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_display_name_max_length(int32_t value) {
  
  _impl_.display_name_max_length_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_display_name_max_length(int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.display_name_max_length)
}

// int32 total_characters = 2;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_characters() {
  _impl_.total_characters_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_characters() const {
  return _impl_.total_characters_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_characters)
  return _internal_total_characters();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_characters(int32_t value) {
  
  _impl_.total_characters_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_characters(int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_characters)
}

// int32 total_scenes = 3;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_scenes() {
  _impl_.total_scenes_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_scenes() const {
  return _impl_.total_scenes_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::total_scenes() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_scenes)
  return _internal_total_scenes();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_scenes(int32_t value) {
  
  _impl_.total_scenes_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_scenes(int32_t value) {
  _internal_set_total_scenes(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_scenes)
}

// int32 total_triggers = 4;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_triggers() {
  _impl_.total_triggers_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_triggers() const {
  return _impl_.total_triggers_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_triggers(int32_t value) {
  
  _impl_.total_triggers_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_triggers(int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_triggers)
}

// int32 total_voices = 5;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_voices() {
  _impl_.total_voices_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_voices() const {
  return _impl_.total_voices_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::total_voices() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_voices)
  return _internal_total_voices();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_voices(int32_t value) {
  
  _impl_.total_voices_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_voices(int32_t value) {
  _internal_set_total_voices(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_voices)
}

// int32 total_common_knowledge = 6;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_common_knowledge() {
  _impl_.total_common_knowledge_ = 0;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_common_knowledge() const {
  return _impl_.total_common_knowledge_;
}
inline int32_t WorkspaceLimitInfo_WorkspaceLimit::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_common_knowledge(int32_t value) {
  
  _impl_.total_common_knowledge_ = value;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_common_knowledge(int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_common_knowledge)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_BillingAccountLimit

// int32 total_workspaces = 1;
inline void WorkspaceLimitInfo_BillingAccountLimit::clear_total_workspaces() {
  _impl_.total_workspaces_ = 0;
}
inline int32_t WorkspaceLimitInfo_BillingAccountLimit::_internal_total_workspaces() const {
  return _impl_.total_workspaces_;
}
inline int32_t WorkspaceLimitInfo_BillingAccountLimit::total_workspaces() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit.total_workspaces)
  return _internal_total_workspaces();
}
inline void WorkspaceLimitInfo_BillingAccountLimit::_internal_set_total_workspaces(int32_t value) {
  
  _impl_.total_workspaces_ = value;
}
inline void WorkspaceLimitInfo_BillingAccountLimit::set_total_workspaces(int32_t value) {
  _internal_set_total_workspaces(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit.total_workspaces)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CommonKnowledgeLimit

// int32 display_name_max_length = 1;
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_display_name_max_length() {
  _impl_.display_name_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_display_name_max_length() const {
  return _impl_.display_name_max_length_;
}
inline int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_set_display_name_max_length(int32_t value) {
  
  _impl_.display_name_max_length_ = value;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_display_name_max_length(int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.display_name_max_length)
}

// int32 description_max_length = 2;
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_description_max_length() {
  _impl_.description_max_length_ = 0;
}
inline int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_description_max_length() const {
  return _impl_.description_max_length_;
}
inline int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::description_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.description_max_length)
  return _internal_description_max_length();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_set_description_max_length(int32_t value) {
  
  _impl_.description_max_length_ = value;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_description_max_length(int32_t value) {
  _internal_set_description_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.description_max_length)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit memory_records = 3;
inline bool WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_has_memory_records() const {
  return this != internal_default_instance() && _impl_.memory_records_ != nullptr;
}
inline bool WorkspaceLimitInfo_CommonKnowledgeLimit::has_memory_records() const {
  return _internal_has_memory_records();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_memory_records() {
  if (GetArenaForAllocation() == nullptr && _impl_.memory_records_ != nullptr) {
    delete _impl_.memory_records_;
  }
  _impl_.memory_records_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_memory_records() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.memory_records_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CommonKnowledgeLimit::memory_records() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
  return _internal_memory_records();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::unsafe_arena_set_allocated_memory_records(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_records_);
  }
  _impl_.memory_records_ = memory_records;
  if (memory_records) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::release_memory_records() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.memory_records_;
  _impl_.memory_records_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::unsafe_arena_release_memory_records() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.memory_records_;
  _impl_.memory_records_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_mutable_memory_records() {
  
  if (_impl_.memory_records_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArenaForAllocation());
    _impl_.memory_records_ = p;
  }
  return _impl_.memory_records_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::mutable_memory_records() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_memory_records();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
  return _msg;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.memory_records_;
  }
  if (memory_records) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory_records);
    if (message_arena != submessage_arena) {
      memory_records = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory_records, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.memory_records_ = memory_records;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit character = 1;
inline bool WorkspaceLimitInfo::_internal_has_character() const {
  return this != internal_default_instance() && _impl_.character_ != nullptr;
}
inline bool WorkspaceLimitInfo::has_character() const {
  return _internal_has_character();
}
inline void WorkspaceLimitInfo::clear_character() {
  if (GetArenaForAllocation() == nullptr && _impl_.character_ != nullptr) {
    delete _impl_.character_;
  }
  _impl_.character_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& WorkspaceLimitInfo::_internal_character() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CharacterLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& WorkspaceLimitInfo::character() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
  return _internal_character();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_character(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = character;
  if (character) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::release_character() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* temp = _impl_.character_;
  _impl_.character_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::unsafe_arena_release_character() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::_internal_mutable_character() {
  
  if (_impl_.character_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit>(GetArenaForAllocation());
    _impl_.character_ = p;
  }
  return _impl_.character_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::mutable_character() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.character_;
  }
  if (character) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(character);
    if (message_arena != submessage_arena) {
      character = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.character_ = character;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit scene = 2;
inline bool WorkspaceLimitInfo::_internal_has_scene() const {
  return this != internal_default_instance() && _impl_.scene_ != nullptr;
}
inline bool WorkspaceLimitInfo::has_scene() const {
  return _internal_has_scene();
}
inline void WorkspaceLimitInfo::clear_scene() {
  if (GetArenaForAllocation() == nullptr && _impl_.scene_ != nullptr) {
    delete _impl_.scene_;
  }
  _impl_.scene_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& WorkspaceLimitInfo::_internal_scene() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* p = _impl_.scene_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_SceneLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& WorkspaceLimitInfo::scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
  return _internal_scene();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_scene(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scene_);
  }
  _impl_.scene_ = scene;
  if (scene) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::release_scene() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* temp = _impl_.scene_;
  _impl_.scene_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::unsafe_arena_release_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* temp = _impl_.scene_;
  _impl_.scene_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::_internal_mutable_scene() {
  
  if (_impl_.scene_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit>(GetArenaForAllocation());
    _impl_.scene_ = p;
  }
  return _impl_.scene_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::mutable_scene() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* _msg = _internal_mutable_scene();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scene_;
  }
  if (scene) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scene);
    if (message_arena != submessage_arena) {
      scene = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit workspace = 3;
inline bool WorkspaceLimitInfo::_internal_has_workspace() const {
  return this != internal_default_instance() && _impl_.workspace_ != nullptr;
}
inline bool WorkspaceLimitInfo::has_workspace() const {
  return _internal_has_workspace();
}
inline void WorkspaceLimitInfo::clear_workspace() {
  if (GetArenaForAllocation() == nullptr && _impl_.workspace_ != nullptr) {
    delete _impl_.workspace_;
  }
  _impl_.workspace_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& WorkspaceLimitInfo::_internal_workspace() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_WorkspaceLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& WorkspaceLimitInfo::workspace() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
  return _internal_workspace();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_workspace(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = workspace;
  if (workspace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::release_workspace() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::unsafe_arena_release_workspace() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::_internal_mutable_workspace() {
  
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit>(GetArenaForAllocation());
    _impl_.workspace_ = p;
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::mutable_workspace() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.workspace_;
  }
  if (workspace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(workspace);
    if (message_arena != submessage_arena) {
      workspace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workspace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.workspace_ = workspace;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit billing_account = 4;
inline bool WorkspaceLimitInfo::_internal_has_billing_account() const {
  return this != internal_default_instance() && _impl_.billing_account_ != nullptr;
}
inline bool WorkspaceLimitInfo::has_billing_account() const {
  return _internal_has_billing_account();
}
inline void WorkspaceLimitInfo::clear_billing_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.billing_account_ != nullptr) {
    delete _impl_.billing_account_;
  }
  _impl_.billing_account_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& WorkspaceLimitInfo::_internal_billing_account() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* p = _impl_.billing_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_BillingAccountLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& WorkspaceLimitInfo::billing_account() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
  return _internal_billing_account();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_billing_account(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.billing_account_);
  }
  _impl_.billing_account_ = billing_account;
  if (billing_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::release_billing_account() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* temp = _impl_.billing_account_;
  _impl_.billing_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::unsafe_arena_release_billing_account() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* temp = _impl_.billing_account_;
  _impl_.billing_account_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::_internal_mutable_billing_account() {
  
  if (_impl_.billing_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit>(GetArenaForAllocation());
    _impl_.billing_account_ = p;
  }
  return _impl_.billing_account_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::mutable_billing_account() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* _msg = _internal_mutable_billing_account();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.billing_account_;
  }
  if (billing_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(billing_account);
    if (message_arena != submessage_arena) {
      billing_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, billing_account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.billing_account_ = billing_account;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit common_knowledge = 5;
inline bool WorkspaceLimitInfo::_internal_has_common_knowledge() const {
  return this != internal_default_instance() && _impl_.common_knowledge_ != nullptr;
}
inline bool WorkspaceLimitInfo::has_common_knowledge() const {
  return _internal_has_common_knowledge();
}
inline void WorkspaceLimitInfo::clear_common_knowledge() {
  if (GetArenaForAllocation() == nullptr && _impl_.common_knowledge_ != nullptr) {
    delete _impl_.common_knowledge_;
  }
  _impl_.common_knowledge_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& WorkspaceLimitInfo::_internal_common_knowledge() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* p = _impl_.common_knowledge_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& WorkspaceLimitInfo::common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
  return _internal_common_knowledge();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_common_knowledge(
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.common_knowledge_);
  }
  _impl_.common_knowledge_ = common_knowledge;
  if (common_knowledge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::release_common_knowledge() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* temp = _impl_.common_knowledge_;
  _impl_.common_knowledge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::unsafe_arena_release_common_knowledge() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
  
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* temp = _impl_.common_knowledge_;
  _impl_.common_knowledge_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::_internal_mutable_common_knowledge() {
  
  if (_impl_.common_knowledge_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit>(GetArenaForAllocation());
    _impl_.common_knowledge_ = p;
  }
  return _impl_.common_knowledge_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::mutable_common_knowledge() {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* _msg = _internal_mutable_common_knowledge();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.common_knowledge_;
  }
  if (common_knowledge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(common_knowledge);
    if (message_arena != submessage_arena) {
      common_knowledge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common_knowledge, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.common_knowledge_ = common_knowledge;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
}

// -------------------------------------------------------------------

// GetWorkspaceBillingInfoRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceBillingInfoRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceBillingInfoRequest::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWorkspaceBillingInfoRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest.name)
}
inline std::string* GetWorkspaceBillingInfoRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceBillingInfoRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetWorkspaceBillingInfoRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWorkspaceBillingInfoRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWorkspaceBillingInfoRequest::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceBillingInfoRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceBillingInfoRequest.name)
}

// -------------------------------------------------------------------

// WorkspaceBillingInfo_QuotaDetails

// bool has_credits = 1;
inline void WorkspaceBillingInfo_QuotaDetails::clear_has_credits() {
  _impl_.has_credits_ = false;
}
inline bool WorkspaceBillingInfo_QuotaDetails::_internal_has_credits() const {
  return _impl_.has_credits_;
}
inline bool WorkspaceBillingInfo_QuotaDetails::has_credits() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.has_credits)
  return _internal_has_credits();
}
inline void WorkspaceBillingInfo_QuotaDetails::_internal_set_has_credits(bool value) {
  
  _impl_.has_credits_ = value;
}
inline void WorkspaceBillingInfo_QuotaDetails::set_has_credits(bool value) {
  _internal_set_has_credits(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.has_credits)
}

// bool has_paid_subscription = 2;
inline void WorkspaceBillingInfo_QuotaDetails::clear_has_paid_subscription() {
  _impl_.has_paid_subscription_ = false;
}
inline bool WorkspaceBillingInfo_QuotaDetails::_internal_has_paid_subscription() const {
  return _impl_.has_paid_subscription_;
}
inline bool WorkspaceBillingInfo_QuotaDetails::has_paid_subscription() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.has_paid_subscription)
  return _internal_has_paid_subscription();
}
inline void WorkspaceBillingInfo_QuotaDetails::_internal_set_has_paid_subscription(bool value) {
  
  _impl_.has_paid_subscription_ = value;
}
inline void WorkspaceBillingInfo_QuotaDetails::set_has_paid_subscription(bool value) {
  _internal_set_has_paid_subscription(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.has_paid_subscription)
}

// .ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaSource current_source = 3;
inline void WorkspaceBillingInfo_QuotaDetails::clear_current_source() {
  _impl_.current_source_ = 0;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource WorkspaceBillingInfo_QuotaDetails::_internal_current_source() const {
  return static_cast< ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource >(_impl_.current_source_);
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource WorkspaceBillingInfo_QuotaDetails::current_source() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.current_source)
  return _internal_current_source();
}
inline void WorkspaceBillingInfo_QuotaDetails::_internal_set_current_source(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource value) {
  
  _impl_.current_source_ = value;
}
inline void WorkspaceBillingInfo_QuotaDetails::set_current_source(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource value) {
  _internal_set_current_source(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails.current_source)
}

// -------------------------------------------------------------------

// WorkspaceBillingInfo

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void WorkspaceBillingInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& WorkspaceBillingInfo::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkspaceBillingInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.name)
}
inline std::string* WorkspaceBillingInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.name)
  return _s;
}
inline const std::string& WorkspaceBillingInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WorkspaceBillingInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkspaceBillingInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkspaceBillingInfo::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.name)
  return _impl_.name_.Release();
}
inline void WorkspaceBillingInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.name)
}

// bool is_billing_owner = 2;
inline void WorkspaceBillingInfo::clear_is_billing_owner() {
  _impl_.is_billing_owner_ = false;
}
inline bool WorkspaceBillingInfo::_internal_is_billing_owner() const {
  return _impl_.is_billing_owner_;
}
inline bool WorkspaceBillingInfo::is_billing_owner() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.is_billing_owner)
  return _internal_is_billing_owner();
}
inline void WorkspaceBillingInfo::_internal_set_is_billing_owner(bool value) {
  
  _impl_.is_billing_owner_ = value;
}
inline void WorkspaceBillingInfo::set_is_billing_owner(bool value) {
  _internal_set_is_billing_owner(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.is_billing_owner)
}

// bool has_usable_quota = 3;
inline void WorkspaceBillingInfo::clear_has_usable_quota() {
  _impl_.has_usable_quota_ = false;
}
inline bool WorkspaceBillingInfo::_internal_has_usable_quota() const {
  return _impl_.has_usable_quota_;
}
inline bool WorkspaceBillingInfo::has_usable_quota() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.has_usable_quota)
  return _internal_has_usable_quota();
}
inline void WorkspaceBillingInfo::_internal_set_has_usable_quota(bool value) {
  
  _impl_.has_usable_quota_ = value;
}
inline void WorkspaceBillingInfo::set_has_usable_quota(bool value) {
  _internal_set_has_usable_quota(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.has_usable_quota)
}

// .ai.inworld.studio.v1alpha.WorkspaceBillingInfo.QuotaDetails quota_details = 4;
inline bool WorkspaceBillingInfo::_internal_has_quota_details() const {
  return this != internal_default_instance() && _impl_.quota_details_ != nullptr;
}
inline bool WorkspaceBillingInfo::has_quota_details() const {
  return _internal_has_quota_details();
}
inline void WorkspaceBillingInfo::clear_quota_details() {
  if (GetArenaForAllocation() == nullptr && _impl_.quota_details_ != nullptr) {
    delete _impl_.quota_details_;
  }
  _impl_.quota_details_ = nullptr;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails& WorkspaceBillingInfo::_internal_quota_details() const {
  const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* p = _impl_.quota_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails&>(
      ::ai::inworld::studio::v1alpha::_WorkspaceBillingInfo_QuotaDetails_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails& WorkspaceBillingInfo::quota_details() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.quota_details)
  return _internal_quota_details();
}
inline void WorkspaceBillingInfo::unsafe_arena_set_allocated_quota_details(
    ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* quota_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quota_details_);
  }
  _impl_.quota_details_ = quota_details;
  if (quota_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.quota_details)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* WorkspaceBillingInfo::release_quota_details() {
  
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* temp = _impl_.quota_details_;
  _impl_.quota_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* WorkspaceBillingInfo::unsafe_arena_release_quota_details() {
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.quota_details)
  
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* temp = _impl_.quota_details_;
  _impl_.quota_details_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* WorkspaceBillingInfo::_internal_mutable_quota_details() {
  
  if (_impl_.quota_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails>(GetArenaForAllocation());
    _impl_.quota_details_ = p;
  }
  return _impl_.quota_details_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* WorkspaceBillingInfo::mutable_quota_details() {
  ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* _msg = _internal_mutable_quota_details();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.quota_details)
  return _msg;
}
inline void WorkspaceBillingInfo::set_allocated_quota_details(::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaDetails* quota_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quota_details_;
  }
  if (quota_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quota_details);
    if (message_arena != submessage_arena) {
      quota_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quota_details, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.quota_details_ = quota_details;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceBillingInfo.quota_details)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha
}  // namespace studio
}  // namespace inworld
}  // namespace ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType>() {
  return ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource>() {
  return ::ai::inworld::studio::v1alpha::WorkspaceBillingInfo_QuotaSource_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::studio::v1alpha::WorkspaceItemView> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::studio::v1alpha::WorkspaceItemView>() {
  return ::ai::inworld::studio::v1alpha::WorkspaceItemView_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto
