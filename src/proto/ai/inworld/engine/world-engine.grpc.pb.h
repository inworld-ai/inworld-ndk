// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ai/inworld/engine/world-engine.proto
#ifndef GRPC_ai_2finworld_2fengine_2fworld_2dengine_2eproto__INCLUDED
#define GRPC_ai_2finworld_2fengine_2fworld_2dengine_2eproto__INCLUDED

#include "ai/inworld/engine/world-engine.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace ai {
namespace inworld {
namespace engine {

// Service that exposes bidirectional interaction session RPC. Effective runtime
// of the inworld.ai.
class WorldEngine final {
 public:
  static constexpr char const* service_full_name() {
    return "ai.inworld.engine.WorldEngine";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Bidirectional events based Session.
    // Requires LoadScene RPC to be called before.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> Session(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(SessionRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> AsyncSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(AsyncSessionRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> PrepareAsyncSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(PrepareAsyncSessionRaw(context, cq));
    }
    // Bidirectional events based Session.
    // Allows to open session with one rpc call.
    // All necessary configuration should be passed before data packets.
    // Configuration provided by SessionControlEvent and MutationEvent.
    // The Client capabilities, user settings, client settings and scene are required to start session.
    // Packets processed in the order of input.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> OpenSession(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(OpenSessionRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> AsyncOpenSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(AsyncOpenSessionRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> PrepareAsyncOpenSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(PrepareAsyncOpenSessionRaw(context, cq));
    }
    // RPC to load world for the interaction session.
    virtual ::grpc::Status LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::ai::inworld::engine::LoadSceneResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>> AsyncLoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>>(AsyncLoadSceneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>> PrepareAsyncLoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>>(PrepareAsyncLoadSceneRaw(context, request, cq));
    }
    // RPC to log errors for the interaction session.
    virtual ::grpc::Status LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::google::protobuf_inworld::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>> AsyncLogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>>(AsyncLogErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>> PrepareAsyncLogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>>(PrepareAsyncLogErrorRaw(context, request, cq));
    }
    // RPC to get voice preview
    virtual ::grpc::Status VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::ai::inworld::engine::VoicePreviewResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>> AsyncVoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>>(AsyncVoicePreviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>> PrepareAsyncVoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>>(PrepareAsyncVoicePreviewRaw(context, request, cq));
    }
    // RPC to load list of base voices.
    virtual ::grpc::Status ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::ai::inworld::engine::ListBaseVoicesResponce* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>> AsyncListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>>(AsyncListBaseVoicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>> PrepareAsyncListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>>(PrepareAsyncListBaseVoicesRaw(context, request, cq));
    }
    // Generates a JWT to access the world engine API with a given API key
    // A valid HMAC-SHA signature matching the API key in the request should be provided as authorization
    virtual ::grpc::Status GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::ai::inworld::engine::AccessToken* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>> AsyncGenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>>(AsyncGenerateTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>> PrepareAsyncGenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>>(PrepareAsyncGenerateTokenRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Bidirectional events based Session.
      // Requires LoadScene RPC to be called before.
      virtual void Session(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::ai::inworld::packets::InworldPacket,::ai::inworld::packets::InworldPacket>* reactor) = 0;
      // Bidirectional events based Session.
      // Allows to open session with one rpc call.
      // All necessary configuration should be passed before data packets.
      // Configuration provided by SessionControlEvent and MutationEvent.
      // The Client capabilities, user settings, client settings and scene are required to start session.
      // Packets processed in the order of input.
      virtual void OpenSession(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::ai::inworld::packets::InworldPacket,::ai::inworld::packets::InworldPacket>* reactor) = 0;
      // RPC to load world for the interaction session.
      virtual void LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RPC to log errors for the interaction session.
      virtual void LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RPC to get voice preview
      virtual void VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RPC to load list of base voices.
      virtual void ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Generates a JWT to access the world engine API with a given API key
      // A valid HMAC-SHA signature matching the API key in the request should be provided as authorization
      virtual void GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* SessionRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* AsyncSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* PrepareAsyncSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* OpenSessionRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* AsyncOpenSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* PrepareAsyncOpenSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>* AsyncLoadSceneRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::LoadSceneResponse>* PrepareAsyncLoadSceneRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>* AsyncLogErrorRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf_inworld::Empty>* PrepareAsyncLogErrorRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>* AsyncVoicePreviewRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::VoicePreviewResponse>* PrepareAsyncVoicePreviewRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>* AsyncListBaseVoicesRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::ListBaseVoicesResponce>* PrepareAsyncListBaseVoicesRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>* AsyncGenerateTokenRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ai::inworld::engine::AccessToken>* PrepareAsyncGenerateTokenRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> Session(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(SessionRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> AsyncSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(AsyncSessionRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> PrepareAsyncSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(PrepareAsyncSessionRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> OpenSession(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(OpenSessionRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> AsyncOpenSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(AsyncOpenSessionRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>> PrepareAsyncOpenSession(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>>(PrepareAsyncOpenSessionRaw(context, cq));
    }
    ::grpc::Status LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::ai::inworld::engine::LoadSceneResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>> AsyncLoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>>(AsyncLoadSceneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>> PrepareAsyncLoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>>(PrepareAsyncLoadSceneRaw(context, request, cq));
    }
    ::grpc::Status LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::google::protobuf_inworld::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>> AsyncLogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>>(AsyncLogErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>> PrepareAsyncLogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>>(PrepareAsyncLogErrorRaw(context, request, cq));
    }
    ::grpc::Status VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::ai::inworld::engine::VoicePreviewResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>> AsyncVoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>>(AsyncVoicePreviewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>> PrepareAsyncVoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>>(PrepareAsyncVoicePreviewRaw(context, request, cq));
    }
    ::grpc::Status ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::ai::inworld::engine::ListBaseVoicesResponce* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>> AsyncListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>>(AsyncListBaseVoicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>> PrepareAsyncListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>>(PrepareAsyncListBaseVoicesRaw(context, request, cq));
    }
    ::grpc::Status GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::ai::inworld::engine::AccessToken* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>> AsyncGenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>>(AsyncGenerateTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>> PrepareAsyncGenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>>(PrepareAsyncGenerateTokenRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Session(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::ai::inworld::packets::InworldPacket,::ai::inworld::packets::InworldPacket>* reactor) override;
      void OpenSession(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::ai::inworld::packets::InworldPacket,::ai::inworld::packets::InworldPacket>* reactor) override;
      void LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadScene(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response, std::function<void(::grpc::Status)>) override;
      void LogError(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response, std::function<void(::grpc::Status)>) override;
      void VoicePreview(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response, std::function<void(::grpc::Status)>) override;
      void ListBaseVoices(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response, std::function<void(::grpc::Status)>) override;
      void GenerateToken(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* SessionRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* AsyncSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* PrepareAsyncSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* OpenSessionRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* AsyncOpenSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* PrepareAsyncOpenSessionRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>* AsyncLoadSceneRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::LoadSceneResponse>* PrepareAsyncLoadSceneRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LoadSceneRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>* AsyncLogErrorRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf_inworld::Empty>* PrepareAsyncLogErrorRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::LogErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>* AsyncVoicePreviewRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::VoicePreviewResponse>* PrepareAsyncVoicePreviewRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::VoicePreviewRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>* AsyncListBaseVoicesRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::ListBaseVoicesResponce>* PrepareAsyncListBaseVoicesRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>* AsyncGenerateTokenRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ai::inworld::engine::AccessToken>* PrepareAsyncGenerateTokenRaw(::grpc::ClientContext* context, const ::ai::inworld::engine::GenerateTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Session_;
    const ::grpc::internal::RpcMethod rpcmethod_OpenSession_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadScene_;
    const ::grpc::internal::RpcMethod rpcmethod_LogError_;
    const ::grpc::internal::RpcMethod rpcmethod_VoicePreview_;
    const ::grpc::internal::RpcMethod rpcmethod_ListBaseVoices_;
    const ::grpc::internal::RpcMethod rpcmethod_GenerateToken_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Bidirectional events based Session.
    // Requires LoadScene RPC to be called before.
    virtual ::grpc::Status Session(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* stream);
    // Bidirectional events based Session.
    // Allows to open session with one rpc call.
    // All necessary configuration should be passed before data packets.
    // Configuration provided by SessionControlEvent and MutationEvent.
    // The Client capabilities, user settings, client settings and scene are required to start session.
    // Packets processed in the order of input.
    virtual ::grpc::Status OpenSession(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* stream);
    // RPC to load world for the interaction session.
    virtual ::grpc::Status LoadScene(::grpc::ServerContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response);
    // RPC to log errors for the interaction session.
    virtual ::grpc::Status LogError(::grpc::ServerContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response);
    // RPC to get voice preview
    virtual ::grpc::Status VoicePreview(::grpc::ServerContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response);
    // RPC to load list of base voices.
    virtual ::grpc::Status ListBaseVoices(::grpc::ServerContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response);
    // Generates a JWT to access the world engine API with a given API key
    // A valid HMAC-SHA signature matching the API key in the request should be provided as authorization
    virtual ::grpc::Status GenerateToken(::grpc::ServerContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Session : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Session() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Session() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Session(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OpenSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OpenSession() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_OpenSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenSession(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadScene() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadScene(::grpc::ServerContext* context, ::ai::inworld::engine::LoadSceneRequest* request, ::grpc::ServerAsyncResponseWriter< ::ai::inworld::engine::LoadSceneResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LogError() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogError(::grpc::ServerContext* context, ::ai::inworld::engine::LogErrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf_inworld::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VoicePreview() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVoicePreview(::grpc::ServerContext* context, ::ai::inworld::engine::VoicePreviewRequest* request, ::grpc::ServerAsyncResponseWriter< ::ai::inworld::engine::VoicePreviewResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListBaseVoices(::grpc::ServerContext* context, ::ai::inworld::engine::ListBaseVoicesRequest* request, ::grpc::ServerAsyncResponseWriter< ::ai::inworld::engine::ListBaseVoicesResponce>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GenerateToken() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateToken(::grpc::ServerContext* context, ::ai::inworld::engine::GenerateTokenRequest* request, ::grpc::ServerAsyncResponseWriter< ::ai::inworld::engine::AccessToken>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Session<WithAsyncMethod_OpenSession<WithAsyncMethod_LoadScene<WithAsyncMethod_LogError<WithAsyncMethod_VoicePreview<WithAsyncMethod_ListBaseVoices<WithAsyncMethod_GenerateToken<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Session : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Session() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackBidiHandler< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Session(context); }));
    }
    ~WithCallbackMethod_Session() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Session(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* Session(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OpenSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OpenSession() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackBidiHandler< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->OpenSession(context); }));
    }
    ~WithCallbackMethod_OpenSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenSession(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* OpenSession(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadScene() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::LoadSceneRequest, ::ai::inworld::engine::LoadSceneResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ai::inworld::engine::LoadSceneRequest* request, ::ai::inworld::engine::LoadSceneResponse* response) { return this->LoadScene(context, request, response); }));}
    void SetMessageAllocatorFor_LoadScene(
        ::grpc::MessageAllocator< ::ai::inworld::engine::LoadSceneRequest, ::ai::inworld::engine::LoadSceneResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::LoadSceneRequest, ::ai::inworld::engine::LoadSceneResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadScene(
      ::grpc::CallbackServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LogError() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::LogErrorRequest, ::google::protobuf_inworld::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ai::inworld::engine::LogErrorRequest* request, ::google::protobuf_inworld::Empty* response) { return this->LogError(context, request, response); }));}
    void SetMessageAllocatorFor_LogError(
        ::grpc::MessageAllocator< ::ai::inworld::engine::LogErrorRequest, ::google::protobuf_inworld::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::LogErrorRequest, ::google::protobuf_inworld::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LogError(
      ::grpc::CallbackServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_VoicePreview() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::VoicePreviewRequest, ::ai::inworld::engine::VoicePreviewResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ai::inworld::engine::VoicePreviewRequest* request, ::ai::inworld::engine::VoicePreviewResponse* response) { return this->VoicePreview(context, request, response); }));}
    void SetMessageAllocatorFor_VoicePreview(
        ::grpc::MessageAllocator< ::ai::inworld::engine::VoicePreviewRequest, ::ai::inworld::engine::VoicePreviewResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::VoicePreviewRequest, ::ai::inworld::engine::VoicePreviewResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VoicePreview(
      ::grpc::CallbackServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::ListBaseVoicesRequest, ::ai::inworld::engine::ListBaseVoicesResponce>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ai::inworld::engine::ListBaseVoicesRequest* request, ::ai::inworld::engine::ListBaseVoicesResponce* response) { return this->ListBaseVoices(context, request, response); }));}
    void SetMessageAllocatorFor_ListBaseVoices(
        ::grpc::MessageAllocator< ::ai::inworld::engine::ListBaseVoicesRequest, ::ai::inworld::engine::ListBaseVoicesResponce>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::ListBaseVoicesRequest, ::ai::inworld::engine::ListBaseVoicesResponce>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListBaseVoices(
      ::grpc::CallbackServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GenerateToken() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::GenerateTokenRequest, ::ai::inworld::engine::AccessToken>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ai::inworld::engine::GenerateTokenRequest* request, ::ai::inworld::engine::AccessToken* response) { return this->GenerateToken(context, request, response); }));}
    void SetMessageAllocatorFor_GenerateToken(
        ::grpc::MessageAllocator< ::ai::inworld::engine::GenerateTokenRequest, ::ai::inworld::engine::AccessToken>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ai::inworld::engine::GenerateTokenRequest, ::ai::inworld::engine::AccessToken>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateToken(
      ::grpc::CallbackServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Session<WithCallbackMethod_OpenSession<WithCallbackMethod_LoadScene<WithCallbackMethod_LogError<WithCallbackMethod_VoicePreview<WithCallbackMethod_ListBaseVoices<WithCallbackMethod_GenerateToken<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Session : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Session() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Session() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Session(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OpenSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OpenSession() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_OpenSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenSession(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadScene() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LogError() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VoicePreview() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GenerateToken() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Session : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Session() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Session() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Session(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OpenSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OpenSession() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_OpenSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenSession(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpenSession(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadScene() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadScene(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LogError() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogError(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VoicePreview() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVoicePreview(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListBaseVoices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GenerateToken() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Session : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Session() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->Session(context); }));
    }
    ~WithRawCallbackMethod_Session() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Session(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Session(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OpenSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OpenSession() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->OpenSession(context); }));
    }
    ~WithRawCallbackMethod_OpenSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OpenSession(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::ai::inworld::packets::InworldPacket, ::ai::inworld::packets::InworldPacket>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* OpenSession(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadScene() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadScene(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadScene(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LogError() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LogError(context, request, response); }));
    }
    ~WithRawCallbackMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LogError(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_VoicePreview() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VoicePreview(context, request, response); }));
    }
    ~WithRawCallbackMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* VoicePreview(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListBaseVoices(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListBaseVoices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GenerateToken() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GenerateToken(context, request, response); }));
    }
    ~WithRawCallbackMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadScene : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadScene() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ai::inworld::engine::LoadSceneRequest, ::ai::inworld::engine::LoadSceneResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ai::inworld::engine::LoadSceneRequest, ::ai::inworld::engine::LoadSceneResponse>* streamer) {
                       return this->StreamedLoadScene(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadScene() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadScene(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LoadSceneRequest* /*request*/, ::ai::inworld::engine::LoadSceneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadScene(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ai::inworld::engine::LoadSceneRequest,::ai::inworld::engine::LoadSceneResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LogError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LogError() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ai::inworld::engine::LogErrorRequest, ::google::protobuf_inworld::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ai::inworld::engine::LogErrorRequest, ::google::protobuf_inworld::Empty>* streamer) {
                       return this->StreamedLogError(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LogError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LogError(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::LogErrorRequest* /*request*/, ::google::protobuf_inworld::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogError(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ai::inworld::engine::LogErrorRequest,::google::protobuf_inworld::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VoicePreview : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VoicePreview() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ai::inworld::engine::VoicePreviewRequest, ::ai::inworld::engine::VoicePreviewResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ai::inworld::engine::VoicePreviewRequest, ::ai::inworld::engine::VoicePreviewResponse>* streamer) {
                       return this->StreamedVoicePreview(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VoicePreview() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VoicePreview(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::VoicePreviewRequest* /*request*/, ::ai::inworld::engine::VoicePreviewResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVoicePreview(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ai::inworld::engine::VoicePreviewRequest,::ai::inworld::engine::VoicePreviewResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListBaseVoices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListBaseVoices() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ai::inworld::engine::ListBaseVoicesRequest, ::ai::inworld::engine::ListBaseVoicesResponce>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ai::inworld::engine::ListBaseVoicesRequest, ::ai::inworld::engine::ListBaseVoicesResponce>* streamer) {
                       return this->StreamedListBaseVoices(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListBaseVoices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListBaseVoices(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::ListBaseVoicesRequest* /*request*/, ::ai::inworld::engine::ListBaseVoicesResponce* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListBaseVoices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ai::inworld::engine::ListBaseVoicesRequest,::ai::inworld::engine::ListBaseVoicesResponce>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GenerateToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GenerateToken() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ai::inworld::engine::GenerateTokenRequest, ::ai::inworld::engine::AccessToken>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ai::inworld::engine::GenerateTokenRequest, ::ai::inworld::engine::AccessToken>* streamer) {
                       return this->StreamedGenerateToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GenerateToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GenerateToken(::grpc::ServerContext* /*context*/, const ::ai::inworld::engine::GenerateTokenRequest* /*request*/, ::ai::inworld::engine::AccessToken* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerateToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ai::inworld::engine::GenerateTokenRequest,::ai::inworld::engine::AccessToken>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_LoadScene<WithStreamedUnaryMethod_LogError<WithStreamedUnaryMethod_VoicePreview<WithStreamedUnaryMethod_ListBaseVoices<WithStreamedUnaryMethod_GenerateToken<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_LoadScene<WithStreamedUnaryMethod_LogError<WithStreamedUnaryMethod_VoicePreview<WithStreamedUnaryMethod_ListBaseVoices<WithStreamedUnaryMethod_GenerateToken<Service > > > > > StreamedService;
};

}  // namespace engine
}  // namespace inworld
}  // namespace ai


#endif  // GRPC_ai_2finworld_2fengine_2fworld_2dengine_2eproto__INCLUDED
