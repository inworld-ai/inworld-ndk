// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ai/inworld/packets/packets.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/struct.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "ai/inworld/options/options.pb.h"
#include "ai/inworld/engine/configuration/configuration.pb.h"
#include "ai/inworld/language_codes/language_codes.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ai_2finworld_2fpackets_2fpackets_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf_inworld::internal::DescriptorTable
    descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto;
namespace ai {
namespace inworld {
namespace packets {
class ActionEvent;
struct ActionEventDefaultTypeInternal;
extern ActionEventDefaultTypeInternal _ActionEvent_default_instance_;
class Actor;
struct ActorDefaultTypeInternal;
extern ActorDefaultTypeInternal _Actor_default_instance_;
class AdditionalPhonemeInfo;
struct AdditionalPhonemeInfoDefaultTypeInternal;
extern AdditionalPhonemeInfoDefaultTypeInternal _AdditionalPhonemeInfo_default_instance_;
class Agent;
struct AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class ApplyResponse;
struct ApplyResponseDefaultTypeInternal;
extern ApplyResponseDefaultTypeInternal _ApplyResponse_default_instance_;
class AudioChunk;
struct AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class CancelResponses;
struct CancelResponsesDefaultTypeInternal;
extern CancelResponsesDefaultTypeInternal _CancelResponses_default_instance_;
class CancelResponsesEvent;
struct CancelResponsesEventDefaultTypeInternal;
extern CancelResponsesEventDefaultTypeInternal _CancelResponsesEvent_default_instance_;
class Continuation;
struct ContinuationDefaultTypeInternal;
extern ContinuationDefaultTypeInternal _Continuation_default_instance_;
class Continuation_ContinuationInfo;
struct Continuation_ContinuationInfoDefaultTypeInternal;
extern Continuation_ContinuationInfoDefaultTypeInternal _Continuation_ContinuationInfo_default_instance_;
class ControlEvent;
struct ControlEventDefaultTypeInternal;
extern ControlEventDefaultTypeInternal _ControlEvent_default_instance_;
class CustomEvent;
struct CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class CustomEvent_Parameter;
struct CustomEvent_ParameterDefaultTypeInternal;
extern CustomEvent_ParameterDefaultTypeInternal _CustomEvent_Parameter_default_instance_;
class DataChunk;
struct DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class DebugInfoEvent;
struct DebugInfoEventDefaultTypeInternal;
extern DebugInfoEventDefaultTypeInternal _DebugInfoEvent_default_instance_;
class DialogHistory;
struct DialogHistoryDefaultTypeInternal;
extern DialogHistoryDefaultTypeInternal _DialogHistory_default_instance_;
class DialogHistory_HistoryItem;
struct DialogHistory_HistoryItemDefaultTypeInternal;
extern DialogHistory_HistoryItemDefaultTypeInternal _DialogHistory_HistoryItem_default_instance_;
class EmotionEvent;
struct EmotionEventDefaultTypeInternal;
extern EmotionEventDefaultTypeInternal _EmotionEvent_default_instance_;
class InworldPacket;
struct InworldPacketDefaultTypeInternal;
extern InworldPacketDefaultTypeInternal _InworldPacket_default_instance_;
class LoadCharacters;
struct LoadCharactersDefaultTypeInternal;
extern LoadCharactersDefaultTypeInternal _LoadCharacters_default_instance_;
class LoadCharacters_CharacterName;
struct LoadCharacters_CharacterNameDefaultTypeInternal;
extern LoadCharacters_CharacterNameDefaultTypeInternal _LoadCharacters_CharacterName_default_instance_;
class LoadScene;
struct LoadSceneDefaultTypeInternal;
extern LoadSceneDefaultTypeInternal _LoadScene_default_instance_;
class LoadSceneOutputEvent;
struct LoadSceneOutputEventDefaultTypeInternal;
extern LoadSceneOutputEventDefaultTypeInternal _LoadSceneOutputEvent_default_instance_;
class LoadSceneOutputEvent_Agent;
struct LoadSceneOutputEvent_AgentDefaultTypeInternal;
extern LoadSceneOutputEvent_AgentDefaultTypeInternal _LoadSceneOutputEvent_Agent_default_instance_;
class LoadedCharacters;
struct LoadedCharactersDefaultTypeInternal;
extern LoadedCharactersDefaultTypeInternal _LoadedCharacters_default_instance_;
class LoadedScene;
struct LoadedSceneDefaultTypeInternal;
extern LoadedSceneDefaultTypeInternal _LoadedScene_default_instance_;
class ModifyExactResponse;
struct ModifyExactResponseDefaultTypeInternal;
extern ModifyExactResponseDefaultTypeInternal _ModifyExactResponse_default_instance_;
class MutationEvent;
struct MutationEventDefaultTypeInternal;
extern MutationEventDefaultTypeInternal _MutationEvent_default_instance_;
class NarratedAction;
struct NarratedActionDefaultTypeInternal;
extern NarratedActionDefaultTypeInternal _NarratedAction_default_instance_;
class PacketId;
struct PacketIdDefaultTypeInternal;
extern PacketIdDefaultTypeInternal _PacketId_default_instance_;
class RegenerateResponse;
struct RegenerateResponseDefaultTypeInternal;
extern RegenerateResponseDefaultTypeInternal _RegenerateResponse_default_instance_;
class RelationInfo;
struct RelationInfoDefaultTypeInternal;
extern RelationInfoDefaultTypeInternal _RelationInfo_default_instance_;
class RelationInfo_RelationAttributes;
struct RelationInfo_RelationAttributesDefaultTypeInternal;
extern RelationInfo_RelationAttributesDefaultTypeInternal _RelationInfo_RelationAttributes_default_instance_;
class Relations;
struct RelationsDefaultTypeInternal;
extern RelationsDefaultTypeInternal _Relations_default_instance_;
class Relations_Relation;
struct Relations_RelationDefaultTypeInternal;
extern Relations_RelationDefaultTypeInternal _Relations_Relation_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class SessionControlEvent;
struct SessionControlEventDefaultTypeInternal;
extern SessionControlEventDefaultTypeInternal _SessionControlEvent_default_instance_;
class SessionControlResponseEvent;
struct SessionControlResponseEventDefaultTypeInternal;
extern SessionControlResponseEventDefaultTypeInternal _SessionControlResponseEvent_default_instance_;
class TextEvent;
struct TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
class TextEvent_ModelInfo;
struct TextEvent_ModelInfoDefaultTypeInternal;
extern TextEvent_ModelInfoDefaultTypeInternal _TextEvent_ModelInfo_default_instance_;
class UnloadCharacters;
struct UnloadCharactersDefaultTypeInternal;
extern UnloadCharactersDefaultTypeInternal _UnloadCharacters_default_instance_;
}  // namespace packets
}  // namespace inworld
}  // namespace ai
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ai {
namespace inworld {
namespace packets {
enum Actor_Type : int {
  Actor_Type_UNKNOWN = 0,
  Actor_Type_PLAYER = 1,
  Actor_Type_AGENT = 2,
  Actor_Type_WORLD = 3,
  Actor_Type_Actor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Actor_Type_Actor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Actor_Type_IsValid(int value);
extern const uint32_t Actor_Type_internal_data_[];
constexpr Actor_Type Actor_Type_Type_MIN = static_cast<Actor_Type>(0);
constexpr Actor_Type Actor_Type_Type_MAX = static_cast<Actor_Type>(3);
constexpr int Actor_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
Actor_Type_descriptor();
template <typename T>
const std::string& Actor_Type_Name(T value) {
  static_assert(std::is_same<T, Actor_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Actor_Type_Name(static_cast<Actor_Type>(value));
}
template <>
inline const std::string& Actor_Type_Name(Actor_Type value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<Actor_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Actor_Type_Parse(absl::string_view name, Actor_Type* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<Actor_Type>(
      Actor_Type_descriptor(), name, value);
}
enum TextEvent_SourceType : int {
  TextEvent_SourceType_UNKNOWN = 0,
  TextEvent_SourceType_SPEECH_TO_TEXT = 1,
  TextEvent_SourceType_TYPED_IN = 2,
  TextEvent_SourceType_GENERATED = 3,
  TextEvent_SourceType_FILLER = 4,
  TextEvent_SourceType_TextEvent_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TextEvent_SourceType_TextEvent_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TextEvent_SourceType_IsValid(int value);
extern const uint32_t TextEvent_SourceType_internal_data_[];
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MIN = static_cast<TextEvent_SourceType>(0);
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MAX = static_cast<TextEvent_SourceType>(4);
constexpr int TextEvent_SourceType_SourceType_ARRAYSIZE = 4 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
TextEvent_SourceType_descriptor();
template <typename T>
const std::string& TextEvent_SourceType_Name(T value) {
  static_assert(std::is_same<T, TextEvent_SourceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SourceType_Name().");
  return TextEvent_SourceType_Name(static_cast<TextEvent_SourceType>(value));
}
template <>
inline const std::string& TextEvent_SourceType_Name(TextEvent_SourceType value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<TextEvent_SourceType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TextEvent_SourceType_Parse(absl::string_view name, TextEvent_SourceType* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<TextEvent_SourceType>(
      TextEvent_SourceType_descriptor(), name, value);
}
enum ControlEvent_Action : int {
  ControlEvent_Action_UNKNOWN = 0,
  ControlEvent_Action_AUDIO_SESSION_START = 1,
  ControlEvent_Action_AUDIO_SESSION_END = 2,
  ControlEvent_Action_INTERACTION_END = 3,
  ControlEvent_Action_TTS_PLAYBACK_START = 4,
  ControlEvent_Action_TTS_PLAYBACK_END = 5,
  ControlEvent_Action_TTS_PLAYBACK_MUTE = 6,
  ControlEvent_Action_TTS_PLAYBACK_UNMUTE = 7,
  ControlEvent_Action_WARNING = 8,
  ControlEvent_Action_SESSION_END = 9,
  ControlEvent_Action_CONVERSATION_START = 10,
  ControlEvent_Action_CONVERSATION_UPDATE = 12,
  ControlEvent_Action_CONVERSATION_STARTED = 13,
  ControlEvent_Action_ControlEvent_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControlEvent_Action_ControlEvent_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControlEvent_Action_IsValid(int value);
extern const uint32_t ControlEvent_Action_internal_data_[];
constexpr ControlEvent_Action ControlEvent_Action_Action_MIN = static_cast<ControlEvent_Action>(0);
constexpr ControlEvent_Action ControlEvent_Action_Action_MAX = static_cast<ControlEvent_Action>(13);
constexpr int ControlEvent_Action_Action_ARRAYSIZE = 13 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
ControlEvent_Action_descriptor();
template <typename T>
const std::string& ControlEvent_Action_Name(T value) {
  static_assert(std::is_same<T, ControlEvent_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return ControlEvent_Action_Name(static_cast<ControlEvent_Action>(value));
}
template <>
inline const std::string& ControlEvent_Action_Name(ControlEvent_Action value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<ControlEvent_Action_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool ControlEvent_Action_Parse(absl::string_view name, ControlEvent_Action* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<ControlEvent_Action>(
      ControlEvent_Action_descriptor(), name, value);
}
enum EmotionEvent_SpaffCode : int {
  EmotionEvent_SpaffCode_NEUTRAL = 0,
  EmotionEvent_SpaffCode_DISGUST = 1,
  EmotionEvent_SpaffCode_CONTEMPT = 2,
  EmotionEvent_SpaffCode_BELLIGERENCE = 3,
  EmotionEvent_SpaffCode_DOMINEERING = 4,
  EmotionEvent_SpaffCode_CRITICISM = 5,
  EmotionEvent_SpaffCode_ANGER = 6,
  EmotionEvent_SpaffCode_TENSION = 7,
  EmotionEvent_SpaffCode_TENSE_HUMOR = 8,
  EmotionEvent_SpaffCode_DEFENSIVENESS = 9,
  EmotionEvent_SpaffCode_WHINING = 10,
  EmotionEvent_SpaffCode_SADNESS = 11,
  EmotionEvent_SpaffCode_STONEWALLING = 12,
  EmotionEvent_SpaffCode_INTEREST = 13,
  EmotionEvent_SpaffCode_VALIDATION = 14,
  EmotionEvent_SpaffCode_AFFECTION = 15,
  EmotionEvent_SpaffCode_HUMOR = 16,
  EmotionEvent_SpaffCode_SURPRISE = 17,
  EmotionEvent_SpaffCode_JOY = 18,
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EmotionEvent_SpaffCode_IsValid(int value);
extern const uint32_t EmotionEvent_SpaffCode_internal_data_[];
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MIN = static_cast<EmotionEvent_SpaffCode>(0);
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MAX = static_cast<EmotionEvent_SpaffCode>(18);
constexpr int EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE = 18 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
EmotionEvent_SpaffCode_descriptor();
template <typename T>
const std::string& EmotionEvent_SpaffCode_Name(T value) {
  static_assert(std::is_same<T, EmotionEvent_SpaffCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SpaffCode_Name().");
  return EmotionEvent_SpaffCode_Name(static_cast<EmotionEvent_SpaffCode>(value));
}
template <>
inline const std::string& EmotionEvent_SpaffCode_Name(EmotionEvent_SpaffCode value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<EmotionEvent_SpaffCode_descriptor,
                                                 0, 18>(
      static_cast<int>(value));
}
inline bool EmotionEvent_SpaffCode_Parse(absl::string_view name, EmotionEvent_SpaffCode* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<EmotionEvent_SpaffCode>(
      EmotionEvent_SpaffCode_descriptor(), name, value);
}
enum EmotionEvent_Strength : int {
  EmotionEvent_Strength_UNSPECIFIED = 0,
  EmotionEvent_Strength_WEAK = 1,
  EmotionEvent_Strength_STRONG = 2,
  EmotionEvent_Strength_NORMAL = 3,
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EmotionEvent_Strength_IsValid(int value);
extern const uint32_t EmotionEvent_Strength_internal_data_[];
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MIN = static_cast<EmotionEvent_Strength>(0);
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MAX = static_cast<EmotionEvent_Strength>(3);
constexpr int EmotionEvent_Strength_Strength_ARRAYSIZE = 3 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
EmotionEvent_Strength_descriptor();
template <typename T>
const std::string& EmotionEvent_Strength_Name(T value) {
  static_assert(std::is_same<T, EmotionEvent_Strength>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Strength_Name().");
  return EmotionEvent_Strength_Name(static_cast<EmotionEvent_Strength>(value));
}
template <>
inline const std::string& EmotionEvent_Strength_Name(EmotionEvent_Strength value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<EmotionEvent_Strength_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EmotionEvent_Strength_Parse(absl::string_view name, EmotionEvent_Strength* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<EmotionEvent_Strength>(
      EmotionEvent_Strength_descriptor(), name, value);
}
enum DataChunk_DataType : int {
  DataChunk_DataType_UNSPECIFIED = 0,
  DataChunk_DataType_AUDIO = 1,
  DataChunk_DataType_SILENCE = 3,
  DataChunk_DataType_STATE = 4,
  DataChunk_DataType_DataChunk_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataChunk_DataType_DataChunk_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataChunk_DataType_IsValid(int value);
extern const uint32_t DataChunk_DataType_internal_data_[];
constexpr DataChunk_DataType DataChunk_DataType_DataType_MIN = static_cast<DataChunk_DataType>(0);
constexpr DataChunk_DataType DataChunk_DataType_DataType_MAX = static_cast<DataChunk_DataType>(4);
constexpr int DataChunk_DataType_DataType_ARRAYSIZE = 4 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
DataChunk_DataType_descriptor();
template <typename T>
const std::string& DataChunk_DataType_Name(T value) {
  static_assert(std::is_same<T, DataChunk_DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return DataChunk_DataType_Name(static_cast<DataChunk_DataType>(value));
}
template <>
inline const std::string& DataChunk_DataType_Name(DataChunk_DataType value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<DataChunk_DataType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DataChunk_DataType_Parse(absl::string_view name, DataChunk_DataType* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<DataChunk_DataType>(
      DataChunk_DataType_descriptor(), name, value);
}
enum DataChunk_AudioFormat : int {
  DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT = 0,
  DataChunk_AudioFormat_AUDIO_MP3 = 1,
  DataChunk_AudioFormat_AUDIO_PCM_16000 = 2,
  DataChunk_AudioFormat_AUDIO_PCM_22050 = 3,
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataChunk_AudioFormat_IsValid(int value);
extern const uint32_t DataChunk_AudioFormat_internal_data_[];
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MIN = static_cast<DataChunk_AudioFormat>(0);
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MAX = static_cast<DataChunk_AudioFormat>(3);
constexpr int DataChunk_AudioFormat_AudioFormat_ARRAYSIZE = 3 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
DataChunk_AudioFormat_descriptor();
template <typename T>
const std::string& DataChunk_AudioFormat_Name(T value) {
  static_assert(std::is_same<T, DataChunk_AudioFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AudioFormat_Name().");
  return DataChunk_AudioFormat_Name(static_cast<DataChunk_AudioFormat>(value));
}
template <>
inline const std::string& DataChunk_AudioFormat_Name(DataChunk_AudioFormat value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<DataChunk_AudioFormat_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DataChunk_AudioFormat_Parse(absl::string_view name, DataChunk_AudioFormat* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<DataChunk_AudioFormat>(
      DataChunk_AudioFormat_descriptor(), name, value);
}
enum Continuation_ContinuationType : int {
  Continuation_ContinuationType_CONTINUATION_TYPE_UNKNOWN = 0,
  Continuation_ContinuationType_CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE = 1,
  Continuation_ContinuationType_CONTINUATION_TYPE_DIALOG_HISTORY = 2,
  Continuation_ContinuationType_Continuation_ContinuationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Continuation_ContinuationType_Continuation_ContinuationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Continuation_ContinuationType_IsValid(int value);
extern const uint32_t Continuation_ContinuationType_internal_data_[];
constexpr Continuation_ContinuationType Continuation_ContinuationType_ContinuationType_MIN = static_cast<Continuation_ContinuationType>(0);
constexpr Continuation_ContinuationType Continuation_ContinuationType_ContinuationType_MAX = static_cast<Continuation_ContinuationType>(2);
constexpr int Continuation_ContinuationType_ContinuationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
Continuation_ContinuationType_descriptor();
template <typename T>
const std::string& Continuation_ContinuationType_Name(T value) {
  static_assert(std::is_same<T, Continuation_ContinuationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContinuationType_Name().");
  return Continuation_ContinuationType_Name(static_cast<Continuation_ContinuationType>(value));
}
template <>
inline const std::string& Continuation_ContinuationType_Name(Continuation_ContinuationType value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<Continuation_ContinuationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Continuation_ContinuationType_Parse(absl::string_view name, Continuation_ContinuationType* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<Continuation_ContinuationType>(
      Continuation_ContinuationType_descriptor(), name, value);
}
enum Playback : int {
  UNSPECIFIED = 0,
  INTERACTION = 1,
  INTERACTION_END = 2,
  UTTERANCE = 3,
  Playback_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Playback_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Playback_IsValid(int value);
extern const uint32_t Playback_internal_data_[];
constexpr Playback Playback_MIN = static_cast<Playback>(0);
constexpr Playback Playback_MAX = static_cast<Playback>(3);
constexpr int Playback_ARRAYSIZE = 3 + 1;
const ::google::protobuf_inworld::EnumDescriptor*
Playback_descriptor();
template <typename T>
const std::string& Playback_Name(T value) {
  static_assert(std::is_same<T, Playback>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Playback_Name().");
  return Playback_Name(static_cast<Playback>(value));
}
template <>
inline const std::string& Playback_Name(Playback value) {
  return ::google::protobuf_inworld::internal::NameOfDenseEnum<Playback_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Playback_Parse(absl::string_view name, Playback* value) {
  return ::google::protobuf_inworld::internal::ParseNamedEnum<Playback>(
      Playback_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TextEvent_ModelInfo final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent.ModelInfo) */ {
 public:
  inline TextEvent_ModelInfo() : TextEvent_ModelInfo(nullptr) {}
  ~TextEvent_ModelInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextEvent_ModelInfo(::google::protobuf_inworld::internal::ConstantInitialized);

  inline TextEvent_ModelInfo(const TextEvent_ModelInfo& from)
      : TextEvent_ModelInfo(nullptr, from) {}
  TextEvent_ModelInfo(TextEvent_ModelInfo&& from) noexcept
    : TextEvent_ModelInfo() {
    *this = ::std::move(from);
  }

  inline TextEvent_ModelInfo& operator=(const TextEvent_ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent_ModelInfo& operator=(TextEvent_ModelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEvent_ModelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEvent_ModelInfo* internal_default_instance() {
    return reinterpret_cast<const TextEvent_ModelInfo*>(
               &_TextEvent_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TextEvent_ModelInfo& a, TextEvent_ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent_ModelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent_ModelInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEvent_ModelInfo* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEvent_ModelInfo>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const TextEvent_ModelInfo& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const TextEvent_ModelInfo& from) {
    TextEvent_ModelInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextEvent_ModelInfo* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.TextEvent.ModelInfo";
  }
  protected:
  explicit TextEvent_ModelInfo(::google::protobuf_inworld::Arena* arena);
  TextEvent_ModelInfo(::google::protobuf_inworld::Arena* arena, const TextEvent_ModelInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string service = 1;
  void clear_service() ;
  const std::string& service() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service(Arg_&& arg, Args_... args);
  std::string* mutable_service();
  PROTOBUF_NODISCARD std::string* release_service();
  void set_allocated_service(std::string* value);

  private:
  const std::string& _internal_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service(
      const std::string& value);
  std::string* _internal_mutable_service();

  public:
  // string model = 2;
  void clear_model() ;
  const std::string& model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model(Arg_&& arg, Args_... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* value);

  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(
      const std::string& value);
  std::string* _internal_mutable_model();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent.ModelInfo)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr service_;
    ::google::protobuf_inworld::internal::ArenaStringPtr model_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Relations_Relation final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Relations.Relation) */ {
 public:
  inline Relations_Relation() : Relations_Relation(nullptr) {}
  ~Relations_Relation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Relations_Relation(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Relations_Relation(const Relations_Relation& from)
      : Relations_Relation(nullptr, from) {}
  Relations_Relation(Relations_Relation&& from) noexcept
    : Relations_Relation() {
    *this = ::std::move(from);
  }

  inline Relations_Relation& operator=(const Relations_Relation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relations_Relation& operator=(Relations_Relation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relations_Relation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relations_Relation* internal_default_instance() {
    return reinterpret_cast<const Relations_Relation*>(
               &_Relations_Relation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Relations_Relation& a, Relations_Relation& b) {
    a.Swap(&b);
  }
  inline void Swap(Relations_Relation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relations_Relation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relations_Relation* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relations_Relation>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Relations_Relation& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Relations_Relation& from) {
    Relations_Relation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Relations_Relation* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Relations.Relation";
  }
  protected:
  explicit Relations_Relation(::google::protobuf_inworld::Arena* arena);
  Relations_Relation(::google::protobuf_inworld::Arena* arena, const Relations_Relation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLabelFieldNumber = 2,
  };
  // string type = 1;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string label = 2;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Relations.Relation)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr type_;
    ::google::protobuf_inworld::internal::ArenaStringPtr label_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class RelationInfo_RelationAttributes final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo.RelationAttributes) */ {
 public:
  inline RelationInfo_RelationAttributes() : RelationInfo_RelationAttributes(nullptr) {}
  ~RelationInfo_RelationAttributes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelationInfo_RelationAttributes(::google::protobuf_inworld::internal::ConstantInitialized);

  inline RelationInfo_RelationAttributes(const RelationInfo_RelationAttributes& from)
      : RelationInfo_RelationAttributes(nullptr, from) {}
  RelationInfo_RelationAttributes(RelationInfo_RelationAttributes&& from) noexcept
    : RelationInfo_RelationAttributes() {
    *this = ::std::move(from);
  }

  inline RelationInfo_RelationAttributes& operator=(const RelationInfo_RelationAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo_RelationAttributes& operator=(RelationInfo_RelationAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationInfo_RelationAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationInfo_RelationAttributes* internal_default_instance() {
    return reinterpret_cast<const RelationInfo_RelationAttributes*>(
               &_RelationInfo_RelationAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RelationInfo_RelationAttributes& a, RelationInfo_RelationAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationInfo_RelationAttributes* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const RelationInfo_RelationAttributes& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const RelationInfo_RelationAttributes& from) {
    RelationInfo_RelationAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(RelationInfo_RelationAttributes* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.RelationInfo.RelationAttributes";
  }
  protected:
  explicit RelationInfo_RelationAttributes(::google::protobuf_inworld::Arena* arena);
  RelationInfo_RelationAttributes(::google::protobuf_inworld::Arena* arena, const RelationInfo_RelationAttributes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustFieldNumber = 1,
    kRespectFieldNumber = 2,
    kFamiliarFieldNumber = 3,
    kFlirtatiousFieldNumber = 4,
    kAttractionFieldNumber = 5,
  };
  // int32 trust = 1;
  void clear_trust() ;
  ::int32_t trust() const;
  void set_trust(::int32_t value);

  private:
  ::int32_t _internal_trust() const;
  void _internal_set_trust(::int32_t value);

  public:
  // int32 respect = 2;
  void clear_respect() ;
  ::int32_t respect() const;
  void set_respect(::int32_t value);

  private:
  ::int32_t _internal_respect() const;
  void _internal_set_respect(::int32_t value);

  public:
  // int32 familiar = 3;
  void clear_familiar() ;
  ::int32_t familiar() const;
  void set_familiar(::int32_t value);

  private:
  ::int32_t _internal_familiar() const;
  void _internal_set_familiar(::int32_t value);

  public:
  // int32 flirtatious = 4;
  void clear_flirtatious() ;
  ::int32_t flirtatious() const;
  void set_flirtatious(::int32_t value);

  private:
  ::int32_t _internal_flirtatious() const;
  void _internal_set_flirtatious(::int32_t value);

  public:
  // int32 attraction = 5;
  void clear_attraction() ;
  ::int32_t attraction() const;
  void set_attraction(::int32_t value);

  private:
  ::int32_t _internal_attraction() const;
  void _internal_set_attraction(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo.RelationAttributes)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::int32_t trust_;
    ::int32_t respect_;
    ::int32_t familiar_;
    ::int32_t flirtatious_;
    ::int32_t attraction_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class RegenerateResponse final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RegenerateResponse) */ {
 public:
  inline RegenerateResponse() : RegenerateResponse(nullptr) {}
  ~RegenerateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegenerateResponse(::google::protobuf_inworld::internal::ConstantInitialized);

  inline RegenerateResponse(const RegenerateResponse& from)
      : RegenerateResponse(nullptr, from) {}
  RegenerateResponse(RegenerateResponse&& from) noexcept
    : RegenerateResponse() {
    *this = ::std::move(from);
  }

  inline RegenerateResponse& operator=(const RegenerateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegenerateResponse& operator=(RegenerateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegenerateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegenerateResponse* internal_default_instance() {
    return reinterpret_cast<const RegenerateResponse*>(
               &_RegenerateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RegenerateResponse& a, RegenerateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegenerateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegenerateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegenerateResponse* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegenerateResponse>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const RegenerateResponse& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const RegenerateResponse& from) {
    RegenerateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegenerateResponse* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.RegenerateResponse";
  }
  protected:
  explicit RegenerateResponse(::google::protobuf_inworld::Arena* arena);
  RegenerateResponse(::google::protobuf_inworld::Arena* arena, const RegenerateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
  };
  // string interaction_id = 1;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RegenerateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr interaction_id_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class PacketId final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PacketId) */ {
 public:
  inline PacketId() : PacketId(nullptr) {}
  ~PacketId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PacketId(::google::protobuf_inworld::internal::ConstantInitialized);

  inline PacketId(const PacketId& from)
      : PacketId(nullptr, from) {}
  PacketId(PacketId&& from) noexcept
    : PacketId() {
    *this = ::std::move(from);
  }

  inline PacketId& operator=(const PacketId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketId& operator=(PacketId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketId* internal_default_instance() {
    return reinterpret_cast<const PacketId*>(
               &_PacketId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketId& a, PacketId& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketId* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketId>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const PacketId& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const PacketId& from) {
    PacketId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(PacketId* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.PacketId";
  }
  protected:
  explicit PacketId(::google::protobuf_inworld::Arena* arena);
  PacketId(::google::protobuf_inworld::Arena* arena, const PacketId& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 3,
    kCorrelationIdFieldNumber = 4,
    kConversationIdFieldNumber = 5,
  };
  // string packet_id = 1;
  void clear_packet_id() ;
  const std::string& packet_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_id(Arg_&& arg, Args_... args);
  std::string* mutable_packet_id();
  PROTOBUF_NODISCARD std::string* release_packet_id();
  void set_allocated_packet_id(std::string* value);

  private:
  const std::string& _internal_packet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_id(
      const std::string& value);
  std::string* _internal_mutable_packet_id();

  public:
  // string utterance_id = 2;
  void clear_utterance_id() ;
  const std::string& utterance_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_utterance_id(Arg_&& arg, Args_... args);
  std::string* mutable_utterance_id();
  PROTOBUF_NODISCARD std::string* release_utterance_id();
  void set_allocated_utterance_id(std::string* value);

  private:
  const std::string& _internal_utterance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utterance_id(
      const std::string& value);
  std::string* _internal_mutable_utterance_id();

  public:
  // string interaction_id = 3;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // string correlation_id = 4;
  void clear_correlation_id() ;
  const std::string& correlation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_correlation_id(Arg_&& arg, Args_... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* value);

  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(
      const std::string& value);
  std::string* _internal_mutable_correlation_id();

  public:
  // string conversation_id = 5;
  void clear_conversation_id() ;
  const std::string& conversation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conversation_id(Arg_&& arg, Args_... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* value);

  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(
      const std::string& value);
  std::string* _internal_mutable_conversation_id();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PacketId)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      3, 5, 0,
      100, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr packet_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr utterance_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr interaction_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr correlation_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr conversation_id_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class NarratedAction final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.NarratedAction) */ {
 public:
  inline NarratedAction() : NarratedAction(nullptr) {}
  ~NarratedAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NarratedAction(::google::protobuf_inworld::internal::ConstantInitialized);

  inline NarratedAction(const NarratedAction& from)
      : NarratedAction(nullptr, from) {}
  NarratedAction(NarratedAction&& from) noexcept
    : NarratedAction() {
    *this = ::std::move(from);
  }

  inline NarratedAction& operator=(const NarratedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NarratedAction& operator=(NarratedAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NarratedAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const NarratedAction* internal_default_instance() {
    return reinterpret_cast<const NarratedAction*>(
               &_NarratedAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NarratedAction& a, NarratedAction& b) {
    a.Swap(&b);
  }
  inline void Swap(NarratedAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NarratedAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NarratedAction* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NarratedAction>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const NarratedAction& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const NarratedAction& from) {
    NarratedAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(NarratedAction* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.NarratedAction";
  }
  protected:
  explicit NarratedAction(::google::protobuf_inworld::Arena* arena);
  NarratedAction(::google::protobuf_inworld::Arena* arena, const NarratedAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.NarratedAction)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr content_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class ModifyExactResponse final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ModifyExactResponse) */ {
 public:
  inline ModifyExactResponse() : ModifyExactResponse(nullptr) {}
  ~ModifyExactResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModifyExactResponse(::google::protobuf_inworld::internal::ConstantInitialized);

  inline ModifyExactResponse(const ModifyExactResponse& from)
      : ModifyExactResponse(nullptr, from) {}
  ModifyExactResponse(ModifyExactResponse&& from) noexcept
    : ModifyExactResponse() {
    *this = ::std::move(from);
  }

  inline ModifyExactResponse& operator=(const ModifyExactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyExactResponse& operator=(ModifyExactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyExactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyExactResponse* internal_default_instance() {
    return reinterpret_cast<const ModifyExactResponse*>(
               &_ModifyExactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ModifyExactResponse& a, ModifyExactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyExactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyExactResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyExactResponse* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyExactResponse>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const ModifyExactResponse& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const ModifyExactResponse& from) {
    ModifyExactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(ModifyExactResponse* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.ModifyExactResponse";
  }
  protected:
  explicit ModifyExactResponse(::google::protobuf_inworld::Arena* arena);
  ModifyExactResponse(::google::protobuf_inworld::Arena* arena, const ModifyExactResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kExactTextFieldNumber = 2,
  };
  // string interaction_id = 1;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // string exact_text = 2;
  void clear_exact_text() ;
  const std::string& exact_text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_exact_text(Arg_&& arg, Args_... args);
  std::string* mutable_exact_text();
  PROTOBUF_NODISCARD std::string* release_exact_text();
  void set_allocated_exact_text(std::string* value);

  private:
  const std::string& _internal_exact_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exact_text(
      const std::string& value);
  std::string* _internal_mutable_exact_text();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ModifyExactResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr interaction_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr exact_text_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadSceneOutputEvent_Agent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent.Agent) */ {
 public:
  inline LoadSceneOutputEvent_Agent() : LoadSceneOutputEvent_Agent(nullptr) {}
  ~LoadSceneOutputEvent_Agent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadSceneOutputEvent_Agent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadSceneOutputEvent_Agent(const LoadSceneOutputEvent_Agent& from)
      : LoadSceneOutputEvent_Agent(nullptr, from) {}
  LoadSceneOutputEvent_Agent(LoadSceneOutputEvent_Agent&& from) noexcept
    : LoadSceneOutputEvent_Agent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent_Agent& operator=(const LoadSceneOutputEvent_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent_Agent& operator=(LoadSceneOutputEvent_Agent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadSceneOutputEvent_Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadSceneOutputEvent_Agent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent_Agent*>(
               &_LoadSceneOutputEvent_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(LoadSceneOutputEvent_Agent& a, LoadSceneOutputEvent_Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadSceneOutputEvent_Agent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadSceneOutputEvent_Agent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadSceneOutputEvent_Agent& from) {
    LoadSceneOutputEvent_Agent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadSceneOutputEvent_Agent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent.Agent";
  }
  protected:
  explicit LoadSceneOutputEvent_Agent(::google::protobuf_inworld::Arena* arena);
  LoadSceneOutputEvent_Agent(::google::protobuf_inworld::Arena* arena, const LoadSceneOutputEvent_Agent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // string brain_name = 2;
  void clear_brain_name() ;
  const std::string& brain_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brain_name(Arg_&& arg, Args_... args);
  std::string* mutable_brain_name();
  PROTOBUF_NODISCARD std::string* release_brain_name();
  void set_allocated_brain_name(std::string* value);

  private:
  const std::string& _internal_brain_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brain_name(
      const std::string& value);
  std::string* _internal_mutable_brain_name();

  public:
  // string given_name = 3;
  void clear_given_name() ;
  const std::string& given_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_given_name(Arg_&& arg, Args_... args);
  std::string* mutable_given_name();
  PROTOBUF_NODISCARD std::string* release_given_name();
  void set_allocated_given_name(std::string* value);

  private:
  const std::string& _internal_given_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_given_name(
      const std::string& value);
  std::string* _internal_mutable_given_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent.Agent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 3, 0,
      82, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr agent_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr brain_name_;
    ::google::protobuf_inworld::internal::ArenaStringPtr given_name_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadScene final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadScene) */ {
 public:
  inline LoadScene() : LoadScene(nullptr) {}
  ~LoadScene() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadScene(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadScene(const LoadScene& from)
      : LoadScene(nullptr, from) {}
  LoadScene(LoadScene&& from) noexcept
    : LoadScene() {
    *this = ::std::move(from);
  }

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScene& operator=(LoadScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadScene* internal_default_instance() {
    return reinterpret_cast<const LoadScene*>(
               &_LoadScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoadScene& a, LoadScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScene* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadScene* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadScene>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadScene& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadScene& from) {
    LoadScene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadScene* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadScene";
  }
  protected:
  explicit LoadScene(::google::protobuf_inworld::Arena* arena);
  LoadScene(::google::protobuf_inworld::Arena* arena, const LoadScene& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadScene)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr name_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadCharacters_CharacterName final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadCharacters.CharacterName) */ {
 public:
  inline LoadCharacters_CharacterName() : LoadCharacters_CharacterName(nullptr) {}
  ~LoadCharacters_CharacterName() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadCharacters_CharacterName(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadCharacters_CharacterName(const LoadCharacters_CharacterName& from)
      : LoadCharacters_CharacterName(nullptr, from) {}
  LoadCharacters_CharacterName(LoadCharacters_CharacterName&& from) noexcept
    : LoadCharacters_CharacterName() {
    *this = ::std::move(from);
  }

  inline LoadCharacters_CharacterName& operator=(const LoadCharacters_CharacterName& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCharacters_CharacterName& operator=(LoadCharacters_CharacterName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadCharacters_CharacterName& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadCharacters_CharacterName* internal_default_instance() {
    return reinterpret_cast<const LoadCharacters_CharacterName*>(
               &_LoadCharacters_CharacterName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoadCharacters_CharacterName& a, LoadCharacters_CharacterName& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCharacters_CharacterName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCharacters_CharacterName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadCharacters_CharacterName* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadCharacters_CharacterName>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadCharacters_CharacterName& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadCharacters_CharacterName& from) {
    LoadCharacters_CharacterName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadCharacters_CharacterName* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadCharacters.CharacterName";
  }
  protected:
  explicit LoadCharacters_CharacterName(::google::protobuf_inworld::Arena* arena);
  LoadCharacters_CharacterName(::google::protobuf_inworld::Arena* arena, const LoadCharacters_CharacterName& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLanguageCodeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .ai.inworld.language_codes.LanguageCode language_code = 2;
  void clear_language_code() ;
  ::ai::inworld::language_codes::LanguageCode language_code() const;
  void set_language_code(::ai::inworld::language_codes::LanguageCode value);

  private:
  ::ai::inworld::language_codes::LanguageCode _internal_language_code() const;
  void _internal_set_language_code(::ai::inworld::language_codes::LanguageCode value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadCharacters.CharacterName)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr name_;
    int language_code_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class EmotionEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.EmotionEvent) */ {
 public:
  inline EmotionEvent() : EmotionEvent(nullptr) {}
  ~EmotionEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmotionEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline EmotionEvent(const EmotionEvent& from)
      : EmotionEvent(nullptr, from) {}
  EmotionEvent(EmotionEvent&& from) noexcept
    : EmotionEvent() {
    *this = ::std::move(from);
  }

  inline EmotionEvent& operator=(const EmotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionEvent& operator=(EmotionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionEvent* internal_default_instance() {
    return reinterpret_cast<const EmotionEvent*>(
               &_EmotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EmotionEvent& a, EmotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmotionEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const EmotionEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const EmotionEvent& from) {
    EmotionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmotionEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.EmotionEvent";
  }
  protected:
  explicit EmotionEvent(::google::protobuf_inworld::Arena* arena);
  EmotionEvent(::google::protobuf_inworld::Arena* arena, const EmotionEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SpaffCode = EmotionEvent_SpaffCode;
  static constexpr SpaffCode NEUTRAL = EmotionEvent_SpaffCode_NEUTRAL;
  static constexpr SpaffCode DISGUST = EmotionEvent_SpaffCode_DISGUST;
  static constexpr SpaffCode CONTEMPT = EmotionEvent_SpaffCode_CONTEMPT;
  static constexpr SpaffCode BELLIGERENCE = EmotionEvent_SpaffCode_BELLIGERENCE;
  static constexpr SpaffCode DOMINEERING = EmotionEvent_SpaffCode_DOMINEERING;
  static constexpr SpaffCode CRITICISM = EmotionEvent_SpaffCode_CRITICISM;
  static constexpr SpaffCode ANGER = EmotionEvent_SpaffCode_ANGER;
  static constexpr SpaffCode TENSION = EmotionEvent_SpaffCode_TENSION;
  static constexpr SpaffCode TENSE_HUMOR = EmotionEvent_SpaffCode_TENSE_HUMOR;
  static constexpr SpaffCode DEFENSIVENESS = EmotionEvent_SpaffCode_DEFENSIVENESS;
  static constexpr SpaffCode WHINING = EmotionEvent_SpaffCode_WHINING;
  static constexpr SpaffCode SADNESS = EmotionEvent_SpaffCode_SADNESS;
  static constexpr SpaffCode STONEWALLING = EmotionEvent_SpaffCode_STONEWALLING;
  static constexpr SpaffCode INTEREST = EmotionEvent_SpaffCode_INTEREST;
  static constexpr SpaffCode VALIDATION = EmotionEvent_SpaffCode_VALIDATION;
  static constexpr SpaffCode AFFECTION = EmotionEvent_SpaffCode_AFFECTION;
  static constexpr SpaffCode HUMOR = EmotionEvent_SpaffCode_HUMOR;
  static constexpr SpaffCode SURPRISE = EmotionEvent_SpaffCode_SURPRISE;
  static constexpr SpaffCode JOY = EmotionEvent_SpaffCode_JOY;
  static inline bool SpaffCode_IsValid(int value) {
    return EmotionEvent_SpaffCode_IsValid(value);
  }
  static constexpr SpaffCode SpaffCode_MIN = EmotionEvent_SpaffCode_SpaffCode_MIN;
  static constexpr SpaffCode SpaffCode_MAX = EmotionEvent_SpaffCode_SpaffCode_MAX;
  static constexpr int SpaffCode_ARRAYSIZE = EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* SpaffCode_descriptor() {
    return EmotionEvent_SpaffCode_descriptor();
  }
  template <typename T>
  static inline const std::string& SpaffCode_Name(T value) {
    return EmotionEvent_SpaffCode_Name(value);
  }
  static inline bool SpaffCode_Parse(absl::string_view name, SpaffCode* value) {
    return EmotionEvent_SpaffCode_Parse(name, value);
  }

  using Strength = EmotionEvent_Strength;
  static constexpr Strength UNSPECIFIED = EmotionEvent_Strength_UNSPECIFIED;
  static constexpr Strength WEAK = EmotionEvent_Strength_WEAK;
  static constexpr Strength STRONG = EmotionEvent_Strength_STRONG;
  static constexpr Strength NORMAL = EmotionEvent_Strength_NORMAL;
  static inline bool Strength_IsValid(int value) {
    return EmotionEvent_Strength_IsValid(value);
  }
  static constexpr Strength Strength_MIN = EmotionEvent_Strength_Strength_MIN;
  static constexpr Strength Strength_MAX = EmotionEvent_Strength_Strength_MAX;
  static constexpr int Strength_ARRAYSIZE = EmotionEvent_Strength_Strength_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* Strength_descriptor() {
    return EmotionEvent_Strength_descriptor();
  }
  template <typename T>
  static inline const std::string& Strength_Name(T value) {
    return EmotionEvent_Strength_Name(value);
  }
  static inline bool Strength_Parse(absl::string_view name, Strength* value) {
    return EmotionEvent_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJoyFieldNumber = 1,
    kFearFieldNumber = 2,
    kTrustFieldNumber = 3,
    kSurpriseFieldNumber = 4,
    kBehaviorFieldNumber = 5,
    kStrengthFieldNumber = 6,
  };
  // float joy = 1;
  void clear_joy() ;
  float joy() const;
  void set_joy(float value);

  private:
  float _internal_joy() const;
  void _internal_set_joy(float value);

  public:
  // float fear = 2;
  void clear_fear() ;
  float fear() const;
  void set_fear(float value);

  private:
  float _internal_fear() const;
  void _internal_set_fear(float value);

  public:
  // float trust = 3;
  void clear_trust() ;
  float trust() const;
  void set_trust(float value);

  private:
  float _internal_trust() const;
  void _internal_set_trust(float value);

  public:
  // float surprise = 4;
  void clear_surprise() ;
  float surprise() const;
  void set_surprise(float value);

  private:
  float _internal_surprise() const;
  void _internal_set_surprise(float value);

  public:
  // .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
  void clear_behavior() ;
  ::ai::inworld::packets::EmotionEvent_SpaffCode behavior() const;
  void set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);

  private:
  ::ai::inworld::packets::EmotionEvent_SpaffCode _internal_behavior() const;
  void _internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);

  public:
  // .ai.inworld.packets.EmotionEvent.Strength strength = 6;
  void clear_strength() ;
  ::ai::inworld::packets::EmotionEvent_Strength strength() const;
  void set_strength(::ai::inworld::packets::EmotionEvent_Strength value);

  private:
  ::ai::inworld::packets::EmotionEvent_Strength _internal_strength() const;
  void _internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.EmotionEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    float joy_;
    float fear_;
    float trust_;
    float surprise_;
    int behavior_;
    int strength_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class CustomEvent_Parameter final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent.Parameter) */ {
 public:
  inline CustomEvent_Parameter() : CustomEvent_Parameter(nullptr) {}
  ~CustomEvent_Parameter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomEvent_Parameter(::google::protobuf_inworld::internal::ConstantInitialized);

  inline CustomEvent_Parameter(const CustomEvent_Parameter& from)
      : CustomEvent_Parameter(nullptr, from) {}
  CustomEvent_Parameter(CustomEvent_Parameter&& from) noexcept
    : CustomEvent_Parameter() {
    *this = ::std::move(from);
  }

  inline CustomEvent_Parameter& operator=(const CustomEvent_Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent_Parameter& operator=(CustomEvent_Parameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent_Parameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent_Parameter* internal_default_instance() {
    return reinterpret_cast<const CustomEvent_Parameter*>(
               &_CustomEvent_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CustomEvent_Parameter& a, CustomEvent_Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent_Parameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent_Parameter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent_Parameter* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const CustomEvent_Parameter& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const CustomEvent_Parameter& from) {
    CustomEvent_Parameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomEvent_Parameter* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.CustomEvent.Parameter";
  }
  protected:
  explicit CustomEvent_Parameter(::google::protobuf_inworld::Arena* arena);
  CustomEvent_Parameter(::google::protobuf_inworld::Arena* arena, const CustomEvent_Parameter& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent.Parameter)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr name_;
    ::google::protobuf_inworld::internal::ArenaStringPtr value_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class CancelResponsesEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponsesEvent) */ {
 public:
  inline CancelResponsesEvent() : CancelResponsesEvent(nullptr) {}
  ~CancelResponsesEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CancelResponsesEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline CancelResponsesEvent(const CancelResponsesEvent& from)
      : CancelResponsesEvent(nullptr, from) {}
  CancelResponsesEvent(CancelResponsesEvent&& from) noexcept
    : CancelResponsesEvent() {
    *this = ::std::move(from);
  }

  inline CancelResponsesEvent& operator=(const CancelResponsesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponsesEvent& operator=(CancelResponsesEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponsesEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponsesEvent* internal_default_instance() {
    return reinterpret_cast<const CancelResponsesEvent*>(
               &_CancelResponsesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CancelResponsesEvent& a, CancelResponsesEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponsesEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponsesEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponsesEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponsesEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const CancelResponsesEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const CancelResponsesEvent& from) {
    CancelResponsesEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelResponsesEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.CancelResponsesEvent";
  }
  protected:
  explicit CancelResponsesEvent(::google::protobuf_inworld::Arena* arena);
  CancelResponsesEvent(::google::protobuf_inworld::Arena* arena, const CancelResponsesEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;

  public:
  void clear_utterance_id() ;
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, std::size_t size);
  void set_utterance_id(int index, absl::string_view value);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, std::size_t size);
  void add_utterance_id(absl::string_view value);
  const ::google::protobuf_inworld::RepeatedPtrField<std::string>& utterance_id() const;
  ::google::protobuf_inworld::RepeatedPtrField<std::string>* mutable_utterance_id();

  private:
  const ::google::protobuf_inworld::RepeatedPtrField<std::string>& _internal_utterance_id() const;
  ::google::protobuf_inworld::RepeatedPtrField<std::string>* _internal_mutable_utterance_id();

  public:
  // string interaction_id = 1;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponsesEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField<std::string> utterance_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr interaction_id_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class CancelResponses final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponses) */ {
 public:
  inline CancelResponses() : CancelResponses(nullptr) {}
  ~CancelResponses() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CancelResponses(::google::protobuf_inworld::internal::ConstantInitialized);

  inline CancelResponses(const CancelResponses& from)
      : CancelResponses(nullptr, from) {}
  CancelResponses(CancelResponses&& from) noexcept
    : CancelResponses() {
    *this = ::std::move(from);
  }

  inline CancelResponses& operator=(const CancelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponses& operator=(CancelResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponses* internal_default_instance() {
    return reinterpret_cast<const CancelResponses*>(
               &_CancelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CancelResponses& a, CancelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponses* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponses* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponses>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const CancelResponses& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const CancelResponses& from) {
    CancelResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelResponses* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.CancelResponses";
  }
  protected:
  explicit CancelResponses(::google::protobuf_inworld::Arena* arena);
  CancelResponses(::google::protobuf_inworld::Arena* arena, const CancelResponses& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;

  public:
  void clear_utterance_id() ;
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, std::size_t size);
  void set_utterance_id(int index, absl::string_view value);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, std::size_t size);
  void add_utterance_id(absl::string_view value);
  const ::google::protobuf_inworld::RepeatedPtrField<std::string>& utterance_id() const;
  ::google::protobuf_inworld::RepeatedPtrField<std::string>* mutable_utterance_id();

  private:
  const ::google::protobuf_inworld::RepeatedPtrField<std::string>& _internal_utterance_id() const;
  ::google::protobuf_inworld::RepeatedPtrField<std::string>* _internal_mutable_utterance_id();

  public:
  // string interaction_id = 1;
  void clear_interaction_id() ;
  const std::string& interaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* value);

  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(
      const std::string& value);
  std::string* _internal_mutable_interaction_id();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponses)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField<std::string> utterance_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr interaction_id_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class AudioChunk final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  ~AudioChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioChunk(::google::protobuf_inworld::internal::ConstantInitialized);

  inline AudioChunk(const AudioChunk& from)
      : AudioChunk(nullptr, from) {}
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioChunk* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const AudioChunk& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const AudioChunk& from) {
    AudioChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioChunk* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.AudioChunk";
  }
  protected:
  explicit AudioChunk(::google::protobuf_inworld::Arena* arena);
  AudioChunk(::google::protobuf_inworld::Arena* arena, const AudioChunk& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk() ;
  const std::string& chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* value);

  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(
      const std::string& value);
  std::string* _internal_mutable_chunk();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AudioChunk)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr chunk_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Agent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Agent) */ {
 public:
  inline Agent() : Agent(nullptr) {}
  ~Agent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Agent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Agent(const Agent& from)
      : Agent(nullptr, from) {}
  Agent(Agent&& from) noexcept
    : Agent() {
    *this = ::std::move(from);
  }

  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent& operator=(Agent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
               &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Agent& a, Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(Agent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Agent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Agent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Agent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Agent& from) {
    Agent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Agent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Agent";
  }
  protected:
  explicit Agent(::google::protobuf_inworld::Arena* arena);
  Agent(::google::protobuf_inworld::Arena* arena, const Agent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id() ;
  const std::string& agent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agent_id(Arg_&& arg, Args_... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* value);

  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(
      const std::string& value);
  std::string* _internal_mutable_agent_id();

  public:
  // string brain_name = 2;
  void clear_brain_name() ;
  const std::string& brain_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brain_name(Arg_&& arg, Args_... args);
  std::string* mutable_brain_name();
  PROTOBUF_NODISCARD std::string* release_brain_name();
  void set_allocated_brain_name(std::string* value);

  private:
  const std::string& _internal_brain_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brain_name(
      const std::string& value);
  std::string* _internal_mutable_brain_name();

  public:
  // string given_name = 3;
  void clear_given_name() ;
  const std::string& given_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_given_name(Arg_&& arg, Args_... args);
  std::string* mutable_given_name();
  PROTOBUF_NODISCARD std::string* release_given_name();
  void set_allocated_given_name(std::string* value);

  private:
  const std::string& _internal_given_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_given_name(
      const std::string& value);
  std::string* _internal_mutable_given_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Agent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 3, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr agent_id_;
    ::google::protobuf_inworld::internal::ArenaStringPtr brain_name_;
    ::google::protobuf_inworld::internal::ArenaStringPtr given_name_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Actor final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Actor) */ {
 public:
  inline Actor() : Actor(nullptr) {}
  ~Actor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Actor(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Actor(const Actor& from)
      : Actor(nullptr, from) {}
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actor& operator=(Actor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Actor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }
  inline void Swap(Actor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Actor* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Actor& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Actor& from) {
    Actor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Actor* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Actor";
  }
  protected:
  explicit Actor(::google::protobuf_inworld::Arena* arena);
  Actor(::google::protobuf_inworld::Arena* arena, const Actor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Actor_Type;
  static constexpr Type UNKNOWN = Actor_Type_UNKNOWN;
  static constexpr Type PLAYER = Actor_Type_PLAYER;
  static constexpr Type AGENT = Actor_Type_AGENT;
  static constexpr Type WORLD = Actor_Type_WORLD;
  static inline bool Type_IsValid(int value) {
    return Actor_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Actor_Type_Type_MIN;
  static constexpr Type Type_MAX = Actor_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Actor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* Type_descriptor() {
    return Actor_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Actor_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Actor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .ai.inworld.packets.Actor.Type type = 1;
  void clear_type() ;
  ::ai::inworld::packets::Actor_Type type() const;
  void set_type(::ai::inworld::packets::Actor_Type value);

  private:
  ::ai::inworld::packets::Actor_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::Actor_Type value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Actor)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::ArenaStringPtr name_;
    int type_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class UnloadCharacters final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.UnloadCharacters) */ {
 public:
  inline UnloadCharacters() : UnloadCharacters(nullptr) {}
  ~UnloadCharacters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnloadCharacters(::google::protobuf_inworld::internal::ConstantInitialized);

  inline UnloadCharacters(const UnloadCharacters& from)
      : UnloadCharacters(nullptr, from) {}
  UnloadCharacters(UnloadCharacters&& from) noexcept
    : UnloadCharacters() {
    *this = ::std::move(from);
  }

  inline UnloadCharacters& operator=(const UnloadCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadCharacters& operator=(UnloadCharacters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnloadCharacters& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnloadCharacters* internal_default_instance() {
    return reinterpret_cast<const UnloadCharacters*>(
               &_UnloadCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UnloadCharacters& a, UnloadCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloadCharacters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadCharacters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnloadCharacters* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnloadCharacters>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const UnloadCharacters& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const UnloadCharacters& from) {
    UnloadCharacters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnloadCharacters* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.UnloadCharacters";
  }
  protected:
  explicit UnloadCharacters(::google::protobuf_inworld::Arena* arena);
  UnloadCharacters(::google::protobuf_inworld::Arena* arena, const UnloadCharacters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& _internal_agents() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* _internal_mutable_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.UnloadCharacters)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class TextEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  ~TextEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TextEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline TextEvent(const TextEvent& from)
      : TextEvent(nullptr, from) {}
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const TextEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const TextEvent& from) {
    TextEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(TextEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.TextEvent";
  }
  protected:
  explicit TextEvent(::google::protobuf_inworld::Arena* arena);
  TextEvent(::google::protobuf_inworld::Arena* arena, const TextEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ModelInfo = TextEvent_ModelInfo;

  using SourceType = TextEvent_SourceType;
  static constexpr SourceType UNKNOWN = TextEvent_SourceType_UNKNOWN;
  static constexpr SourceType SPEECH_TO_TEXT = TextEvent_SourceType_SPEECH_TO_TEXT;
  static constexpr SourceType TYPED_IN = TextEvent_SourceType_TYPED_IN;
  static constexpr SourceType GENERATED = TextEvent_SourceType_GENERATED;
  static constexpr SourceType FILLER = TextEvent_SourceType_FILLER;
  static inline bool SourceType_IsValid(int value) {
    return TextEvent_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN = TextEvent_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX = TextEvent_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE = TextEvent_SourceType_SourceType_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* SourceType_descriptor() {
    return TextEvent_SourceType_descriptor();
  }
  template <typename T>
  static inline const std::string& SourceType_Name(T value) {
    return TextEvent_SourceType_Name(value);
  }
  static inline bool SourceType_Parse(absl::string_view name, SourceType* value) {
    return TextEvent_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelInfoFieldNumber = 4,
    kSourceTypeFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
  bool has_model_info() const;
  void clear_model_info() ;
  const ::ai::inworld::packets::TextEvent_ModelInfo& model_info() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::TextEvent_ModelInfo* release_model_info();
  ::ai::inworld::packets::TextEvent_ModelInfo* mutable_model_info();
  void set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* value);
  void unsafe_arena_set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* value);
  ::ai::inworld::packets::TextEvent_ModelInfo* unsafe_arena_release_model_info();

  private:
  const ::ai::inworld::packets::TextEvent_ModelInfo& _internal_model_info() const;
  ::ai::inworld::packets::TextEvent_ModelInfo* _internal_mutable_model_info();

  public:
  // .ai.inworld.packets.TextEvent.SourceType source_type = 2;
  void clear_source_type() ;
  ::ai::inworld::packets::TextEvent_SourceType source_type() const;
  void set_source_type(::ai::inworld::packets::TextEvent_SourceType value);

  private:
  ::ai::inworld::packets::TextEvent_SourceType _internal_source_type() const;
  void _internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value);

  public:
  // bool final = 3;
  void clear_final() ;
  bool final() const;
  void set_final(bool value);

  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 4, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::internal::ArenaStringPtr text_;
    ::ai::inworld::packets::TextEvent_ModelInfo* model_info_;
    int source_type_;
    bool final_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Routing final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Routing(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Routing(const Routing& from)
      : Routing(nullptr, from) {}
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Routing& from) {
    Routing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Routing* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Routing";
  }
  protected:
  explicit Routing(::google::protobuf_inworld::Arena* arena);
  Routing(::google::protobuf_inworld::Arena* arena, const Routing& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 3,
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.Actor targets = 3;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::ai::inworld::packets::Actor* mutable_targets(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Actor >*
      mutable_targets();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>& _internal_targets() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>* _internal_mutable_targets();
  public:
  const ::ai::inworld::packets::Actor& targets(int index) const;
  ::ai::inworld::packets::Actor* add_targets();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Actor >&
      targets() const;
  // .ai.inworld.packets.Actor source = 1;
  bool has_source() const;
  void clear_source() ;
  const ::ai::inworld::packets::Actor& source() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_source();
  ::ai::inworld::packets::Actor* mutable_source();
  void set_allocated_source(::ai::inworld::packets::Actor* value);
  void unsafe_arena_set_allocated_source(::ai::inworld::packets::Actor* value);
  ::ai::inworld::packets::Actor* unsafe_arena_release_source();

  private:
  const ::ai::inworld::packets::Actor& _internal_source() const;
  ::ai::inworld::packets::Actor* _internal_mutable_source();

  public:
  // .ai.inworld.packets.Actor target = 2;
  bool has_target() const;
  void clear_target() ;
  const ::ai::inworld::packets::Actor& target() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_target();
  ::ai::inworld::packets::Actor* mutable_target();
  void set_allocated_target(::ai::inworld::packets::Actor* value);
  void unsafe_arena_set_allocated_target(::ai::inworld::packets::Actor* value);
  ::ai::inworld::packets::Actor* unsafe_arena_release_target();

  private:
  const ::ai::inworld::packets::Actor& _internal_target() const;
  ::ai::inworld::packets::Actor* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Routing)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Actor > targets_;
    ::ai::inworld::packets::Actor* source_;
    ::ai::inworld::packets::Actor* target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Relations final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Relations) */ {
 public:
  inline Relations() : Relations(nullptr) {}
  ~Relations() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Relations(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Relations(const Relations& from)
      : Relations(nullptr, from) {}
  Relations(Relations&& from) noexcept
    : Relations() {
    *this = ::std::move(from);
  }

  inline Relations& operator=(const Relations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relations& operator=(Relations&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relations* internal_default_instance() {
    return reinterpret_cast<const Relations*>(
               &_Relations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Relations& a, Relations& b) {
    a.Swap(&b);
  }
  inline void Swap(Relations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relations* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relations* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relations>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Relations& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Relations& from) {
    Relations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Relations* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Relations";
  }
  protected:
  explicit Relations(::google::protobuf_inworld::Arena* arena);
  Relations(::google::protobuf_inworld::Arena* arena, const Relations& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Relation = Relations_Relation;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationsFieldNumber = 2,
    kActorFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Relations.Relation relations = 2;
  int relations_size() const;
  private:
  int _internal_relations_size() const;

  public:
  void clear_relations() ;
  ::ai::inworld::packets::Relations_Relation* mutable_relations(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >*
      mutable_relations();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>& _internal_relations() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>* _internal_mutable_relations();
  public:
  const ::ai::inworld::packets::Relations_Relation& relations(int index) const;
  ::ai::inworld::packets::Relations_Relation* add_relations();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >&
      relations() const;
  // .ai.inworld.packets.Actor actor = 1;
  bool has_actor() const;
  void clear_actor() ;
  const ::ai::inworld::packets::Actor& actor() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_actor();
  ::ai::inworld::packets::Actor* mutable_actor();
  void set_allocated_actor(::ai::inworld::packets::Actor* value);
  void unsafe_arena_set_allocated_actor(::ai::inworld::packets::Actor* value);
  ::ai::inworld::packets::Actor* unsafe_arena_release_actor();

  private:
  const ::ai::inworld::packets::Actor& _internal_actor() const;
  ::ai::inworld::packets::Actor* _internal_mutable_actor();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Relations)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation > relations_;
    ::ai::inworld::packets::Actor* actor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class RelationInfo final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo) */ {
 public:
  inline RelationInfo() : RelationInfo(nullptr) {}
  ~RelationInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelationInfo(::google::protobuf_inworld::internal::ConstantInitialized);

  inline RelationInfo(const RelationInfo& from)
      : RelationInfo(nullptr, from) {}
  RelationInfo(RelationInfo&& from) noexcept
    : RelationInfo() {
    *this = ::std::move(from);
  }

  inline RelationInfo& operator=(const RelationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo& operator=(RelationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationInfo* internal_default_instance() {
    return reinterpret_cast<const RelationInfo*>(
               &_RelationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RelationInfo& a, RelationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationInfo* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationInfo>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const RelationInfo& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const RelationInfo& from) {
    RelationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(RelationInfo* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.RelationInfo";
  }
  protected:
  explicit RelationInfo(::google::protobuf_inworld::Arena* arena);
  RelationInfo(::google::protobuf_inworld::Arena* arena, const RelationInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RelationAttributes = RelationInfo_RelationAttributes;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationStateFieldNumber = 1,
    kRelationUpdateFieldNumber = 2,
  };
  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
  bool has_relation_state() const;
  void clear_relation_state() ;
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_state() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_state();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_state();
  void set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* value);
  void unsafe_arena_set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* value);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_state();

  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_state();

  public:
  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
  bool has_relation_update() const;
  void clear_relation_update() ;
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_update() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_update();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_update();
  void set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* value);
  void unsafe_arena_set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* value);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_update();

  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_update();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state_;
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadedScene final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadedScene) */ {
 public:
  inline LoadedScene() : LoadedScene(nullptr) {}
  ~LoadedScene() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadedScene(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadedScene(const LoadedScene& from)
      : LoadedScene(nullptr, from) {}
  LoadedScene(LoadedScene&& from) noexcept
    : LoadedScene() {
    *this = ::std::move(from);
  }

  inline LoadedScene& operator=(const LoadedScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadedScene& operator=(LoadedScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadedScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadedScene* internal_default_instance() {
    return reinterpret_cast<const LoadedScene*>(
               &_LoadedScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoadedScene& a, LoadedScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadedScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadedScene* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadedScene* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadedScene>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadedScene& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadedScene& from) {
    LoadedScene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadedScene* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadedScene";
  }
  protected:
  explicit LoadedScene(::google::protobuf_inworld::Arena* arena);
  LoadedScene(::google::protobuf_inworld::Arena* arena, const LoadedScene& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& _internal_agents() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* _internal_mutable_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadedScene)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadedCharacters final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadedCharacters) */ {
 public:
  inline LoadedCharacters() : LoadedCharacters(nullptr) {}
  ~LoadedCharacters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadedCharacters(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadedCharacters(const LoadedCharacters& from)
      : LoadedCharacters(nullptr, from) {}
  LoadedCharacters(LoadedCharacters&& from) noexcept
    : LoadedCharacters() {
    *this = ::std::move(from);
  }

  inline LoadedCharacters& operator=(const LoadedCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadedCharacters& operator=(LoadedCharacters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadedCharacters& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadedCharacters* internal_default_instance() {
    return reinterpret_cast<const LoadedCharacters*>(
               &_LoadedCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LoadedCharacters& a, LoadedCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadedCharacters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadedCharacters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadedCharacters* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadedCharacters>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadedCharacters& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadedCharacters& from) {
    LoadedCharacters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadedCharacters* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadedCharacters";
  }
  protected:
  explicit LoadedCharacters(::google::protobuf_inworld::Arena* arena);
  LoadedCharacters(::google::protobuf_inworld::Arena* arena, const LoadedCharacters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& _internal_agents() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* _internal_mutable_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadedCharacters)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadSceneOutputEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent) */ {
 public:
  inline LoadSceneOutputEvent() : LoadSceneOutputEvent(nullptr) {}
  ~LoadSceneOutputEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadSceneOutputEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadSceneOutputEvent(const LoadSceneOutputEvent& from)
      : LoadSceneOutputEvent(nullptr, from) {}
  LoadSceneOutputEvent(LoadSceneOutputEvent&& from) noexcept
    : LoadSceneOutputEvent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent& operator=(const LoadSceneOutputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent& operator=(LoadSceneOutputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadSceneOutputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadSceneOutputEvent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent*>(
               &_LoadSceneOutputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LoadSceneOutputEvent& a, LoadSceneOutputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadSceneOutputEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadSceneOutputEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadSceneOutputEvent& from) {
    LoadSceneOutputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadSceneOutputEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent";
  }
  protected:
  explicit LoadSceneOutputEvent(::google::protobuf_inworld::Arena* arena);
  LoadSceneOutputEvent(::google::protobuf_inworld::Arena* arena, const LoadSceneOutputEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Agent = LoadSceneOutputEvent_Agent;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;

  public:
  void clear_agents() ;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* mutable_agents(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
      mutable_agents();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>& _internal_agents() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>* _internal_mutable_agents();
  public:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* add_agents();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
      agents() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent > agents_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class LoadCharacters final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadCharacters) */ {
 public:
  inline LoadCharacters() : LoadCharacters(nullptr) {}
  ~LoadCharacters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadCharacters(::google::protobuf_inworld::internal::ConstantInitialized);

  inline LoadCharacters(const LoadCharacters& from)
      : LoadCharacters(nullptr, from) {}
  LoadCharacters(LoadCharacters&& from) noexcept
    : LoadCharacters() {
    *this = ::std::move(from);
  }

  inline LoadCharacters& operator=(const LoadCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCharacters& operator=(LoadCharacters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadCharacters& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadCharacters* internal_default_instance() {
    return reinterpret_cast<const LoadCharacters*>(
               &_LoadCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LoadCharacters& a, LoadCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCharacters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCharacters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadCharacters* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadCharacters>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const LoadCharacters& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const LoadCharacters& from) {
    LoadCharacters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadCharacters* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.LoadCharacters";
  }
  protected:
  explicit LoadCharacters(::google::protobuf_inworld::Arena* arena);
  LoadCharacters(::google::protobuf_inworld::Arena* arena, const LoadCharacters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CharacterName = LoadCharacters_CharacterName;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadCharacters.CharacterName name = 1;
  int name_size() const;
  private:
  int _internal_name_size() const;

  public:
  void clear_name() ;
  ::ai::inworld::packets::LoadCharacters_CharacterName* mutable_name(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >*
      mutable_name();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>& _internal_name() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>* _internal_mutable_name();
  public:
  const ::ai::inworld::packets::LoadCharacters_CharacterName& name(int index) const;
  ::ai::inworld::packets::LoadCharacters_CharacterName* add_name();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >&
      name() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadCharacters)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName > name_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class DialogHistory_HistoryItem final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DialogHistory.HistoryItem) */ {
 public:
  inline DialogHistory_HistoryItem() : DialogHistory_HistoryItem(nullptr) {}
  ~DialogHistory_HistoryItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DialogHistory_HistoryItem(::google::protobuf_inworld::internal::ConstantInitialized);

  inline DialogHistory_HistoryItem(const DialogHistory_HistoryItem& from)
      : DialogHistory_HistoryItem(nullptr, from) {}
  DialogHistory_HistoryItem(DialogHistory_HistoryItem&& from) noexcept
    : DialogHistory_HistoryItem() {
    *this = ::std::move(from);
  }

  inline DialogHistory_HistoryItem& operator=(const DialogHistory_HistoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DialogHistory_HistoryItem& operator=(DialogHistory_HistoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DialogHistory_HistoryItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const DialogHistory_HistoryItem* internal_default_instance() {
    return reinterpret_cast<const DialogHistory_HistoryItem*>(
               &_DialogHistory_HistoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DialogHistory_HistoryItem& a, DialogHistory_HistoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(DialogHistory_HistoryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DialogHistory_HistoryItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DialogHistory_HistoryItem* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DialogHistory_HistoryItem>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const DialogHistory_HistoryItem& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const DialogHistory_HistoryItem& from) {
    DialogHistory_HistoryItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(DialogHistory_HistoryItem* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.DialogHistory.HistoryItem";
  }
  protected:
  explicit DialogHistory_HistoryItem(::google::protobuf_inworld::Arena* arena);
  DialogHistory_HistoryItem(::google::protobuf_inworld::Arena* arena, const DialogHistory_HistoryItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kActorFieldNumber = 1,
  };
  // string text = 2;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .ai.inworld.packets.Actor actor = 1;
  bool has_actor() const;
  void clear_actor() ;
  const ::ai::inworld::packets::Actor& actor() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_actor();
  ::ai::inworld::packets::Actor* mutable_actor();
  void set_allocated_actor(::ai::inworld::packets::Actor* value);
  void unsafe_arena_set_allocated_actor(::ai::inworld::packets::Actor* value);
  ::ai::inworld::packets::Actor* unsafe_arena_release_actor();

  private:
  const ::ai::inworld::packets::Actor& _internal_actor() const;
  ::ai::inworld::packets::Actor* _internal_mutable_actor();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DialogHistory.HistoryItem)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::internal::ArenaStringPtr text_;
    ::ai::inworld::packets::Actor* actor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class CustomEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  ~CustomEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CustomEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline CustomEvent(const CustomEvent& from)
      : CustomEvent(nullptr, from) {}
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const CustomEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const CustomEvent& from) {
    CustomEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(CustomEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.CustomEvent";
  }
  protected:
  explicit CustomEvent(::google::protobuf_inworld::Arena* arena);
  CustomEvent(::google::protobuf_inworld::Arena* arena, const CustomEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Parameter = CustomEvent_Parameter;

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kNameFieldNumber = 1,
    kPlaybackFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  ::ai::inworld::packets::CustomEvent_Parameter* mutable_parameters(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
      mutable_parameters();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>& _internal_parameters() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>* _internal_mutable_parameters();
  public:
  const ::ai::inworld::packets::CustomEvent_Parameter& parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* add_parameters();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
      parameters() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback() ;
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);

  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 3, 1,
      43, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter > parameters_;
    ::google::protobuf_inworld::internal::ArenaStringPtr name_;
    int playback_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class ControlEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ControlEvent) */ {
 public:
  inline ControlEvent() : ControlEvent(nullptr) {}
  ~ControlEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline ControlEvent(const ControlEvent& from)
      : ControlEvent(nullptr, from) {}
  ControlEvent(ControlEvent&& from) noexcept
    : ControlEvent() {
    *this = ::std::move(from);
  }

  inline ControlEvent& operator=(const ControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlEvent& operator=(ControlEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlEvent* internal_default_instance() {
    return reinterpret_cast<const ControlEvent*>(
               &_ControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlEvent& a, ControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const ControlEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const ControlEvent& from) {
    ControlEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControlEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.ControlEvent";
  }
  protected:
  explicit ControlEvent(::google::protobuf_inworld::Arena* arena);
  ControlEvent(::google::protobuf_inworld::Arena* arena, const ControlEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Action = ControlEvent_Action;
  static constexpr Action UNKNOWN = ControlEvent_Action_UNKNOWN;
  static constexpr Action AUDIO_SESSION_START = ControlEvent_Action_AUDIO_SESSION_START;
  static constexpr Action AUDIO_SESSION_END = ControlEvent_Action_AUDIO_SESSION_END;
  static constexpr Action INTERACTION_END = ControlEvent_Action_INTERACTION_END;
  static constexpr Action TTS_PLAYBACK_START = ControlEvent_Action_TTS_PLAYBACK_START;
  static constexpr Action TTS_PLAYBACK_END = ControlEvent_Action_TTS_PLAYBACK_END;
  static constexpr Action TTS_PLAYBACK_MUTE = ControlEvent_Action_TTS_PLAYBACK_MUTE;
  static constexpr Action TTS_PLAYBACK_UNMUTE = ControlEvent_Action_TTS_PLAYBACK_UNMUTE;
  static constexpr Action WARNING = ControlEvent_Action_WARNING;
  static constexpr Action SESSION_END = ControlEvent_Action_SESSION_END;
  static constexpr Action CONVERSATION_START = ControlEvent_Action_CONVERSATION_START;
  static constexpr Action CONVERSATION_UPDATE = ControlEvent_Action_CONVERSATION_UPDATE;
  static constexpr Action CONVERSATION_STARTED = ControlEvent_Action_CONVERSATION_STARTED;
  static inline bool Action_IsValid(int value) {
    return ControlEvent_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = ControlEvent_Action_Action_MIN;
  static constexpr Action Action_MAX = ControlEvent_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = ControlEvent_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* Action_descriptor() {
    return ControlEvent_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return ControlEvent_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return ControlEvent_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .google.protobuf.Struct payload = 3;
  bool has_payload() const;
  void clear_payload() ;
  const ::google::protobuf_inworld::Struct& payload() const;
  PROTOBUF_NODISCARD ::google::protobuf_inworld::Struct* release_payload();
  ::google::protobuf_inworld::Struct* mutable_payload();
  void set_allocated_payload(::google::protobuf_inworld::Struct* value);
  void unsafe_arena_set_allocated_payload(::google::protobuf_inworld::Struct* value);
  ::google::protobuf_inworld::Struct* unsafe_arena_release_payload();

  private:
  const ::google::protobuf_inworld::Struct& _internal_payload() const;
  ::google::protobuf_inworld::Struct* _internal_mutable_payload();

  public:
  // .ai.inworld.packets.ControlEvent.Action action = 1;
  void clear_action() ;
  ::ai::inworld::packets::ControlEvent_Action action() const;
  void set_action(::ai::inworld::packets::ControlEvent_Action value);

  private:
  ::ai::inworld::packets::ControlEvent_Action _internal_action() const;
  void _internal_set_action(::ai::inworld::packets::ControlEvent_Action value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ControlEvent)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 3, 1,
      51, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::internal::ArenaStringPtr description_;
    ::google::protobuf_inworld::Struct* payload_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Continuation_ContinuationInfo final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Continuation.ContinuationInfo) */ {
 public:
  inline Continuation_ContinuationInfo() : Continuation_ContinuationInfo(nullptr) {}
  ~Continuation_ContinuationInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Continuation_ContinuationInfo(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Continuation_ContinuationInfo(const Continuation_ContinuationInfo& from)
      : Continuation_ContinuationInfo(nullptr, from) {}
  Continuation_ContinuationInfo(Continuation_ContinuationInfo&& from) noexcept
    : Continuation_ContinuationInfo() {
    *this = ::std::move(from);
  }

  inline Continuation_ContinuationInfo& operator=(const Continuation_ContinuationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Continuation_ContinuationInfo& operator=(Continuation_ContinuationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Continuation_ContinuationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Continuation_ContinuationInfo* internal_default_instance() {
    return reinterpret_cast<const Continuation_ContinuationInfo*>(
               &_Continuation_ContinuationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Continuation_ContinuationInfo& a, Continuation_ContinuationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Continuation_ContinuationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Continuation_ContinuationInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Continuation_ContinuationInfo* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Continuation_ContinuationInfo>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Continuation_ContinuationInfo& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Continuation_ContinuationInfo& from) {
    Continuation_ContinuationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Continuation_ContinuationInfo* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Continuation.ContinuationInfo";
  }
  protected:
  explicit Continuation_ContinuationInfo(::google::protobuf_inworld::Arena* arena);
  Continuation_ContinuationInfo(::google::protobuf_inworld::Arena* arena, const Continuation_ContinuationInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassedTimeFieldNumber = 1,
  };
  // .google.protobuf.Timestamp passed_time = 1;
  bool has_passed_time() const;
  void clear_passed_time() ;
  const ::google::protobuf_inworld::Timestamp& passed_time() const;
  PROTOBUF_NODISCARD ::google::protobuf_inworld::Timestamp* release_passed_time();
  ::google::protobuf_inworld::Timestamp* mutable_passed_time();
  void set_allocated_passed_time(::google::protobuf_inworld::Timestamp* value);
  void unsafe_arena_set_allocated_passed_time(::google::protobuf_inworld::Timestamp* value);
  ::google::protobuf_inworld::Timestamp* unsafe_arena_release_passed_time();

  private:
  const ::google::protobuf_inworld::Timestamp& _internal_passed_time() const;
  ::google::protobuf_inworld::Timestamp* _internal_mutable_passed_time();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Continuation.ContinuationInfo)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::Timestamp* passed_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class ApplyResponse final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ApplyResponse) */ {
 public:
  inline ApplyResponse() : ApplyResponse(nullptr) {}
  ~ApplyResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ApplyResponse(::google::protobuf_inworld::internal::ConstantInitialized);

  inline ApplyResponse(const ApplyResponse& from)
      : ApplyResponse(nullptr, from) {}
  ApplyResponse(ApplyResponse&& from) noexcept
    : ApplyResponse() {
    *this = ::std::move(from);
  }

  inline ApplyResponse& operator=(const ApplyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyResponse& operator=(ApplyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyResponse*>(
               &_ApplyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ApplyResponse& a, ApplyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyResponse* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyResponse>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const ApplyResponse& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const ApplyResponse& from) {
    ApplyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApplyResponse* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.ApplyResponse";
  }
  protected:
  explicit ApplyResponse(::google::protobuf_inworld::Arena* arena);
  ApplyResponse(::google::protobuf_inworld::Arena* arena, const ApplyResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
  };
  // .ai.inworld.packets.PacketId packet_id = 1;
  bool has_packet_id() const;
  void clear_packet_id() ;
  const ::ai::inworld::packets::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* value);
  void unsafe_arena_set_allocated_packet_id(::ai::inworld::packets::PacketId* value);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ApplyResponse)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::ai::inworld::packets::PacketId* packet_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class AdditionalPhonemeInfo final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AdditionalPhonemeInfo) */ {
 public:
  inline AdditionalPhonemeInfo() : AdditionalPhonemeInfo(nullptr) {}
  ~AdditionalPhonemeInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AdditionalPhonemeInfo(::google::protobuf_inworld::internal::ConstantInitialized);

  inline AdditionalPhonemeInfo(const AdditionalPhonemeInfo& from)
      : AdditionalPhonemeInfo(nullptr, from) {}
  AdditionalPhonemeInfo(AdditionalPhonemeInfo&& from) noexcept
    : AdditionalPhonemeInfo() {
    *this = ::std::move(from);
  }

  inline AdditionalPhonemeInfo& operator=(const AdditionalPhonemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPhonemeInfo& operator=(AdditionalPhonemeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdditionalPhonemeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdditionalPhonemeInfo* internal_default_instance() {
    return reinterpret_cast<const AdditionalPhonemeInfo*>(
               &_AdditionalPhonemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AdditionalPhonemeInfo& a, AdditionalPhonemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalPhonemeInfo* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const AdditionalPhonemeInfo& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const AdditionalPhonemeInfo& from) {
    AdditionalPhonemeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(AdditionalPhonemeInfo* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.AdditionalPhonemeInfo";
  }
  protected:
  explicit AdditionalPhonemeInfo(::google::protobuf_inworld::Arena* arena);
  AdditionalPhonemeInfo(::google::protobuf_inworld::Arena* arena, const AdditionalPhonemeInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonemeFieldNumber = 1,
    kStartOffsetFieldNumber = 2,
  };
  // string phoneme = 1;
  void clear_phoneme() ;
  const std::string& phoneme() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phoneme(Arg_&& arg, Args_... args);
  std::string* mutable_phoneme();
  PROTOBUF_NODISCARD std::string* release_phoneme();
  void set_allocated_phoneme(std::string* value);

  private:
  const std::string& _internal_phoneme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phoneme(
      const std::string& value);
  std::string* _internal_mutable_phoneme();

  public:
  // .google.protobuf.Duration start_offset = 2;
  bool has_start_offset() const;
  void clear_start_offset() ;
  const ::google::protobuf_inworld::Duration& start_offset() const;
  PROTOBUF_NODISCARD ::google::protobuf_inworld::Duration* release_start_offset();
  ::google::protobuf_inworld::Duration* mutable_start_offset();
  void set_allocated_start_offset(::google::protobuf_inworld::Duration* value);
  void unsafe_arena_set_allocated_start_offset(::google::protobuf_inworld::Duration* value);
  ::google::protobuf_inworld::Duration* unsafe_arena_release_start_offset();

  private:
  const ::google::protobuf_inworld::Duration& _internal_start_offset() const;
  ::google::protobuf_inworld::Duration* _internal_mutable_start_offset();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AdditionalPhonemeInfo)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      1, 2, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::internal::ArenaStringPtr phoneme_;
    ::google::protobuf_inworld::Duration* start_offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class ActionEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ActionEvent) */ {
 public:
  inline ActionEvent() : ActionEvent(nullptr) {}
  ~ActionEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ActionEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline ActionEvent(const ActionEvent& from)
      : ActionEvent(nullptr, from) {}
  ActionEvent(ActionEvent&& from) noexcept
    : ActionEvent() {
    *this = ::std::move(from);
  }

  inline ActionEvent& operator=(const ActionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEvent& operator=(ActionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionEvent& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kNarratedAction = 1,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionEvent* internal_default_instance() {
    return reinterpret_cast<const ActionEvent*>(
               &_ActionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ActionEvent& a, ActionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const ActionEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const ActionEvent& from) {
    ActionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(ActionEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.ActionEvent";
  }
  protected:
  explicit ActionEvent(::google::protobuf_inworld::Arena* arena);
  ActionEvent(::google::protobuf_inworld::Arena* arena, const ActionEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaybackFieldNumber = 2,
    kNarratedActionFieldNumber = 1,
  };
  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback() ;
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);

  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);

  public:
  // .ai.inworld.packets.NarratedAction narrated_action = 1;
  bool has_narrated_action() const;
  private:
  bool _internal_has_narrated_action() const;

  public:
  void clear_narrated_action() ;
  const ::ai::inworld::packets::NarratedAction& narrated_action() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::NarratedAction* release_narrated_action();
  ::ai::inworld::packets::NarratedAction* mutable_narrated_action();
  void set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* value);
  void unsafe_arena_set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* value);
  ::ai::inworld::packets::NarratedAction* unsafe_arena_release_narrated_action();

  private:
  const ::ai::inworld::packets::NarratedAction& _internal_narrated_action() const;
  ::ai::inworld::packets::NarratedAction* _internal_mutable_narrated_action();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ActionEvent)
 private:
  class _Internal;
  void set_has_narrated_action();

  inline bool has_action() const;
  inline void clear_has_action();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    int playback_;
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::NarratedAction* narrated_action_;
    } action_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class SessionControlResponseEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionControlResponseEvent) */ {
 public:
  inline SessionControlResponseEvent() : SessionControlResponseEvent(nullptr) {}
  ~SessionControlResponseEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SessionControlResponseEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline SessionControlResponseEvent(const SessionControlResponseEvent& from)
      : SessionControlResponseEvent(nullptr, from) {}
  SessionControlResponseEvent(SessionControlResponseEvent&& from) noexcept
    : SessionControlResponseEvent() {
    *this = ::std::move(from);
  }

  inline SessionControlResponseEvent& operator=(const SessionControlResponseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionControlResponseEvent& operator=(SessionControlResponseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionControlResponseEvent& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kLoadedScene = 1,
    kLoadedCharacters = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const SessionControlResponseEvent* internal_default_instance() {
    return reinterpret_cast<const SessionControlResponseEvent*>(
               &_SessionControlResponseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SessionControlResponseEvent& a, SessionControlResponseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionControlResponseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionControlResponseEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionControlResponseEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionControlResponseEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const SessionControlResponseEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const SessionControlResponseEvent& from) {
    SessionControlResponseEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionControlResponseEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.SessionControlResponseEvent";
  }
  protected:
  explicit SessionControlResponseEvent(::google::protobuf_inworld::Arena* arena);
  SessionControlResponseEvent(::google::protobuf_inworld::Arena* arena, const SessionControlResponseEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadedSceneFieldNumber = 1,
    kLoadedCharactersFieldNumber = 2,
  };
  // .ai.inworld.packets.LoadedScene loaded_scene = 1;
  bool has_loaded_scene() const;
  private:
  bool _internal_has_loaded_scene() const;

  public:
  void clear_loaded_scene() ;
  const ::ai::inworld::packets::LoadedScene& loaded_scene() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadedScene* release_loaded_scene();
  ::ai::inworld::packets::LoadedScene* mutable_loaded_scene();
  void set_allocated_loaded_scene(::ai::inworld::packets::LoadedScene* value);
  void unsafe_arena_set_allocated_loaded_scene(::ai::inworld::packets::LoadedScene* value);
  ::ai::inworld::packets::LoadedScene* unsafe_arena_release_loaded_scene();

  private:
  const ::ai::inworld::packets::LoadedScene& _internal_loaded_scene() const;
  ::ai::inworld::packets::LoadedScene* _internal_mutable_loaded_scene();

  public:
  // .ai.inworld.packets.LoadedCharacters loaded_characters = 2;
  bool has_loaded_characters() const;
  private:
  bool _internal_has_loaded_characters() const;

  public:
  void clear_loaded_characters() ;
  const ::ai::inworld::packets::LoadedCharacters& loaded_characters() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadedCharacters* release_loaded_characters();
  ::ai::inworld::packets::LoadedCharacters* mutable_loaded_characters();
  void set_allocated_loaded_characters(::ai::inworld::packets::LoadedCharacters* value);
  void unsafe_arena_set_allocated_loaded_characters(::ai::inworld::packets::LoadedCharacters* value);
  ::ai::inworld::packets::LoadedCharacters* unsafe_arena_release_loaded_characters();

  private:
  const ::ai::inworld::packets::LoadedCharacters& _internal_loaded_characters() const;
  ::ai::inworld::packets::LoadedCharacters* _internal_mutable_loaded_characters();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionControlResponseEvent)
 private:
  class _Internal;
  void set_has_loaded_scene();
  void set_has_loaded_characters();

  inline bool has_response() const;
  inline void clear_has_response();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::LoadedScene* loaded_scene_;
      ::ai::inworld::packets::LoadedCharacters* loaded_characters_;
    } response_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class MutationEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.MutationEvent) */ {
 public:
  inline MutationEvent() : MutationEvent(nullptr) {}
  ~MutationEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MutationEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline MutationEvent(const MutationEvent& from)
      : MutationEvent(nullptr, from) {}
  MutationEvent(MutationEvent&& from) noexcept
    : MutationEvent() {
    *this = ::std::move(from);
  }

  inline MutationEvent& operator=(const MutationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationEvent& operator=(MutationEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutationEvent& default_instance() {
    return *internal_default_instance();
  }
  enum MutationCase {
    kCancelResponses = 1,
    kRegenerateResponse = 2,
    kApplyResponse = 3,
    kLoadScene = 4,
    kModifyExactResponse = 5,
    kLoadCharacters = 6,
    MUTATION_NOT_SET = 0,
  };

  static inline const MutationEvent* internal_default_instance() {
    return reinterpret_cast<const MutationEvent*>(
               &_MutationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MutationEvent& a, MutationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutationEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutationEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutationEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const MutationEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const MutationEvent& from) {
    MutationEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(MutationEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.MutationEvent";
  }
  protected:
  explicit MutationEvent(::google::protobuf_inworld::Arena* arena);
  MutationEvent(::google::protobuf_inworld::Arena* arena, const MutationEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancelResponsesFieldNumber = 1,
    kRegenerateResponseFieldNumber = 2,
    kApplyResponseFieldNumber = 3,
    kLoadSceneFieldNumber = 4,
    kModifyExactResponseFieldNumber = 5,
    kLoadCharactersFieldNumber = 6,
  };
  // .ai.inworld.packets.CancelResponses cancel_responses = 1;
  bool has_cancel_responses() const;
  private:
  bool _internal_has_cancel_responses() const;

  public:
  void clear_cancel_responses() ;
  const ::ai::inworld::packets::CancelResponses& cancel_responses() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CancelResponses* release_cancel_responses();
  ::ai::inworld::packets::CancelResponses* mutable_cancel_responses();
  void set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* value);
  void unsafe_arena_set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* value);
  ::ai::inworld::packets::CancelResponses* unsafe_arena_release_cancel_responses();

  private:
  const ::ai::inworld::packets::CancelResponses& _internal_cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* _internal_mutable_cancel_responses();

  public:
  // .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
  bool has_regenerate_response() const;
  private:
  bool _internal_has_regenerate_response() const;

  public:
  void clear_regenerate_response() ;
  const ::ai::inworld::packets::RegenerateResponse& regenerate_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RegenerateResponse* release_regenerate_response();
  ::ai::inworld::packets::RegenerateResponse* mutable_regenerate_response();
  void set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* value);
  void unsafe_arena_set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* value);
  ::ai::inworld::packets::RegenerateResponse* unsafe_arena_release_regenerate_response();

  private:
  const ::ai::inworld::packets::RegenerateResponse& _internal_regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* _internal_mutable_regenerate_response();

  public:
  // .ai.inworld.packets.ApplyResponse apply_response = 3;
  bool has_apply_response() const;
  private:
  bool _internal_has_apply_response() const;

  public:
  void clear_apply_response() ;
  const ::ai::inworld::packets::ApplyResponse& apply_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ApplyResponse* release_apply_response();
  ::ai::inworld::packets::ApplyResponse* mutable_apply_response();
  void set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* value);
  void unsafe_arena_set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* value);
  ::ai::inworld::packets::ApplyResponse* unsafe_arena_release_apply_response();

  private:
  const ::ai::inworld::packets::ApplyResponse& _internal_apply_response() const;
  ::ai::inworld::packets::ApplyResponse* _internal_mutable_apply_response();

  public:
  // .ai.inworld.packets.LoadScene load_scene = 4;
  bool has_load_scene() const;
  private:
  bool _internal_has_load_scene() const;

  public:
  void clear_load_scene() ;
  const ::ai::inworld::packets::LoadScene& load_scene() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadScene* release_load_scene();
  ::ai::inworld::packets::LoadScene* mutable_load_scene();
  void set_allocated_load_scene(::ai::inworld::packets::LoadScene* value);
  void unsafe_arena_set_allocated_load_scene(::ai::inworld::packets::LoadScene* value);
  ::ai::inworld::packets::LoadScene* unsafe_arena_release_load_scene();

  private:
  const ::ai::inworld::packets::LoadScene& _internal_load_scene() const;
  ::ai::inworld::packets::LoadScene* _internal_mutable_load_scene();

  public:
  // .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
  bool has_modify_exact_response() const;
  private:
  bool _internal_has_modify_exact_response() const;

  public:
  void clear_modify_exact_response() ;
  const ::ai::inworld::packets::ModifyExactResponse& modify_exact_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ModifyExactResponse* release_modify_exact_response();
  ::ai::inworld::packets::ModifyExactResponse* mutable_modify_exact_response();
  void set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* value);
  void unsafe_arena_set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* value);
  ::ai::inworld::packets::ModifyExactResponse* unsafe_arena_release_modify_exact_response();

  private:
  const ::ai::inworld::packets::ModifyExactResponse& _internal_modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* _internal_mutable_modify_exact_response();

  public:
  // .ai.inworld.packets.LoadCharacters load_characters = 6;
  bool has_load_characters() const;
  private:
  bool _internal_has_load_characters() const;

  public:
  void clear_load_characters() ;
  const ::ai::inworld::packets::LoadCharacters& load_characters() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadCharacters* release_load_characters();
  ::ai::inworld::packets::LoadCharacters* mutable_load_characters();
  void set_allocated_load_characters(::ai::inworld::packets::LoadCharacters* value);
  void unsafe_arena_set_allocated_load_characters(::ai::inworld::packets::LoadCharacters* value);
  ::ai::inworld::packets::LoadCharacters* unsafe_arena_release_load_characters();

  private:
  const ::ai::inworld::packets::LoadCharacters& _internal_load_characters() const;
  ::ai::inworld::packets::LoadCharacters* _internal_mutable_load_characters();

  public:
  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.MutationEvent)
 private:
  class _Internal;
  void set_has_cancel_responses();
  void set_has_regenerate_response();
  void set_has_apply_response();
  void set_has_load_scene();
  void set_has_modify_exact_response();
  void set_has_load_characters();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    union MutationUnion {
      constexpr MutationUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::CancelResponses* cancel_responses_;
      ::ai::inworld::packets::RegenerateResponse* regenerate_response_;
      ::ai::inworld::packets::ApplyResponse* apply_response_;
      ::ai::inworld::packets::LoadScene* load_scene_;
      ::ai::inworld::packets::ModifyExactResponse* modify_exact_response_;
      ::ai::inworld::packets::LoadCharacters* load_characters_;
    } mutation_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class DialogHistory final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DialogHistory) */ {
 public:
  inline DialogHistory() : DialogHistory(nullptr) {}
  ~DialogHistory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DialogHistory(::google::protobuf_inworld::internal::ConstantInitialized);

  inline DialogHistory(const DialogHistory& from)
      : DialogHistory(nullptr, from) {}
  DialogHistory(DialogHistory&& from) noexcept
    : DialogHistory() {
    *this = ::std::move(from);
  }

  inline DialogHistory& operator=(const DialogHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline DialogHistory& operator=(DialogHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DialogHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const DialogHistory* internal_default_instance() {
    return reinterpret_cast<const DialogHistory*>(
               &_DialogHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DialogHistory& a, DialogHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(DialogHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DialogHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DialogHistory* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DialogHistory>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const DialogHistory& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const DialogHistory& from) {
    DialogHistory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(DialogHistory* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.DialogHistory";
  }
  protected:
  explicit DialogHistory(::google::protobuf_inworld::Arena* arena);
  DialogHistory(::google::protobuf_inworld::Arena* arena, const DialogHistory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using HistoryItem = DialogHistory_HistoryItem;

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.DialogHistory.HistoryItem history = 1;
  int history_size() const;
  private:
  int _internal_history_size() const;

  public:
  void clear_history() ;
  ::ai::inworld::packets::DialogHistory_HistoryItem* mutable_history(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >*
      mutable_history();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>& _internal_history() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>* _internal_mutable_history();
  public:
  const ::ai::inworld::packets::DialogHistory_HistoryItem& history(int index) const;
  ::ai::inworld::packets::DialogHistory_HistoryItem* add_history();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >&
      history() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DialogHistory)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem > history_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class DebugInfoEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DebugInfoEvent) */ {
 public:
  inline DebugInfoEvent() : DebugInfoEvent(nullptr) {}
  ~DebugInfoEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DebugInfoEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline DebugInfoEvent(const DebugInfoEvent& from)
      : DebugInfoEvent(nullptr, from) {}
  DebugInfoEvent(DebugInfoEvent&& from) noexcept
    : DebugInfoEvent() {
    *this = ::std::move(from);
  }

  inline DebugInfoEvent& operator=(const DebugInfoEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInfoEvent& operator=(DebugInfoEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugInfoEvent& default_instance() {
    return *internal_default_instance();
  }
  enum InfoCase {
    kRelation = 1,
    INFO_NOT_SET = 0,
  };

  static inline const DebugInfoEvent* internal_default_instance() {
    return reinterpret_cast<const DebugInfoEvent*>(
               &_DebugInfoEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DebugInfoEvent& a, DebugInfoEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugInfoEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInfoEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugInfoEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugInfoEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const DebugInfoEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const DebugInfoEvent& from) {
    DebugInfoEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebugInfoEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.DebugInfoEvent";
  }
  protected:
  explicit DebugInfoEvent(::google::protobuf_inworld::Arena* arena);
  DebugInfoEvent(::google::protobuf_inworld::Arena* arena, const DebugInfoEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // .ai.inworld.packets.RelationInfo relation = 1;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;

  public:
  void clear_relation() ;
  const ::ai::inworld::packets::RelationInfo& relation() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo* release_relation();
  ::ai::inworld::packets::RelationInfo* mutable_relation();
  void set_allocated_relation(::ai::inworld::packets::RelationInfo* value);
  void unsafe_arena_set_allocated_relation(::ai::inworld::packets::RelationInfo* value);
  ::ai::inworld::packets::RelationInfo* unsafe_arena_release_relation();

  private:
  const ::ai::inworld::packets::RelationInfo& _internal_relation() const;
  ::ai::inworld::packets::RelationInfo* _internal_mutable_relation();

  public:
  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DebugInfoEvent)
 private:
  class _Internal;
  void set_has_relation();

  inline bool has_info() const;
  inline void clear_has_info();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    union InfoUnion {
      constexpr InfoUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::RelationInfo* relation_;
    } info_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class DataChunk final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  ~DataChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataChunk(::google::protobuf_inworld::internal::ConstantInitialized);

  inline DataChunk(const DataChunk& from)
      : DataChunk(nullptr, from) {}
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChunk& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kChunk = 1,
    kDurationMs = 3,
    DATA_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChunk* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const DataChunk& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const DataChunk& from) {
    DataChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataChunk* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.DataChunk";
  }
  protected:
  explicit DataChunk(::google::protobuf_inworld::Arena* arena);
  DataChunk(::google::protobuf_inworld::Arena* arena, const DataChunk& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DataType = DataChunk_DataType;
  static constexpr DataType UNSPECIFIED = DataChunk_DataType_UNSPECIFIED;
  static constexpr DataType AUDIO = DataChunk_DataType_AUDIO;
  static constexpr DataType SILENCE = DataChunk_DataType_SILENCE;
  static constexpr DataType STATE = DataChunk_DataType_STATE;
  static inline bool DataType_IsValid(int value) {
    return DataChunk_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN = DataChunk_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX = DataChunk_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE = DataChunk_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* DataType_descriptor() {
    return DataChunk_DataType_descriptor();
  }
  template <typename T>
  static inline const std::string& DataType_Name(T value) {
    return DataChunk_DataType_Name(value);
  }
  static inline bool DataType_Parse(absl::string_view name, DataType* value) {
    return DataChunk_DataType_Parse(name, value);
  }

  using AudioFormat = DataChunk_AudioFormat;
  static constexpr AudioFormat UNSPECIFIED_AUDIO_FORMAT = DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT;
  static constexpr AudioFormat AUDIO_MP3 = DataChunk_AudioFormat_AUDIO_MP3;
  static constexpr AudioFormat AUDIO_PCM_16000 = DataChunk_AudioFormat_AUDIO_PCM_16000;
  static constexpr AudioFormat AUDIO_PCM_22050 = DataChunk_AudioFormat_AUDIO_PCM_22050;
  static inline bool AudioFormat_IsValid(int value) {
    return DataChunk_AudioFormat_IsValid(value);
  }
  static constexpr AudioFormat AudioFormat_MIN = DataChunk_AudioFormat_AudioFormat_MIN;
  static constexpr AudioFormat AudioFormat_MAX = DataChunk_AudioFormat_AudioFormat_MAX;
  static constexpr int AudioFormat_ARRAYSIZE = DataChunk_AudioFormat_AudioFormat_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* AudioFormat_descriptor() {
    return DataChunk_AudioFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& AudioFormat_Name(T value) {
    return DataChunk_AudioFormat_Name(value);
  }
  static inline bool AudioFormat_Parse(absl::string_view name, AudioFormat* value) {
    return DataChunk_AudioFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPhonemeInfoFieldNumber = 4,
    kTypeFieldNumber = 2,
    kAudioFormatFieldNumber = 5,
    kChunkFieldNumber = 1,
    kDurationMsFieldNumber = 3,
  };
  // repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
  int additional_phoneme_info_size() const;
  private:
  int _internal_additional_phoneme_info_size() const;

  public:
  void clear_additional_phoneme_info() ;
  ::ai::inworld::packets::AdditionalPhonemeInfo* mutable_additional_phoneme_info(int index);
  ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
      mutable_additional_phoneme_info();
  private:
  const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>& _internal_additional_phoneme_info() const;
  ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>* _internal_mutable_additional_phoneme_info();
  public:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* add_additional_phoneme_info();
  const ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
      additional_phoneme_info() const;
  // .ai.inworld.packets.DataChunk.DataType type = 2;
  void clear_type() ;
  ::ai::inworld::packets::DataChunk_DataType type() const;
  void set_type(::ai::inworld::packets::DataChunk_DataType value);

  private:
  ::ai::inworld::packets::DataChunk_DataType _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::DataChunk_DataType value);

  public:
  // .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
  void clear_audioformat() ;
  ::ai::inworld::packets::DataChunk_AudioFormat audioformat() const;
  void set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);

  private:
  ::ai::inworld::packets::DataChunk_AudioFormat _internal_audioformat() const;
  void _internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);

  public:
  // bytes chunk = 1;
  bool has_chunk() const;
  void clear_chunk() ;
  const std::string& chunk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chunk(Arg_&& arg, Args_... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* value);

  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(
      const std::string& value);
  std::string* _internal_mutable_chunk();

  public:
  // int64 duration_ms = 3;
  bool has_duration_ms() const;
  void clear_duration_ms() ;
  ::int64_t duration_ms() const;
  void set_duration_ms(::int64_t value);

  private:
  ::int64_t _internal_duration_ms() const;
  void _internal_set_duration_ms(::int64_t value);

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DataChunk)
 private:
  class _Internal;
  void set_has_chunk();
  void set_has_duration_ms();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo > additional_phoneme_info_;
    int type_;
    int audioformat_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::google::protobuf_inworld::internal::ArenaStringPtr chunk_;
      ::int64_t duration_ms_;
    } data_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class Continuation final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Continuation) */ {
 public:
  inline Continuation() : Continuation(nullptr) {}
  ~Continuation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Continuation(::google::protobuf_inworld::internal::ConstantInitialized);

  inline Continuation(const Continuation& from)
      : Continuation(nullptr, from) {}
  Continuation(Continuation&& from) noexcept
    : Continuation() {
    *this = ::std::move(from);
  }

  inline Continuation& operator=(const Continuation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Continuation& operator=(Continuation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Continuation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Continuation* internal_default_instance() {
    return reinterpret_cast<const Continuation*>(
               &_Continuation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Continuation& a, Continuation& b) {
    a.Swap(&b);
  }
  inline void Swap(Continuation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Continuation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Continuation* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Continuation>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const Continuation& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const Continuation& from) {
    Continuation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(Continuation* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.Continuation";
  }
  protected:
  explicit Continuation(::google::protobuf_inworld::Arena* arena);
  Continuation(::google::protobuf_inworld::Arena* arena, const Continuation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ContinuationInfo = Continuation_ContinuationInfo;

  using ContinuationType = Continuation_ContinuationType;
  static constexpr ContinuationType CONTINUATION_TYPE_UNKNOWN = Continuation_ContinuationType_CONTINUATION_TYPE_UNKNOWN;
  static constexpr ContinuationType CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE = Continuation_ContinuationType_CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE;
  static constexpr ContinuationType CONTINUATION_TYPE_DIALOG_HISTORY = Continuation_ContinuationType_CONTINUATION_TYPE_DIALOG_HISTORY;
  static inline bool ContinuationType_IsValid(int value) {
    return Continuation_ContinuationType_IsValid(value);
  }
  static constexpr ContinuationType ContinuationType_MIN = Continuation_ContinuationType_ContinuationType_MIN;
  static constexpr ContinuationType ContinuationType_MAX = Continuation_ContinuationType_ContinuationType_MAX;
  static constexpr int ContinuationType_ARRAYSIZE = Continuation_ContinuationType_ContinuationType_ARRAYSIZE;
  static inline const ::google::protobuf_inworld::EnumDescriptor* ContinuationType_descriptor() {
    return Continuation_ContinuationType_descriptor();
  }
  template <typename T>
  static inline const std::string& ContinuationType_Name(T value) {
    return Continuation_ContinuationType_Name(value);
  }
  static inline bool ContinuationType_Parse(absl::string_view name, ContinuationType* value) {
    return Continuation_ContinuationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExternallySavedStateFieldNumber = 4,
    kContinuationInfoFieldNumber = 1,
    kDialogHistoryFieldNumber = 3,
    kContinuationTypeFieldNumber = 2,
  };
  // bytes externally_saved_state = 4;
  void clear_externally_saved_state() ;
  const std::string& externally_saved_state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_externally_saved_state(Arg_&& arg, Args_... args);
  std::string* mutable_externally_saved_state();
  PROTOBUF_NODISCARD std::string* release_externally_saved_state();
  void set_allocated_externally_saved_state(std::string* value);

  private:
  const std::string& _internal_externally_saved_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_externally_saved_state(
      const std::string& value);
  std::string* _internal_mutable_externally_saved_state();

  public:
  // .ai.inworld.packets.Continuation.ContinuationInfo continuation_info = 1;
  bool has_continuation_info() const;
  void clear_continuation_info() ;
  const ::ai::inworld::packets::Continuation_ContinuationInfo& continuation_info() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Continuation_ContinuationInfo* release_continuation_info();
  ::ai::inworld::packets::Continuation_ContinuationInfo* mutable_continuation_info();
  void set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* value);
  void unsafe_arena_set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* value);
  ::ai::inworld::packets::Continuation_ContinuationInfo* unsafe_arena_release_continuation_info();

  private:
  const ::ai::inworld::packets::Continuation_ContinuationInfo& _internal_continuation_info() const;
  ::ai::inworld::packets::Continuation_ContinuationInfo* _internal_mutable_continuation_info();

  public:
  // .ai.inworld.packets.DialogHistory dialog_history = 3;
  bool has_dialog_history() const;
  void clear_dialog_history() ;
  const ::ai::inworld::packets::DialogHistory& dialog_history() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DialogHistory* release_dialog_history();
  ::ai::inworld::packets::DialogHistory* mutable_dialog_history();
  void set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* value);
  void unsafe_arena_set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* value);
  ::ai::inworld::packets::DialogHistory* unsafe_arena_release_dialog_history();

  private:
  const ::ai::inworld::packets::DialogHistory& _internal_dialog_history() const;
  ::ai::inworld::packets::DialogHistory* _internal_mutable_dialog_history();

  public:
  // .ai.inworld.packets.Continuation.ContinuationType continuation_type = 2;
  void clear_continuation_type() ;
  ::ai::inworld::packets::Continuation_ContinuationType continuation_type() const;
  void set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value);

  private:
  ::ai::inworld::packets::Continuation_ContinuationType _internal_continuation_type() const;
  void _internal_set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Continuation)
 private:
  class _Internal;

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::internal::ArenaStringPtr externally_saved_state_;
    ::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info_;
    ::ai::inworld::packets::DialogHistory* dialog_history_;
    int continuation_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class SessionControlEvent final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionControlEvent) */ {
 public:
  inline SessionControlEvent() : SessionControlEvent(nullptr) {}
  ~SessionControlEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SessionControlEvent(::google::protobuf_inworld::internal::ConstantInitialized);

  inline SessionControlEvent(const SessionControlEvent& from)
      : SessionControlEvent(nullptr, from) {}
  SessionControlEvent(SessionControlEvent&& from) noexcept
    : SessionControlEvent() {
    *this = ::std::move(from);
  }

  inline SessionControlEvent& operator=(const SessionControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionControlEvent& operator=(SessionControlEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionControlEvent& default_instance() {
    return *internal_default_instance();
  }
  enum SessionControlCase {
    kSessionConfiguration = 1,
    kUserConfiguration = 2,
    kClientConfiguration = 3,
    kCapabilitiesConfiguration = 4,
    kContinuation = 5,
    SESSION_CONTROL_NOT_SET = 0,
  };

  static inline const SessionControlEvent* internal_default_instance() {
    return reinterpret_cast<const SessionControlEvent*>(
               &_SessionControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SessionControlEvent& a, SessionControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionControlEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionControlEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionControlEvent* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionControlEvent>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const SessionControlEvent& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const SessionControlEvent& from) {
    SessionControlEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionControlEvent* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.SessionControlEvent";
  }
  protected:
  explicit SessionControlEvent(::google::protobuf_inworld::Arena* arena);
  SessionControlEvent(::google::protobuf_inworld::Arena* arena, const SessionControlEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionConfigurationFieldNumber = 1,
    kUserConfigurationFieldNumber = 2,
    kClientConfigurationFieldNumber = 3,
    kCapabilitiesConfigurationFieldNumber = 4,
    kContinuationFieldNumber = 5,
  };
  // .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
  bool has_session_configuration() const;
  private:
  bool _internal_has_session_configuration() const;

  public:
  void clear_session_configuration() ;
  const ::ai::inworld::engine::configuration::SessionConfiguration& session_configuration() const;
  PROTOBUF_NODISCARD ::ai::inworld::engine::configuration::SessionConfiguration* release_session_configuration();
  ::ai::inworld::engine::configuration::SessionConfiguration* mutable_session_configuration();
  void set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* value);
  void unsafe_arena_set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* value);
  ::ai::inworld::engine::configuration::SessionConfiguration* unsafe_arena_release_session_configuration();

  private:
  const ::ai::inworld::engine::configuration::SessionConfiguration& _internal_session_configuration() const;
  ::ai::inworld::engine::configuration::SessionConfiguration* _internal_mutable_session_configuration();

  public:
  // .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
  bool has_user_configuration() const;
  private:
  bool _internal_has_user_configuration() const;

  public:
  void clear_user_configuration() ;
  const ::ai::inworld::engine::configuration::UserConfiguration& user_configuration() const;
  PROTOBUF_NODISCARD ::ai::inworld::engine::configuration::UserConfiguration* release_user_configuration();
  ::ai::inworld::engine::configuration::UserConfiguration* mutable_user_configuration();
  void set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* value);
  void unsafe_arena_set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* value);
  ::ai::inworld::engine::configuration::UserConfiguration* unsafe_arena_release_user_configuration();

  private:
  const ::ai::inworld::engine::configuration::UserConfiguration& _internal_user_configuration() const;
  ::ai::inworld::engine::configuration::UserConfiguration* _internal_mutable_user_configuration();

  public:
  // .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;

  public:
  void clear_client_configuration() ;
  const ::ai::inworld::engine::configuration::ClientConfiguration& client_configuration() const;
  PROTOBUF_NODISCARD ::ai::inworld::engine::configuration::ClientConfiguration* release_client_configuration();
  ::ai::inworld::engine::configuration::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* value);
  void unsafe_arena_set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* value);
  ::ai::inworld::engine::configuration::ClientConfiguration* unsafe_arena_release_client_configuration();

  private:
  const ::ai::inworld::engine::configuration::ClientConfiguration& _internal_client_configuration() const;
  ::ai::inworld::engine::configuration::ClientConfiguration* _internal_mutable_client_configuration();

  public:
  // .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
  bool has_capabilities_configuration() const;
  private:
  bool _internal_has_capabilities_configuration() const;

  public:
  void clear_capabilities_configuration() ;
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& capabilities_configuration() const;
  PROTOBUF_NODISCARD ::ai::inworld::engine::configuration::CapabilitiesConfiguration* release_capabilities_configuration();
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* mutable_capabilities_configuration();
  void set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* value);
  void unsafe_arena_set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* value);
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* unsafe_arena_release_capabilities_configuration();

  private:
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& _internal_capabilities_configuration() const;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* _internal_mutable_capabilities_configuration();

  public:
  // .ai.inworld.packets.Continuation continuation = 5;
  bool has_continuation() const;
  private:
  bool _internal_has_continuation() const;

  public:
  void clear_continuation() ;
  const ::ai::inworld::packets::Continuation& continuation() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Continuation* release_continuation();
  ::ai::inworld::packets::Continuation* mutable_continuation();
  void set_allocated_continuation(::ai::inworld::packets::Continuation* value);
  void unsafe_arena_set_allocated_continuation(::ai::inworld::packets::Continuation* value);
  ::ai::inworld::packets::Continuation* unsafe_arena_release_continuation();

  private:
  const ::ai::inworld::packets::Continuation& _internal_continuation() const;
  ::ai::inworld::packets::Continuation* _internal_mutable_continuation();

  public:
  void clear_session_control();
  SessionControlCase session_control_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionControlEvent)
 private:
  class _Internal;
  void set_has_session_configuration();
  void set_has_user_configuration();
  void set_has_client_configuration();
  void set_has_capabilities_configuration();
  void set_has_continuation();

  inline bool has_session_control() const;
  inline void clear_has_session_control();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    union SessionControlUnion {
      constexpr SessionControlUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration_;
      ::ai::inworld::engine::configuration::UserConfiguration* user_configuration_;
      ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration_;
      ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration_;
      ::ai::inworld::packets::Continuation* continuation_;
    } session_control_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};// -------------------------------------------------------------------

class InworldPacket final :
    public ::google::protobuf_inworld::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.InworldPacket) */ {
 public:
  inline InworldPacket() : InworldPacket(nullptr) {}
  ~InworldPacket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InworldPacket(::google::protobuf_inworld::internal::ConstantInitialized);

  inline InworldPacket(const InworldPacket& from)
      : InworldPacket(nullptr, from) {}
  InworldPacket(InworldPacket&& from) noexcept
    : InworldPacket() {
    *this = ::std::move(from);
  }

  inline InworldPacket& operator=(const InworldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InworldPacket& operator=(InworldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf_inworld::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf_inworld::UnknownFieldSet>(::google::protobuf_inworld::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf_inworld::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf_inworld::UnknownFieldSet>();
  }

  static const ::google::protobuf_inworld::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf_inworld::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf_inworld::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InworldPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kText = 2,
    kControl = 3,
    kAudioChunk = 4,
    kCustom = 8,
    kCancelResponses = 10,
    kEmotion = 11,
    kDataChunk = 12,
    kAction = 13,
    kMutation = 15,
    kLoadSceneOutput = 16,
    kDebugInfo = 18,
    kSessionControl = 19,
    kSessionControlResponse = 20,
    PACKET_NOT_SET = 0,
  };

  static inline const InworldPacket* internal_default_instance() {
    return reinterpret_cast<const InworldPacket*>(
               &_InworldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InworldPacket& a, InworldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InworldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf_inworld::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InworldPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InworldPacket* New(::google::protobuf_inworld::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InworldPacket>(arena);
  }
  using ::google::protobuf_inworld::Message::CopyFrom;
  void CopyFrom(const InworldPacket& from);
  using ::google::protobuf_inworld::Message::MergeFrom;
  void MergeFrom( const InworldPacket& from) {
    InworldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf_inworld::Message& to_msg, const ::google::protobuf_inworld::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf_inworld::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf_inworld::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf_inworld::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf_inworld::Arena* arena);
  void SharedDtor();
  void InternalSwap(InworldPacket* other);

  private:
  friend class ::google::protobuf_inworld::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.packets.InworldPacket";
  }
  protected:
  explicit InworldPacket(::google::protobuf_inworld::Arena* arena);
  InworldPacket(::google::protobuf_inworld::Arena* arena, const InworldPacket& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf_inworld::Message::ClassData*GetClassData() const final;

  ::google::protobuf_inworld::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kRoutingFieldNumber = 6,
    kPacketIdFieldNumber = 9,
    kTextFieldNumber = 2,
    kControlFieldNumber = 3,
    kAudioChunkFieldNumber = 4,
    kCustomFieldNumber = 8,
    kCancelResponsesFieldNumber = 10,
    kEmotionFieldNumber = 11,
    kDataChunkFieldNumber = 12,
    kActionFieldNumber = 13,
    kMutationFieldNumber = 15,
    kLoadSceneOutputFieldNumber = 16,
    kDebugInfoFieldNumber = 18,
    kSessionControlFieldNumber = 19,
    kSessionControlResponseFieldNumber = 20,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf_inworld::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf_inworld::Timestamp* release_timestamp();
  ::google::protobuf_inworld::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf_inworld::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf_inworld::Timestamp* value);
  ::google::protobuf_inworld::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf_inworld::Timestamp& _internal_timestamp() const;
  ::google::protobuf_inworld::Timestamp* _internal_mutable_timestamp();

  public:
  // .ai.inworld.packets.Routing routing = 6;
  bool has_routing() const;
  void clear_routing() ;
  const ::ai::inworld::packets::Routing& routing() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Routing* release_routing();
  ::ai::inworld::packets::Routing* mutable_routing();
  void set_allocated_routing(::ai::inworld::packets::Routing* value);
  void unsafe_arena_set_allocated_routing(::ai::inworld::packets::Routing* value);
  ::ai::inworld::packets::Routing* unsafe_arena_release_routing();

  private:
  const ::ai::inworld::packets::Routing& _internal_routing() const;
  ::ai::inworld::packets::Routing* _internal_mutable_routing();

  public:
  // .ai.inworld.packets.PacketId packet_id = 9;
  bool has_packet_id() const;
  void clear_packet_id() ;
  const ::ai::inworld::packets::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* value);
  void unsafe_arena_set_allocated_packet_id(::ai::inworld::packets::PacketId* value);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();

  public:
  // .ai.inworld.packets.TextEvent text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;

  public:
  void clear_text() ;
  const ::ai::inworld::packets::TextEvent& text() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::TextEvent* release_text();
  ::ai::inworld::packets::TextEvent* mutable_text();
  void set_allocated_text(::ai::inworld::packets::TextEvent* value);
  void unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* value);
  ::ai::inworld::packets::TextEvent* unsafe_arena_release_text();

  private:
  const ::ai::inworld::packets::TextEvent& _internal_text() const;
  ::ai::inworld::packets::TextEvent* _internal_mutable_text();

  public:
  // .ai.inworld.packets.ControlEvent control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;

  public:
  void clear_control() ;
  const ::ai::inworld::packets::ControlEvent& control() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ControlEvent* release_control();
  ::ai::inworld::packets::ControlEvent* mutable_control();
  void set_allocated_control(::ai::inworld::packets::ControlEvent* value);
  void unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* value);
  ::ai::inworld::packets::ControlEvent* unsafe_arena_release_control();

  private:
  const ::ai::inworld::packets::ControlEvent& _internal_control() const;
  ::ai::inworld::packets::ControlEvent* _internal_mutable_control();

  public:
  // .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
  [[deprecated]]  bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;

  public:
  [[deprecated]]  void clear_audio_chunk() ;
  [[deprecated]] const ::ai::inworld::packets::AudioChunk& audio_chunk() const;
  [[deprecated]] PROTOBUF_NODISCARD ::ai::inworld::packets::AudioChunk* release_audio_chunk();
  [[deprecated]] ::ai::inworld::packets::AudioChunk* mutable_audio_chunk();
  [[deprecated]] void set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* value);
  [[deprecated]] void unsafe_arena_set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* value);
  [[deprecated]] ::ai::inworld::packets::AudioChunk* unsafe_arena_release_audio_chunk();

  private:
  const ::ai::inworld::packets::AudioChunk& _internal_audio_chunk() const;
  ::ai::inworld::packets::AudioChunk* _internal_mutable_audio_chunk();

  public:
  // .ai.inworld.packets.CustomEvent custom = 8;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;

  public:
  void clear_custom() ;
  const ::ai::inworld::packets::CustomEvent& custom() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CustomEvent* release_custom();
  ::ai::inworld::packets::CustomEvent* mutable_custom();
  void set_allocated_custom(::ai::inworld::packets::CustomEvent* value);
  void unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* value);
  ::ai::inworld::packets::CustomEvent* unsafe_arena_release_custom();

  private:
  const ::ai::inworld::packets::CustomEvent& _internal_custom() const;
  ::ai::inworld::packets::CustomEvent* _internal_mutable_custom();

  public:
  // .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
  [[deprecated]]  bool has_cancelresponses() const;
  private:
  bool _internal_has_cancelresponses() const;

  public:
  [[deprecated]]  void clear_cancelresponses() ;
  [[deprecated]] const ::ai::inworld::packets::CancelResponsesEvent& cancelresponses() const;
  [[deprecated]] PROTOBUF_NODISCARD ::ai::inworld::packets::CancelResponsesEvent* release_cancelresponses();
  [[deprecated]] ::ai::inworld::packets::CancelResponsesEvent* mutable_cancelresponses();
  [[deprecated]] void set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* value);
  [[deprecated]] void unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* value);
  [[deprecated]] ::ai::inworld::packets::CancelResponsesEvent* unsafe_arena_release_cancelresponses();

  private:
  const ::ai::inworld::packets::CancelResponsesEvent& _internal_cancelresponses() const;
  ::ai::inworld::packets::CancelResponsesEvent* _internal_mutable_cancelresponses();

  public:
  // .ai.inworld.packets.EmotionEvent emotion = 11;
  bool has_emotion() const;
  private:
  bool _internal_has_emotion() const;

  public:
  void clear_emotion() ;
  const ::ai::inworld::packets::EmotionEvent& emotion() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::EmotionEvent* release_emotion();
  ::ai::inworld::packets::EmotionEvent* mutable_emotion();
  void set_allocated_emotion(::ai::inworld::packets::EmotionEvent* value);
  void unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* value);
  ::ai::inworld::packets::EmotionEvent* unsafe_arena_release_emotion();

  private:
  const ::ai::inworld::packets::EmotionEvent& _internal_emotion() const;
  ::ai::inworld::packets::EmotionEvent* _internal_mutable_emotion();

  public:
  // .ai.inworld.packets.DataChunk data_chunk = 12;
  bool has_data_chunk() const;
  private:
  bool _internal_has_data_chunk() const;

  public:
  void clear_data_chunk() ;
  const ::ai::inworld::packets::DataChunk& data_chunk() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DataChunk* release_data_chunk();
  ::ai::inworld::packets::DataChunk* mutable_data_chunk();
  void set_allocated_data_chunk(::ai::inworld::packets::DataChunk* value);
  void unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* value);
  ::ai::inworld::packets::DataChunk* unsafe_arena_release_data_chunk();

  private:
  const ::ai::inworld::packets::DataChunk& _internal_data_chunk() const;
  ::ai::inworld::packets::DataChunk* _internal_mutable_data_chunk();

  public:
  // .ai.inworld.packets.ActionEvent action = 13;
  bool has_action() const;
  private:
  bool _internal_has_action() const;

  public:
  void clear_action() ;
  const ::ai::inworld::packets::ActionEvent& action() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ActionEvent* release_action();
  ::ai::inworld::packets::ActionEvent* mutable_action();
  void set_allocated_action(::ai::inworld::packets::ActionEvent* value);
  void unsafe_arena_set_allocated_action(::ai::inworld::packets::ActionEvent* value);
  ::ai::inworld::packets::ActionEvent* unsafe_arena_release_action();

  private:
  const ::ai::inworld::packets::ActionEvent& _internal_action() const;
  ::ai::inworld::packets::ActionEvent* _internal_mutable_action();

  public:
  // .ai.inworld.packets.MutationEvent mutation = 15;
  bool has_mutation() const;
  private:
  bool _internal_has_mutation() const;

  public:
  void clear_mutation() ;
  const ::ai::inworld::packets::MutationEvent& mutation() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::MutationEvent* release_mutation();
  ::ai::inworld::packets::MutationEvent* mutable_mutation();
  void set_allocated_mutation(::ai::inworld::packets::MutationEvent* value);
  void unsafe_arena_set_allocated_mutation(::ai::inworld::packets::MutationEvent* value);
  ::ai::inworld::packets::MutationEvent* unsafe_arena_release_mutation();

  private:
  const ::ai::inworld::packets::MutationEvent& _internal_mutation() const;
  ::ai::inworld::packets::MutationEvent* _internal_mutable_mutation();

  public:
  // .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16 [deprecated = true];
  [[deprecated]]  bool has_load_scene_output() const;
  private:
  bool _internal_has_load_scene_output() const;

  public:
  [[deprecated]]  void clear_load_scene_output() ;
  [[deprecated]] const ::ai::inworld::packets::LoadSceneOutputEvent& load_scene_output() const;
  [[deprecated]] PROTOBUF_NODISCARD ::ai::inworld::packets::LoadSceneOutputEvent* release_load_scene_output();
  [[deprecated]] ::ai::inworld::packets::LoadSceneOutputEvent* mutable_load_scene_output();
  [[deprecated]] void set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* value);
  [[deprecated]] void unsafe_arena_set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* value);
  [[deprecated]] ::ai::inworld::packets::LoadSceneOutputEvent* unsafe_arena_release_load_scene_output();

  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent& _internal_load_scene_output() const;
  ::ai::inworld::packets::LoadSceneOutputEvent* _internal_mutable_load_scene_output();

  public:
  // .ai.inworld.packets.DebugInfoEvent debug_info = 18;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;

  public:
  void clear_debug_info() ;
  const ::ai::inworld::packets::DebugInfoEvent& debug_info() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DebugInfoEvent* release_debug_info();
  ::ai::inworld::packets::DebugInfoEvent* mutable_debug_info();
  void set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* value);
  void unsafe_arena_set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* value);
  ::ai::inworld::packets::DebugInfoEvent* unsafe_arena_release_debug_info();

  private:
  const ::ai::inworld::packets::DebugInfoEvent& _internal_debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* _internal_mutable_debug_info();

  public:
  // .ai.inworld.packets.SessionControlEvent session_control = 19;
  bool has_session_control() const;
  private:
  bool _internal_has_session_control() const;

  public:
  void clear_session_control() ;
  const ::ai::inworld::packets::SessionControlEvent& session_control() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::SessionControlEvent* release_session_control();
  ::ai::inworld::packets::SessionControlEvent* mutable_session_control();
  void set_allocated_session_control(::ai::inworld::packets::SessionControlEvent* value);
  void unsafe_arena_set_allocated_session_control(::ai::inworld::packets::SessionControlEvent* value);
  ::ai::inworld::packets::SessionControlEvent* unsafe_arena_release_session_control();

  private:
  const ::ai::inworld::packets::SessionControlEvent& _internal_session_control() const;
  ::ai::inworld::packets::SessionControlEvent* _internal_mutable_session_control();

  public:
  // .ai.inworld.packets.SessionControlResponseEvent session_control_response = 20;
  bool has_session_control_response() const;
  private:
  bool _internal_has_session_control_response() const;

  public:
  void clear_session_control_response() ;
  const ::ai::inworld::packets::SessionControlResponseEvent& session_control_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::SessionControlResponseEvent* release_session_control_response();
  ::ai::inworld::packets::SessionControlResponseEvent* mutable_session_control_response();
  void set_allocated_session_control_response(::ai::inworld::packets::SessionControlResponseEvent* value);
  void unsafe_arena_set_allocated_session_control_response(::ai::inworld::packets::SessionControlResponseEvent* value);
  ::ai::inworld::packets::SessionControlResponseEvent* unsafe_arena_release_session_control_response();

  private:
  const ::ai::inworld::packets::SessionControlResponseEvent& _internal_session_control_response() const;
  ::ai::inworld::packets::SessionControlResponseEvent* _internal_mutable_session_control_response();

  public:
  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.InworldPacket)
 private:
  class _Internal;
  void set_has_text();
  void set_has_control();
  void set_has_audio_chunk();
  void set_has_custom();
  void set_has_cancelresponses();
  void set_has_emotion();
  void set_has_data_chunk();
  void set_has_action();
  void set_has_mutation();
  void set_has_load_scene_output();
  void set_has_debug_info();
  void set_has_session_control();
  void set_has_session_control_response();

  inline bool has_packet() const;
  inline void clear_has_packet();

  friend class ::google::protobuf_inworld::internal::TcParser;
  static const ::google::protobuf_inworld::internal::TcParseTable<
      4, 16, 16,
      0, 2>
      _table_;
  friend class ::google::protobuf_inworld::MessageLite;
  friend class ::google::protobuf_inworld::Arena;
  template <typename T>
  friend class ::google::protobuf_inworld::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf_inworld::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena);
        inline explicit Impl_(::google::protobuf_inworld::internal::InternalVisibility visibility,
                              ::google::protobuf_inworld::Arena* arena, const Impl_& from);
    ::google::protobuf_inworld::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf_inworld::internal::CachedSize _cached_size_;
    ::google::protobuf_inworld::Timestamp* timestamp_;
    ::ai::inworld::packets::Routing* routing_;
    ::ai::inworld::packets::PacketId* packet_id_;
    union PacketUnion {
      constexpr PacketUnion() : _constinit_{} {}
        ::google::protobuf_inworld::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::TextEvent* text_;
      ::ai::inworld::packets::ControlEvent* control_;
      ::ai::inworld::packets::AudioChunk* audio_chunk_;
      ::ai::inworld::packets::CustomEvent* custom_;
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses_;
      ::ai::inworld::packets::EmotionEvent* emotion_;
      ::ai::inworld::packets::DataChunk* data_chunk_;
      ::ai::inworld::packets::ActionEvent* action_;
      ::ai::inworld::packets::MutationEvent* mutation_;
      ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output_;
      ::ai::inworld::packets::DebugInfoEvent* debug_info_;
      ::ai::inworld::packets::SessionControlEvent* session_control_;
      ::ai::inworld::packets::SessionControlResponseEvent* session_control_response_;
    } packet_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Actor

// .ai.inworld.packets.Actor.Type type = 1;
inline void Actor::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::Actor_Type Actor::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.type)
  return _internal_type();
}
inline void Actor::set_type(::ai::inworld::packets::Actor_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.type)
}
inline ::ai::inworld::packets::Actor_Type Actor::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::Actor_Type>(_impl_.type_);
}
inline void Actor::_internal_set_type(::ai::inworld::packets::Actor_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string name = 2;
inline void Actor::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Actor::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Actor::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Actor.name)
  return _s;
}
inline const std::string& Actor::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Actor::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Actor::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Actor::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Actor.name)
  return _impl_.name_.Release();
}
inline void Actor::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Actor.name)
}

// -------------------------------------------------------------------

// Routing

// .ai.inworld.packets.Actor source = 1;
inline bool Routing::has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline void Routing::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Actor* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.source)
  return _internal_source();
}
inline void Routing::unsafe_arena_set_allocated_source(::ai::inworld::packets::Actor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.source)
}
inline ::ai::inworld::packets::Actor* Routing::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* released = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.source)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    _impl_.source_ = reinterpret_cast<::ai::inworld::packets::Actor*>(p);
  }
  return _impl_.source_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.source)
  return _msg;
}
inline void Routing::set_allocated_source(::ai::inworld::packets::Actor* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Actor*>(_impl_.source_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Actor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.source)
}

// .ai.inworld.packets.Actor target = 2;
inline bool Routing::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void Routing::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Actor* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.target)
  return _internal_target();
}
inline void Routing::unsafe_arena_set_allocated_target(::ai::inworld::packets::Actor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.target)
}
inline ::ai::inworld::packets::Actor* Routing::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::Actor* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::Actor* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    _impl_.target_ = reinterpret_cast<::ai::inworld::packets::Actor*>(p);
  }
  return _impl_.target_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.target)
  return _msg;
}
inline void Routing::set_allocated_target(::ai::inworld::packets::Actor* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Actor*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Actor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.target)
}

// repeated .ai.inworld.packets.Actor targets = 3;
inline int Routing::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int Routing::targets_size() const {
  return _internal_targets_size();
}
inline void Routing::clear_targets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targets_.Clear();
}
inline ::ai::inworld::packets::Actor* Routing::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>* Routing::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.Routing.targets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targets();
}
inline const ::ai::inworld::packets::Actor& Routing::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.targets)
  return _internal_targets().Get(index);
}
inline ::ai::inworld::packets::Actor* Routing::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::Actor* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.Routing.targets)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>& Routing::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.Routing.targets)
  return _internal_targets();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>&
Routing::_internal_targets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targets_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Actor>*
Routing::_internal_mutable_targets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targets_;
}

// -------------------------------------------------------------------

// PacketId

// string packet_id = 1;
inline void PacketId::clear_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_id_.ClearToEmpty();
}
inline const std::string& PacketId::packet_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.packet_id)
  return _internal_packet_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketId::set_packet_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packet_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::mutable_packet_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.packet_id)
  return _s;
}
inline const std::string& PacketId::_internal_packet_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_id_.Get();
}
inline void PacketId::_internal_set_packet_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packet_id_.Set(value, GetArena());
}
inline std::string* PacketId::_internal_mutable_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.packet_id_.Mutable( GetArena());
}
inline std::string* PacketId::release_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.packet_id)
  return _impl_.packet_id_.Release();
}
inline void PacketId::set_allocated_packet_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_id_.IsDefault()) {
          _impl_.packet_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.packet_id)
}

// string utterance_id = 2;
inline void PacketId::clear_utterance_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utterance_id_.ClearToEmpty();
}
inline const std::string& PacketId::utterance_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.utterance_id)
  return _internal_utterance_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketId::set_utterance_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.utterance_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::mutable_utterance_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_utterance_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.utterance_id)
  return _s;
}
inline const std::string& PacketId::_internal_utterance_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterance_id_.Get();
}
inline void PacketId::_internal_set_utterance_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.utterance_id_.Set(value, GetArena());
}
inline std::string* PacketId::_internal_mutable_utterance_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.utterance_id_.Mutable( GetArena());
}
inline std::string* PacketId::release_utterance_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.utterance_id)
  return _impl_.utterance_id_.Release();
}
inline void PacketId::set_allocated_utterance_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utterance_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.utterance_id_.IsDefault()) {
          _impl_.utterance_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.utterance_id)
}

// string interaction_id = 3;
inline void PacketId::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& PacketId::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketId::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.interaction_id)
  return _s;
}
inline const std::string& PacketId::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void PacketId::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* PacketId::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* PacketId::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void PacketId::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.interaction_id)
}

// string correlation_id = 4;
inline void PacketId::clear_correlation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& PacketId::correlation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.correlation_id)
  return _internal_correlation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketId::set_correlation_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.correlation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::mutable_correlation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.correlation_id)
  return _s;
}
inline const std::string& PacketId::_internal_correlation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.correlation_id_.Get();
}
inline void PacketId::_internal_set_correlation_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.correlation_id_.Set(value, GetArena());
}
inline std::string* PacketId::_internal_mutable_correlation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.correlation_id_.Mutable( GetArena());
}
inline std::string* PacketId::release_correlation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void PacketId::set_allocated_correlation_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.correlation_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.correlation_id_.IsDefault()) {
          _impl_.correlation_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.correlation_id)
}

// string conversation_id = 5;
inline void PacketId::clear_conversation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& PacketId::conversation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.conversation_id)
  return _internal_conversation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PacketId::set_conversation_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.conversation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.conversation_id)
}
inline std::string* PacketId::mutable_conversation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.conversation_id)
  return _s;
}
inline const std::string& PacketId::_internal_conversation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.conversation_id_.Get();
}
inline void PacketId::_internal_set_conversation_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.conversation_id_.Set(value, GetArena());
}
inline std::string* PacketId::_internal_mutable_conversation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.conversation_id_.Mutable( GetArena());
}
inline std::string* PacketId::release_conversation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void PacketId::set_allocated_conversation_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.conversation_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.conversation_id_.IsDefault()) {
          _impl_.conversation_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.conversation_id)
}

// -------------------------------------------------------------------

// InworldPacket

// .google.protobuf.Timestamp timestamp = 1;
inline bool InworldPacket::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf_inworld::Timestamp& InworldPacket::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf_inworld::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf_inworld::Timestamp&>(::google::protobuf_inworld::_Timestamp_default_instance_);
}
inline const ::google::protobuf_inworld::Timestamp& InworldPacket::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_timestamp();
}
inline void InworldPacket::unsafe_arena_set_allocated_timestamp(::google::protobuf_inworld::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}
inline ::google::protobuf_inworld::Timestamp* InworldPacket::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf_inworld::Timestamp* InworldPacket::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf_inworld::Timestamp* InworldPacket::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf_inworld::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf_inworld::Timestamp* InworldPacket::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf_inworld::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.timestamp)
  return _msg;
}
inline void InworldPacket::set_allocated_timestamp(::google::protobuf_inworld::Timestamp* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}

// .ai.inworld.packets.Routing routing = 6;
inline bool InworldPacket::has_routing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.routing_ != nullptr);
  return value;
}
inline void InworldPacket::clear_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.routing_ != nullptr) _impl_.routing_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::packets::Routing& InworldPacket::_internal_routing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Routing* p = _impl_.routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Routing&>(::ai::inworld::packets::_Routing_default_instance_);
}
inline const ::ai::inworld::packets::Routing& InworldPacket::routing() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.routing)
  return _internal_routing();
}
inline void InworldPacket::unsafe_arena_set_allocated_routing(::ai::inworld::packets::Routing* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.routing_);
  }
  _impl_.routing_ = reinterpret_cast<::ai::inworld::packets::Routing*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.routing)
}
inline ::ai::inworld::packets::Routing* InworldPacket::release_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::Routing* released = _impl_.routing_;
  _impl_.routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Routing* InworldPacket::unsafe_arena_release_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.routing)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::Routing* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::_internal_mutable_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Routing>(GetArena());
    _impl_.routing_ = reinterpret_cast<::ai::inworld::packets::Routing*>(p);
  }
  return _impl_.routing_;
}
inline ::ai::inworld::packets::Routing* InworldPacket::mutable_routing() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Routing* _msg = _internal_mutable_routing();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.routing)
  return _msg;
}
inline void InworldPacket::set_allocated_routing(::ai::inworld::packets::Routing* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Routing*>(_impl_.routing_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Routing*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.routing_ = reinterpret_cast<::ai::inworld::packets::Routing*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.routing)
}

// .ai.inworld.packets.PacketId packet_id = 9;
inline bool InworldPacket::has_packet_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_id_ != nullptr);
  return value;
}
inline void InworldPacket::clear_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_id_ != nullptr) _impl_.packet_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::_internal_packet_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::packet_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_packet_id();
}
inline void InworldPacket::unsafe_arena_set_allocated_packet_id(::ai::inworld::packets::PacketId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}
inline ::ai::inworld::packets::PacketId* InworldPacket::release_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::packets::PacketId* released = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::unsafe_arena_release_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.packet_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::_internal_mutable_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(p);
  }
  return _impl_.packet_id_;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::mutable_packet_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.packet_id)
  return _msg;
}
inline void InworldPacket::set_allocated_packet_id(::ai::inworld::packets::PacketId* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::PacketId*>(_impl_.packet_id_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::PacketId*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}

// .ai.inworld.packets.TextEvent text = 2;
inline bool InworldPacket::has_text() const {
  return packet_case() == kText;
}
inline bool InworldPacket::_internal_has_text() const {
  return packet_case() == kText;
}
inline void InworldPacket::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void InworldPacket::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kText) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.text_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.text)
  if (packet_case() == kText) {
    clear_has_packet();
    auto* temp = _impl_.packet_.text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::_internal_text() const {
  return packet_case() == kText ? *_impl_.packet_.text_ : reinterpret_cast<::ai::inworld::packets::TextEvent&>(::ai::inworld::packets::_TextEvent_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.text)
  return _internal_text();
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.text)
  if (packet_case() == kText) {
    clear_has_packet();
    auto* temp = _impl_.packet_.text_;
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_text();
    _impl_.packet_.text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.text)
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::_internal_mutable_text() {
  if (packet_case() != kText) {
    clear_packet();
    set_has_text();
    _impl_.packet_.text_ = CreateMaybeMessage<::ai::inworld::packets::TextEvent>(GetArena());
  }
  return _impl_.packet_.text_;
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::TextEvent* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.text)
  return _msg;
}

// .ai.inworld.packets.ControlEvent control = 3;
inline bool InworldPacket::has_control() const {
  return packet_case() == kControl;
}
inline bool InworldPacket::_internal_has_control() const {
  return packet_case() == kControl;
}
inline void InworldPacket::set_has_control() {
  _impl_._oneof_case_[0] = kControl;
}
inline void InworldPacket::clear_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kControl) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::release_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.control)
  if (packet_case() == kControl) {
    clear_has_packet();
    auto* temp = _impl_.packet_.control_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::_internal_control() const {
  return packet_case() == kControl ? *_impl_.packet_.control_ : reinterpret_cast<::ai::inworld::packets::ControlEvent&>(::ai::inworld::packets::_ControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.control)
  return _internal_control();
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.control)
  if (packet_case() == kControl) {
    clear_has_packet();
    auto* temp = _impl_.packet_.control_;
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_control();
    _impl_.packet_.control_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.control)
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::_internal_mutable_control() {
  if (packet_case() != kControl) {
    clear_packet();
    set_has_control();
    _impl_.packet_.control_ = CreateMaybeMessage<::ai::inworld::packets::ControlEvent>(GetArena());
  }
  return _impl_.packet_.control_;
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::mutable_control() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::ControlEvent* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.control)
  return _msg;
}

// .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
inline bool InworldPacket::has_audio_chunk() const {
  return packet_case() == kAudioChunk;
}
inline bool InworldPacket::_internal_has_audio_chunk() const {
  return packet_case() == kAudioChunk;
}
inline void InworldPacket::set_has_audio_chunk() {
  _impl_._oneof_case_[0] = kAudioChunk;
}
inline void InworldPacket::clear_audio_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kAudioChunk) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.audio_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (packet_case() == kAudioChunk) {
    clear_has_packet();
    auto* temp = _impl_.packet_.audio_chunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::_internal_audio_chunk() const {
  return packet_case() == kAudioChunk ? *_impl_.packet_.audio_chunk_ : reinterpret_cast<::ai::inworld::packets::AudioChunk&>(::ai::inworld::packets::_AudioChunk_default_instance_);
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::audio_chunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_audio_chunk();
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::unsafe_arena_release_audio_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (packet_case() == kAudioChunk) {
    clear_has_packet();
    auto* temp = _impl_.packet_.audio_chunk_;
    _impl_.packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_audio_chunk();
    _impl_.packet_.audio_chunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.audio_chunk)
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::_internal_mutable_audio_chunk() {
  if (packet_case() != kAudioChunk) {
    clear_packet();
    set_has_audio_chunk();
    _impl_.packet_.audio_chunk_ = CreateMaybeMessage<::ai::inworld::packets::AudioChunk>(GetArena());
  }
  return _impl_.packet_.audio_chunk_;
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::mutable_audio_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::AudioChunk* _msg = _internal_mutable_audio_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.audio_chunk)
  return _msg;
}

// .ai.inworld.packets.CustomEvent custom = 8;
inline bool InworldPacket::has_custom() const {
  return packet_case() == kCustom;
}
inline bool InworldPacket::_internal_has_custom() const {
  return packet_case() == kCustom;
}
inline void InworldPacket::set_has_custom() {
  _impl_._oneof_case_[0] = kCustom;
}
inline void InworldPacket::clear_custom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kCustom) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.custom_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::release_custom() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.custom)
  if (packet_case() == kCustom) {
    clear_has_packet();
    auto* temp = _impl_.packet_.custom_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::_internal_custom() const {
  return packet_case() == kCustom ? *_impl_.packet_.custom_ : reinterpret_cast<::ai::inworld::packets::CustomEvent&>(::ai::inworld::packets::_CustomEvent_default_instance_);
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::custom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.custom)
  return _internal_custom();
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.custom)
  if (packet_case() == kCustom) {
    clear_has_packet();
    auto* temp = _impl_.packet_.custom_;
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_custom();
    _impl_.packet_.custom_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.custom)
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::_internal_mutable_custom() {
  if (packet_case() != kCustom) {
    clear_packet();
    set_has_custom();
    _impl_.packet_.custom_ = CreateMaybeMessage<::ai::inworld::packets::CustomEvent>(GetArena());
  }
  return _impl_.packet_.custom_;
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::mutable_custom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::CustomEvent* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.custom)
  return _msg;
}

// .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
inline bool InworldPacket::has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline bool InworldPacket::_internal_has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline void InworldPacket::set_has_cancelresponses() {
  _impl_._oneof_case_[0] = kCancelResponses;
}
inline void InworldPacket::clear_cancelresponses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kCancelResponses) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.cancelresponses_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::release_cancelresponses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (packet_case() == kCancelResponses) {
    clear_has_packet();
    auto* temp = _impl_.packet_.cancelresponses_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::_internal_cancelresponses() const {
  return packet_case() == kCancelResponses ? *_impl_.packet_.cancelresponses_ : reinterpret_cast<::ai::inworld::packets::CancelResponsesEvent&>(::ai::inworld::packets::_CancelResponsesEvent_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::cancelresponses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_cancelresponses();
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::unsafe_arena_release_cancelresponses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (packet_case() == kCancelResponses) {
    clear_has_packet();
    auto* temp = _impl_.packet_.cancelresponses_;
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.cancelResponses)
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::_internal_mutable_cancelresponses() {
  if (packet_case() != kCancelResponses) {
    clear_packet();
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = CreateMaybeMessage<::ai::inworld::packets::CancelResponsesEvent>(GetArena());
  }
  return _impl_.packet_.cancelresponses_;
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::mutable_cancelresponses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::CancelResponsesEvent* _msg = _internal_mutable_cancelresponses();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.cancelResponses)
  return _msg;
}

// .ai.inworld.packets.EmotionEvent emotion = 11;
inline bool InworldPacket::has_emotion() const {
  return packet_case() == kEmotion;
}
inline bool InworldPacket::_internal_has_emotion() const {
  return packet_case() == kEmotion;
}
inline void InworldPacket::set_has_emotion() {
  _impl_._oneof_case_[0] = kEmotion;
}
inline void InworldPacket::clear_emotion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kEmotion) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.emotion_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::release_emotion() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.emotion)
  if (packet_case() == kEmotion) {
    clear_has_packet();
    auto* temp = _impl_.packet_.emotion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::_internal_emotion() const {
  return packet_case() == kEmotion ? *_impl_.packet_.emotion_ : reinterpret_cast<::ai::inworld::packets::EmotionEvent&>(::ai::inworld::packets::_EmotionEvent_default_instance_);
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::emotion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.emotion)
  return _internal_emotion();
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::unsafe_arena_release_emotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.emotion)
  if (packet_case() == kEmotion) {
    clear_has_packet();
    auto* temp = _impl_.packet_.emotion_;
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_emotion();
    _impl_.packet_.emotion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.emotion)
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::_internal_mutable_emotion() {
  if (packet_case() != kEmotion) {
    clear_packet();
    set_has_emotion();
    _impl_.packet_.emotion_ = CreateMaybeMessage<::ai::inworld::packets::EmotionEvent>(GetArena());
  }
  return _impl_.packet_.emotion_;
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::mutable_emotion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::EmotionEvent* _msg = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.emotion)
  return _msg;
}

// .ai.inworld.packets.DataChunk data_chunk = 12;
inline bool InworldPacket::has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline bool InworldPacket::_internal_has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline void InworldPacket::set_has_data_chunk() {
  _impl_._oneof_case_[0] = kDataChunk;
}
inline void InworldPacket::clear_data_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kDataChunk) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.data_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::release_data_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (packet_case() == kDataChunk) {
    clear_has_packet();
    auto* temp = _impl_.packet_.data_chunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::_internal_data_chunk() const {
  return packet_case() == kDataChunk ? *_impl_.packet_.data_chunk_ : reinterpret_cast<::ai::inworld::packets::DataChunk&>(::ai::inworld::packets::_DataChunk_default_instance_);
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::data_chunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_data_chunk();
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::unsafe_arena_release_data_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (packet_case() == kDataChunk) {
    clear_has_packet();
    auto* temp = _impl_.packet_.data_chunk_;
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.data_chunk)
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::_internal_mutable_data_chunk() {
  if (packet_case() != kDataChunk) {
    clear_packet();
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = CreateMaybeMessage<::ai::inworld::packets::DataChunk>(GetArena());
  }
  return _impl_.packet_.data_chunk_;
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::mutable_data_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::DataChunk* _msg = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.data_chunk)
  return _msg;
}

// .ai.inworld.packets.ActionEvent action = 13;
inline bool InworldPacket::has_action() const {
  return packet_case() == kAction;
}
inline bool InworldPacket::_internal_has_action() const {
  return packet_case() == kAction;
}
inline void InworldPacket::set_has_action() {
  _impl_._oneof_case_[0] = kAction;
}
inline void InworldPacket::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kAction) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.action_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::release_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.action)
  if (packet_case() == kAction) {
    clear_has_packet();
    auto* temp = _impl_.packet_.action_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::_internal_action() const {
  return packet_case() == kAction ? *_impl_.packet_.action_ : reinterpret_cast<::ai::inworld::packets::ActionEvent&>(::ai::inworld::packets::_ActionEvent_default_instance_);
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.action)
  return _internal_action();
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.action)
  if (packet_case() == kAction) {
    clear_has_packet();
    auto* temp = _impl_.packet_.action_;
    _impl_.packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_action(::ai::inworld::packets::ActionEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_action();
    _impl_.packet_.action_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.action)
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::_internal_mutable_action() {
  if (packet_case() != kAction) {
    clear_packet();
    set_has_action();
    _impl_.packet_.action_ = CreateMaybeMessage<::ai::inworld::packets::ActionEvent>(GetArena());
  }
  return _impl_.packet_.action_;
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::ActionEvent* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.action)
  return _msg;
}

// .ai.inworld.packets.MutationEvent mutation = 15;
inline bool InworldPacket::has_mutation() const {
  return packet_case() == kMutation;
}
inline bool InworldPacket::_internal_has_mutation() const {
  return packet_case() == kMutation;
}
inline void InworldPacket::set_has_mutation() {
  _impl_._oneof_case_[0] = kMutation;
}
inline void InworldPacket::clear_mutation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kMutation) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.mutation_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::release_mutation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.mutation)
  if (packet_case() == kMutation) {
    clear_has_packet();
    auto* temp = _impl_.packet_.mutation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::_internal_mutation() const {
  return packet_case() == kMutation ? *_impl_.packet_.mutation_ : reinterpret_cast<::ai::inworld::packets::MutationEvent&>(::ai::inworld::packets::_MutationEvent_default_instance_);
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::mutation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutation();
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::unsafe_arena_release_mutation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.mutation)
  if (packet_case() == kMutation) {
    clear_has_packet();
    auto* temp = _impl_.packet_.mutation_;
    _impl_.packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_mutation(::ai::inworld::packets::MutationEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_mutation();
    _impl_.packet_.mutation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.mutation)
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::_internal_mutable_mutation() {
  if (packet_case() != kMutation) {
    clear_packet();
    set_has_mutation();
    _impl_.packet_.mutation_ = CreateMaybeMessage<::ai::inworld::packets::MutationEvent>(GetArena());
  }
  return _impl_.packet_.mutation_;
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::mutable_mutation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::MutationEvent* _msg = _internal_mutable_mutation();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.mutation)
  return _msg;
}

// .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16 [deprecated = true];
inline bool InworldPacket::has_load_scene_output() const {
  return packet_case() == kLoadSceneOutput;
}
inline bool InworldPacket::_internal_has_load_scene_output() const {
  return packet_case() == kLoadSceneOutput;
}
inline void InworldPacket::set_has_load_scene_output() {
  _impl_._oneof_case_[0] = kLoadSceneOutput;
}
inline void InworldPacket::clear_load_scene_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kLoadSceneOutput) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.load_scene_output_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::release_load_scene_output() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (packet_case() == kLoadSceneOutput) {
    clear_has_packet();
    auto* temp = _impl_.packet_.load_scene_output_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::_internal_load_scene_output() const {
  return packet_case() == kLoadSceneOutput ? *_impl_.packet_.load_scene_output_ : reinterpret_cast<::ai::inworld::packets::LoadSceneOutputEvent&>(::ai::inworld::packets::_LoadSceneOutputEvent_default_instance_);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::load_scene_output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_load_scene_output();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::unsafe_arena_release_load_scene_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (packet_case() == kLoadSceneOutput) {
    clear_has_packet();
    auto* temp = _impl_.packet_.load_scene_output_;
    _impl_.packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_load_scene_output();
    _impl_.packet_.load_scene_output_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.load_scene_output)
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::_internal_mutable_load_scene_output() {
  if (packet_case() != kLoadSceneOutput) {
    clear_packet();
    set_has_load_scene_output();
    _impl_.packet_.load_scene_output_ = CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent>(GetArena());
  }
  return _impl_.packet_.load_scene_output_;
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::mutable_load_scene_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::LoadSceneOutputEvent* _msg = _internal_mutable_load_scene_output();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.load_scene_output)
  return _msg;
}

// .ai.inworld.packets.DebugInfoEvent debug_info = 18;
inline bool InworldPacket::has_debug_info() const {
  return packet_case() == kDebugInfo;
}
inline bool InworldPacket::_internal_has_debug_info() const {
  return packet_case() == kDebugInfo;
}
inline void InworldPacket::set_has_debug_info() {
  _impl_._oneof_case_[0] = kDebugInfo;
}
inline void InworldPacket::clear_debug_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kDebugInfo) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.debug_info_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::release_debug_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.debug_info)
  if (packet_case() == kDebugInfo) {
    clear_has_packet();
    auto* temp = _impl_.packet_.debug_info_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::_internal_debug_info() const {
  return packet_case() == kDebugInfo ? *_impl_.packet_.debug_info_ : reinterpret_cast<::ai::inworld::packets::DebugInfoEvent&>(::ai::inworld::packets::_DebugInfoEvent_default_instance_);
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::debug_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_debug_info();
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.debug_info)
  if (packet_case() == kDebugInfo) {
    clear_has_packet();
    auto* temp = _impl_.packet_.debug_info_;
    _impl_.packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_debug_info();
    _impl_.packet_.debug_info_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.debug_info)
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::_internal_mutable_debug_info() {
  if (packet_case() != kDebugInfo) {
    clear_packet();
    set_has_debug_info();
    _impl_.packet_.debug_info_ = CreateMaybeMessage<::ai::inworld::packets::DebugInfoEvent>(GetArena());
  }
  return _impl_.packet_.debug_info_;
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::mutable_debug_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::DebugInfoEvent* _msg = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.debug_info)
  return _msg;
}

// .ai.inworld.packets.SessionControlEvent session_control = 19;
inline bool InworldPacket::has_session_control() const {
  return packet_case() == kSessionControl;
}
inline bool InworldPacket::_internal_has_session_control() const {
  return packet_case() == kSessionControl;
}
inline void InworldPacket::set_has_session_control() {
  _impl_._oneof_case_[0] = kSessionControl;
}
inline void InworldPacket::clear_session_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kSessionControl) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.session_control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::release_session_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.session_control)
  if (packet_case() == kSessionControl) {
    clear_has_packet();
    auto* temp = _impl_.packet_.session_control_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.session_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionControlEvent& InworldPacket::_internal_session_control() const {
  return packet_case() == kSessionControl ? *_impl_.packet_.session_control_ : reinterpret_cast<::ai::inworld::packets::SessionControlEvent&>(::ai::inworld::packets::_SessionControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::SessionControlEvent& InworldPacket::session_control() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.session_control)
  return _internal_session_control();
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::unsafe_arena_release_session_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.session_control)
  if (packet_case() == kSessionControl) {
    clear_has_packet();
    auto* temp = _impl_.packet_.session_control_;
    _impl_.packet_.session_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_session_control(::ai::inworld::packets::SessionControlEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_session_control();
    _impl_.packet_.session_control_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.session_control)
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::_internal_mutable_session_control() {
  if (packet_case() != kSessionControl) {
    clear_packet();
    set_has_session_control();
    _impl_.packet_.session_control_ = CreateMaybeMessage<::ai::inworld::packets::SessionControlEvent>(GetArena());
  }
  return _impl_.packet_.session_control_;
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::mutable_session_control() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::SessionControlEvent* _msg = _internal_mutable_session_control();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.session_control)
  return _msg;
}

// .ai.inworld.packets.SessionControlResponseEvent session_control_response = 20;
inline bool InworldPacket::has_session_control_response() const {
  return packet_case() == kSessionControlResponse;
}
inline bool InworldPacket::_internal_has_session_control_response() const {
  return packet_case() == kSessionControlResponse;
}
inline void InworldPacket::set_has_session_control_response() {
  _impl_._oneof_case_[0] = kSessionControlResponse;
}
inline void InworldPacket::clear_session_control_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (packet_case() == kSessionControlResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.packet_.session_control_response_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::release_session_control_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.session_control_response)
  if (packet_case() == kSessionControlResponse) {
    clear_has_packet();
    auto* temp = _impl_.packet_.session_control_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.session_control_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionControlResponseEvent& InworldPacket::_internal_session_control_response() const {
  return packet_case() == kSessionControlResponse ? *_impl_.packet_.session_control_response_ : reinterpret_cast<::ai::inworld::packets::SessionControlResponseEvent&>(::ai::inworld::packets::_SessionControlResponseEvent_default_instance_);
}
inline const ::ai::inworld::packets::SessionControlResponseEvent& InworldPacket::session_control_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.session_control_response)
  return _internal_session_control_response();
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::unsafe_arena_release_session_control_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.session_control_response)
  if (packet_case() == kSessionControlResponse) {
    clear_has_packet();
    auto* temp = _impl_.packet_.session_control_response_;
    _impl_.packet_.session_control_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_session_control_response(::ai::inworld::packets::SessionControlResponseEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_packet();
  if (value) {
    set_has_session_control_response();
    _impl_.packet_.session_control_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.session_control_response)
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::_internal_mutable_session_control_response() {
  if (packet_case() != kSessionControlResponse) {
    clear_packet();
    set_has_session_control_response();
    _impl_.packet_.session_control_response_ = CreateMaybeMessage<::ai::inworld::packets::SessionControlResponseEvent>(GetArena());
  }
  return _impl_.packet_.session_control_response_;
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::mutable_session_control_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::SessionControlResponseEvent* _msg = _internal_mutable_session_control_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.session_control_response)
  return _msg;
}

inline bool InworldPacket::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void InworldPacket::clear_has_packet() {
  _impl_._oneof_case_[0] = PACKET_NOT_SET;
}
inline InworldPacket::PacketCase InworldPacket::packet_case() const {
  return InworldPacket::PacketCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextEvent_ModelInfo

// string service = 1;
inline void TextEvent_ModelInfo::clear_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::service() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _internal_service();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextEvent_ModelInfo::set_service(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.service_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline std::string* TextEvent_ModelInfo::mutable_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _s;
}
inline const std::string& TextEvent_ModelInfo::_internal_service() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.service_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_service(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.service_.Set(value, GetArena());
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.service_.Mutable( GetArena());
}
inline std::string* TextEvent_ModelInfo::release_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _impl_.service_.Release();
}
inline void TextEvent_ModelInfo::set_allocated_service(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.service_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_.IsDefault()) {
          _impl_.service_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.service)
}

// string model = 2;
inline void TextEvent_ModelInfo::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _internal_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextEvent_ModelInfo::set_model(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline std::string* TextEvent_ModelInfo::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _s;
}
inline const std::string& TextEvent_ModelInfo::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_model(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.model_.Set(value, GetArena());
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.model_.Mutable( GetArena());
}
inline std::string* TextEvent_ModelInfo::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _impl_.model_.Release();
}
inline void TextEvent_ModelInfo::set_allocated_model(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_.IsDefault()) {
          _impl_.model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.model)
}

// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextEvent::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.text)
  return _s;
}
inline const std::string& TextEvent::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* TextEvent::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* TextEvent::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.text)
  return _impl_.text_.Release();
}
inline void TextEvent::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.text)
}

// .ai.inworld.packets.TextEvent.SourceType source_type = 2;
inline void TextEvent::clear_source_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_type_ = 0;
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::source_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.source_type)
  return _internal_source_type();
}
inline void TextEvent::set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.source_type)
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::_internal_source_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::TextEvent_SourceType>(_impl_.source_type_);
}
inline void TextEvent::_internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_type_ = value;
}

// bool final = 3;
inline void TextEvent::clear_final() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.final_ = false;
}
inline bool TextEvent::final() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.final)
  return _internal_final();
}
inline void TextEvent::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.final)
}
inline bool TextEvent::_internal_final() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.final_;
}
inline void TextEvent::_internal_set_final(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.final_ = value;
}

// .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
inline bool TextEvent::has_model_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_info_ != nullptr);
  return value;
}
inline void TextEvent::clear_model_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_info_ != nullptr) _impl_.model_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::_internal_model_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::TextEvent_ModelInfo* p = _impl_.model_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::TextEvent_ModelInfo&>(::ai::inworld::packets::_TextEvent_ModelInfo_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::model_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.model_info)
  return _internal_model_info();
}
inline void TextEvent::unsafe_arena_set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.model_info_);
  }
  _impl_.model_info_ = reinterpret_cast<::ai::inworld::packets::TextEvent_ModelInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.TextEvent.model_info)
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::release_model_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::TextEvent_ModelInfo* released = _impl_.model_info_;
  _impl_.model_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::unsafe_arena_release_model_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.model_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::TextEvent_ModelInfo* temp = _impl_.model_info_;
  _impl_.model_info_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::_internal_mutable_model_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::TextEvent_ModelInfo>(GetArena());
    _impl_.model_info_ = reinterpret_cast<::ai::inworld::packets::TextEvent_ModelInfo*>(p);
  }
  return _impl_.model_info_;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::mutable_model_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::TextEvent_ModelInfo* _msg = _internal_mutable_model_info();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.model_info)
  return _msg;
}
inline void TextEvent::set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::TextEvent_ModelInfo*>(_impl_.model_info_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::TextEvent_ModelInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_info_ = reinterpret_cast<::ai::inworld::packets::TextEvent_ModelInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.model_info)
}

// -------------------------------------------------------------------

// ControlEvent

// .ai.inworld.packets.ControlEvent.Action action = 1;
inline void ControlEvent::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_ = 0;
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.action)
  return _internal_action();
}
inline void ControlEvent::set_action(::ai::inworld::packets::ControlEvent_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.action)
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::ControlEvent_Action>(_impl_.action_);
}
inline void ControlEvent::_internal_set_action(::ai::inworld::packets::ControlEvent_Action value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_ = value;
}

// string description = 2;
inline void ControlEvent::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ControlEvent::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControlEvent::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.description)
  return _s;
}
inline const std::string& ControlEvent::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void ControlEvent::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* ControlEvent::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* ControlEvent::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.description)
  return _impl_.description_.Release();
}
inline void ControlEvent::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.description)
}

// .google.protobuf.Struct payload = 3;
inline bool ControlEvent::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline const ::google::protobuf_inworld::Struct& ControlEvent::_internal_payload() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf_inworld::Struct* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf_inworld::Struct&>(::google::protobuf_inworld::_Struct_default_instance_);
}
inline const ::google::protobuf_inworld::Struct& ControlEvent::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.payload)
  return _internal_payload();
}
inline void ControlEvent::unsafe_arena_set_allocated_payload(::google::protobuf_inworld::Struct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::google::protobuf_inworld::Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.payload)
}
inline ::google::protobuf_inworld::Struct* ControlEvent::release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Struct* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf_inworld::Struct* ControlEvent::unsafe_arena_release_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.payload)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Struct* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::google::protobuf_inworld::Struct* ControlEvent::_internal_mutable_payload() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf_inworld::Struct>(GetArena());
    _impl_.payload_ = reinterpret_cast<::google::protobuf_inworld::Struct*>(p);
  }
  return _impl_.payload_;
}
inline ::google::protobuf_inworld::Struct* ControlEvent::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf_inworld::Struct* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.payload)
  return _msg;
}
inline void ControlEvent::set_allocated_payload(::google::protobuf_inworld::Struct* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.payload_ = reinterpret_cast<::google::protobuf_inworld::Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.payload)
}

// -------------------------------------------------------------------

// AudioChunk

// bytes chunk = 1;
inline void AudioChunk::clear_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_.ClearToEmpty();
}
inline const std::string& AudioChunk::chunk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioChunk.chunk)
  return _internal_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioChunk::set_chunk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::mutable_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AudioChunk.chunk)
  return _s;
}
inline const std::string& AudioChunk::_internal_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chunk_.Get();
}
inline void AudioChunk::_internal_set_chunk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chunk_.Set(value, GetArena());
}
inline std::string* AudioChunk::_internal_mutable_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.chunk_.Mutable( GetArena());
}
inline std::string* AudioChunk::release_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AudioChunk.chunk)
  return _impl_.chunk_.Release();
}
inline void AudioChunk::set_allocated_chunk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chunk_.IsDefault()) {
          _impl_.chunk_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AudioChunk.chunk)
}

// -------------------------------------------------------------------

// CustomEvent_Parameter

// string name = 1;
inline void CustomEvent_Parameter::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomEvent_Parameter::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.name)
  return _s;
}
inline const std::string& CustomEvent_Parameter::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CustomEvent_Parameter::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CustomEvent_Parameter::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CustomEvent_Parameter::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.name)
  return _impl_.name_.Release();
}
inline void CustomEvent_Parameter::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.name)
}

// string value = 2;
inline void CustomEvent_Parameter::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomEvent_Parameter::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.value)
  return _s;
}
inline const std::string& CustomEvent_Parameter::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void CustomEvent_Parameter::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* CustomEvent_Parameter::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* CustomEvent_Parameter::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.value)
  return _impl_.value_.Release();
}
inline void CustomEvent_Parameter::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.value)
}

// -------------------------------------------------------------------

// CustomEvent

// string name = 1;
inline void CustomEvent::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomEvent::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.name)
  return _s;
}
inline const std::string& CustomEvent::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CustomEvent::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CustomEvent::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.name)
  return _impl_.name_.Release();
}
inline void CustomEvent::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.name)
}

// .ai.inworld.packets.Playback playback = 2;
inline void CustomEvent::clear_playback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback CustomEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.playback)
  return _internal_playback();
}
inline void CustomEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.playback)
}
inline ::ai::inworld::packets::Playback CustomEvent::_internal_playback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::Playback>(_impl_.playback_);
}
inline void CustomEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playback_ = value;
}

// repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
inline int CustomEvent::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int CustomEvent::parameters_size() const {
  return _internal_parameters_size();
}
inline void CustomEvent::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::mutable_parameters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.parameters)
  return _internal_mutable_parameters()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>* CustomEvent::mutable_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CustomEvent.parameters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parameters();
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::parameters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.parameters)
  return _internal_parameters().Get(index);
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::add_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::CustomEvent_Parameter* _add = _internal_mutable_parameters()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CustomEvent.parameters)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>& CustomEvent::parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CustomEvent.parameters)
  return _internal_parameters();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>&
CustomEvent::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::CustomEvent_Parameter>*
CustomEvent::_internal_mutable_parameters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parameters_;
}

// -------------------------------------------------------------------

// CancelResponsesEvent

// string interaction_id = 1;
inline void CancelResponsesEvent::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponsesEvent::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelResponsesEvent::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void CancelResponsesEvent::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* CancelResponsesEvent::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* CancelResponsesEvent::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void CancelResponsesEvent::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponsesEvent::_internal_utterance_id_size() const {
  return _internal_utterance_id().size();
}
inline int CancelResponsesEvent::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponsesEvent::clear_utterance_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utterance_id_.Clear();
}
inline std::string* CancelResponsesEvent::add_utterance_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_utterance_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::utterance_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id().Get(index);
}
inline std::string* CancelResponsesEvent::mutable_utterance_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_mutable_utterance_id()->Mutable(index);
}
inline void CancelResponsesEvent::set_utterance_id(int index, const std::string& value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, std::string&& value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_utterance_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, absl::string_view value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline const ::google::protobuf_inworld::RepeatedPtrField<std::string>&
CancelResponsesEvent::utterance_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id();
}
inline ::google::protobuf_inworld::RepeatedPtrField<std::string>*
CancelResponsesEvent::mutable_utterance_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_utterance_id();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<std::string>&
CancelResponsesEvent::_internal_utterance_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterance_id_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<std::string>*
CancelResponsesEvent::_internal_mutable_utterance_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.utterance_id_;
}

// -------------------------------------------------------------------

// EmotionEvent

// float joy = 1;
inline void EmotionEvent::clear_joy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.joy_ = 0;
}
inline float EmotionEvent::joy() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.joy)
  return _internal_joy();
}
inline void EmotionEvent::set_joy(float value) {
  _internal_set_joy(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.joy)
}
inline float EmotionEvent::_internal_joy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.joy_;
}
inline void EmotionEvent::_internal_set_joy(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.joy_ = value;
}

// float fear = 2;
inline void EmotionEvent::clear_fear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fear_ = 0;
}
inline float EmotionEvent::fear() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.fear)
  return _internal_fear();
}
inline void EmotionEvent::set_fear(float value) {
  _internal_set_fear(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.fear)
}
inline float EmotionEvent::_internal_fear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fear_;
}
inline void EmotionEvent::_internal_set_fear(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fear_ = value;
}

// float trust = 3;
inline void EmotionEvent::clear_trust() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trust_ = 0;
}
inline float EmotionEvent::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.trust)
  return _internal_trust();
}
inline void EmotionEvent::set_trust(float value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.trust)
}
inline float EmotionEvent::_internal_trust() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trust_;
}
inline void EmotionEvent::_internal_set_trust(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trust_ = value;
}

// float surprise = 4;
inline void EmotionEvent::clear_surprise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.surprise_ = 0;
}
inline float EmotionEvent::surprise() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.surprise)
  return _internal_surprise();
}
inline void EmotionEvent::set_surprise(float value) {
  _internal_set_surprise(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.surprise)
}
inline float EmotionEvent::_internal_surprise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.surprise_;
}
inline void EmotionEvent::_internal_set_surprise(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.surprise_ = value;
}

// .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
inline void EmotionEvent::clear_behavior() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.behavior_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::behavior() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.behavior)
  return _internal_behavior();
}
inline void EmotionEvent::set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.behavior)
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::_internal_behavior() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::EmotionEvent_SpaffCode>(_impl_.behavior_);
}
inline void EmotionEvent::_internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.behavior_ = value;
}

// .ai.inworld.packets.EmotionEvent.Strength strength = 6;
inline void EmotionEvent::clear_strength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strength_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::strength() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.strength)
  return _internal_strength();
}
inline void EmotionEvent::set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.strength)
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::_internal_strength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::EmotionEvent_Strength>(_impl_.strength_);
}
inline void EmotionEvent::_internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.strength_ = value;
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk = 1;
inline bool DataChunk::has_chunk() const {
  return data_case() == kChunk;
}
inline void DataChunk::set_has_chunk() {
  _impl_._oneof_case_[0] = kChunk;
}
inline void DataChunk::clear_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kChunk) {
    _impl_.data_.chunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& DataChunk::chunk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.chunk)
  return _internal_chunk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DataChunk::set_chunk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kChunk) {
    clear_data();

    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::mutable_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.chunk)
  return _s;
}
inline const std::string& DataChunk::_internal_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kChunk) {
    return ::google::protobuf_inworld::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.chunk_.Get();
}
inline void DataChunk::_internal_set_chunk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kChunk) {
    clear_data();

    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.Set(value, GetArena());
}
inline std::string* DataChunk::_internal_mutable_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kChunk) {
    clear_data();

    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  return _impl_.data_.chunk_.Mutable( GetArena());
}
inline std::string* DataChunk::release_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DataChunk.chunk)
  if (data_case() != kChunk) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.chunk_.Release();
}
inline void DataChunk::set_allocated_chunk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_chunk();
    _impl_.data_.chunk_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DataChunk.chunk)
}

// int64 duration_ms = 3;
inline bool DataChunk::has_duration_ms() const {
  return data_case() == kDurationMs;
}
inline void DataChunk::set_has_duration_ms() {
  _impl_._oneof_case_[0] = kDurationMs;
}
inline void DataChunk::clear_duration_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kDurationMs) {
    _impl_.data_.duration_ms_ = ::int64_t{0};
    clear_has_data();
  }
}
inline ::int64_t DataChunk::duration_ms() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.duration_ms)
  return _internal_duration_ms();
}
inline void DataChunk::set_duration_ms(::int64_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.duration_ms)
}
inline ::int64_t DataChunk::_internal_duration_ms() const {
  if (data_case() == kDurationMs) {
    return _impl_.data_.duration_ms_;
  }
  return ::int64_t{0};
}
inline void DataChunk::_internal_set_duration_ms(::int64_t value) {
  if (data_case() != kDurationMs) {
    clear_data();
    set_has_duration_ms();
  }
  _impl_.data_.duration_ms_ = value;
}

// .ai.inworld.packets.DataChunk.DataType type = 2;
inline void DataChunk::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.type)
  return _internal_type();
}
inline void DataChunk::set_type(::ai::inworld::packets::DataChunk_DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.type)
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::DataChunk_DataType>(_impl_.type_);
}
inline void DataChunk::_internal_set_type(::ai::inworld::packets::DataChunk_DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
inline int DataChunk::_internal_additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info().size();
}
inline int DataChunk::additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info_size();
}
inline void DataChunk::clear_additional_phoneme_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_phoneme_info_.Clear();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::mutable_additional_phoneme_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_mutable_additional_phoneme_info()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>* DataChunk::mutable_additional_phoneme_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_additional_phoneme_info();
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::additional_phoneme_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info().Get(index);
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::add_additional_phoneme_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::AdditionalPhonemeInfo* _add = _internal_mutable_additional_phoneme_info()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>& DataChunk::additional_phoneme_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>&
DataChunk::_internal_additional_phoneme_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.additional_phoneme_info_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::AdditionalPhonemeInfo>*
DataChunk::_internal_mutable_additional_phoneme_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.additional_phoneme_info_;
}

// .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
inline void DataChunk::clear_audioformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audioformat_ = 0;
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::audioformat() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.audioFormat)
  return _internal_audioformat();
}
inline void DataChunk::set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  _internal_set_audioformat(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.audioFormat)
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::_internal_audioformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::DataChunk_AudioFormat>(_impl_.audioformat_);
}
inline void DataChunk::_internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audioformat_ = value;
}

inline bool DataChunk::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void DataChunk::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline DataChunk::DataCase DataChunk::data_case() const {
  return DataChunk::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdditionalPhonemeInfo

// string phoneme = 1;
inline void AdditionalPhonemeInfo::clear_phoneme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phoneme_.ClearToEmpty();
}
inline const std::string& AdditionalPhonemeInfo::phoneme() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_phoneme();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdditionalPhonemeInfo::set_phoneme(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.phoneme_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::mutable_phoneme() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phoneme();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _s;
}
inline const std::string& AdditionalPhonemeInfo::_internal_phoneme() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phoneme_.Get();
}
inline void AdditionalPhonemeInfo::_internal_set_phoneme(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.phoneme_.Set(value, GetArena());
}
inline std::string* AdditionalPhonemeInfo::_internal_mutable_phoneme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.phoneme_.Mutable( GetArena());
}
inline std::string* AdditionalPhonemeInfo::release_phoneme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _impl_.phoneme_.Release();
}
inline void AdditionalPhonemeInfo::set_allocated_phoneme(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phoneme_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phoneme_.IsDefault()) {
          _impl_.phoneme_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}

// .google.protobuf.Duration start_offset = 2;
inline bool AdditionalPhonemeInfo::has_start_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_offset_ != nullptr);
  return value;
}
inline const ::google::protobuf_inworld::Duration& AdditionalPhonemeInfo::_internal_start_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf_inworld::Duration* p = _impl_.start_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf_inworld::Duration&>(::google::protobuf_inworld::_Duration_default_instance_);
}
inline const ::google::protobuf_inworld::Duration& AdditionalPhonemeInfo::start_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_start_offset();
}
inline void AdditionalPhonemeInfo::unsafe_arena_set_allocated_start_offset(::google::protobuf_inworld::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.start_offset_);
  }
  _impl_.start_offset_ = reinterpret_cast<::google::protobuf_inworld::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}
inline ::google::protobuf_inworld::Duration* AdditionalPhonemeInfo::release_start_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Duration* released = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf_inworld::Duration* AdditionalPhonemeInfo::unsafe_arena_release_start_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Duration* temp = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
  return temp;
}
inline ::google::protobuf_inworld::Duration* AdditionalPhonemeInfo::_internal_mutable_start_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf_inworld::Duration>(GetArena());
    _impl_.start_offset_ = reinterpret_cast<::google::protobuf_inworld::Duration*>(p);
  }
  return _impl_.start_offset_;
}
inline ::google::protobuf_inworld::Duration* AdditionalPhonemeInfo::mutable_start_offset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf_inworld::Duration* _msg = _internal_mutable_start_offset();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _msg;
}
inline void AdditionalPhonemeInfo::set_allocated_start_offset(::google::protobuf_inworld::Duration* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.start_offset_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_offset_ = reinterpret_cast<::google::protobuf_inworld::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}

// -------------------------------------------------------------------

// ActionEvent

// .ai.inworld.packets.NarratedAction narrated_action = 1;
inline bool ActionEvent::has_narrated_action() const {
  return action_case() == kNarratedAction;
}
inline bool ActionEvent::_internal_has_narrated_action() const {
  return action_case() == kNarratedAction;
}
inline void ActionEvent::set_has_narrated_action() {
  _impl_._oneof_case_[0] = kNarratedAction;
}
inline void ActionEvent::clear_narrated_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNarratedAction) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.narrated_action_;
    }
    clear_has_action();
  }
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::release_narrated_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (action_case() == kNarratedAction) {
    clear_has_action();
    auto* temp = _impl_.action_.narrated_action_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::_internal_narrated_action() const {
  return action_case() == kNarratedAction ? *_impl_.action_.narrated_action_ : reinterpret_cast<::ai::inworld::packets::NarratedAction&>(::ai::inworld::packets::_NarratedAction_default_instance_);
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::narrated_action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_narrated_action();
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::unsafe_arena_release_narrated_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (action_case() == kNarratedAction) {
    clear_has_action();
    auto* temp = _impl_.action_.narrated_action_;
    _impl_.action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionEvent::unsafe_arena_set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_narrated_action();
    _impl_.action_.narrated_action_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ActionEvent.narrated_action)
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::_internal_mutable_narrated_action() {
  if (action_case() != kNarratedAction) {
    clear_action();
    set_has_narrated_action();
    _impl_.action_.narrated_action_ = CreateMaybeMessage<::ai::inworld::packets::NarratedAction>(GetArena());
  }
  return _impl_.action_.narrated_action_;
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::mutable_narrated_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::NarratedAction* _msg = _internal_mutable_narrated_action();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ActionEvent.narrated_action)
  return _msg;
}

// .ai.inworld.packets.Playback playback = 2;
inline void ActionEvent::clear_playback() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback ActionEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.playback)
  return _internal_playback();
}
inline void ActionEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ActionEvent.playback)
}
inline ::ai::inworld::packets::Playback ActionEvent::_internal_playback() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::Playback>(_impl_.playback_);
}
inline void ActionEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playback_ = value;
}

inline bool ActionEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionEvent::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionEvent::ActionCase ActionEvent::action_case() const {
  return ActionEvent::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NarratedAction

// string content = 1;
inline void NarratedAction::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& NarratedAction::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.NarratedAction.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NarratedAction::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.NarratedAction.content)
  return _s;
}
inline const std::string& NarratedAction::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void NarratedAction::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* NarratedAction::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* NarratedAction::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.NarratedAction.content)
  return _impl_.content_.Release();
}
inline void NarratedAction::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.NarratedAction.content)
}

// -------------------------------------------------------------------

// RelationInfo_RelationAttributes

// int32 trust = 1;
inline void RelationInfo_RelationAttributes::clear_trust() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trust_ = 0;
}
inline ::int32_t RelationInfo_RelationAttributes::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
  return _internal_trust();
}
inline void RelationInfo_RelationAttributes::set_trust(::int32_t value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
}
inline ::int32_t RelationInfo_RelationAttributes::_internal_trust() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trust_;
}
inline void RelationInfo_RelationAttributes::_internal_set_trust(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trust_ = value;
}

// int32 respect = 2;
inline void RelationInfo_RelationAttributes::clear_respect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.respect_ = 0;
}
inline ::int32_t RelationInfo_RelationAttributes::respect() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
  return _internal_respect();
}
inline void RelationInfo_RelationAttributes::set_respect(::int32_t value) {
  _internal_set_respect(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
}
inline ::int32_t RelationInfo_RelationAttributes::_internal_respect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.respect_;
}
inline void RelationInfo_RelationAttributes::_internal_set_respect(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.respect_ = value;
}

// int32 familiar = 3;
inline void RelationInfo_RelationAttributes::clear_familiar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.familiar_ = 0;
}
inline ::int32_t RelationInfo_RelationAttributes::familiar() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
  return _internal_familiar();
}
inline void RelationInfo_RelationAttributes::set_familiar(::int32_t value) {
  _internal_set_familiar(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
}
inline ::int32_t RelationInfo_RelationAttributes::_internal_familiar() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.familiar_;
}
inline void RelationInfo_RelationAttributes::_internal_set_familiar(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.familiar_ = value;
}

// int32 flirtatious = 4;
inline void RelationInfo_RelationAttributes::clear_flirtatious() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flirtatious_ = 0;
}
inline ::int32_t RelationInfo_RelationAttributes::flirtatious() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
  return _internal_flirtatious();
}
inline void RelationInfo_RelationAttributes::set_flirtatious(::int32_t value) {
  _internal_set_flirtatious(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
}
inline ::int32_t RelationInfo_RelationAttributes::_internal_flirtatious() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flirtatious_;
}
inline void RelationInfo_RelationAttributes::_internal_set_flirtatious(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flirtatious_ = value;
}

// int32 attraction = 5;
inline void RelationInfo_RelationAttributes::clear_attraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attraction_ = 0;
}
inline ::int32_t RelationInfo_RelationAttributes::attraction() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
  return _internal_attraction();
}
inline void RelationInfo_RelationAttributes::set_attraction(::int32_t value) {
  _internal_set_attraction(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
}
inline ::int32_t RelationInfo_RelationAttributes::_internal_attraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attraction_;
}
inline void RelationInfo_RelationAttributes::_internal_set_attraction(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attraction_ = value;
}

// -------------------------------------------------------------------

// RelationInfo

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
inline bool RelationInfo::has_relation_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relation_state_ != nullptr);
  return value;
}
inline void RelationInfo::clear_relation_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.relation_state_ != nullptr) _impl_.relation_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = _impl_.relation_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_relation_state();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.relation_state_);
  }
  _impl_.relation_state_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* released = _impl_.relation_state_;
  _impl_.relation_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_state_;
  _impl_.relation_state_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.relation_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    _impl_.relation_state_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(p);
  }
  return _impl_.relation_state_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _msg = _internal_mutable_relation_state();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_state)
  return _msg;
}
inline void RelationInfo::set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(_impl_.relation_state_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.relation_state_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
inline bool RelationInfo::has_relation_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relation_update_ != nullptr);
  return value;
}
inline void RelationInfo::clear_relation_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.relation_update_ != nullptr) _impl_.relation_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_update() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = _impl_.relation_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_relation_update();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.relation_update_);
  }
  _impl_.relation_update_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* released = _impl_.relation_update_;
  _impl_.relation_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_update)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_update_;
  _impl_.relation_update_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.relation_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    _impl_.relation_update_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(p);
  }
  return _impl_.relation_update_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _msg = _internal_mutable_relation_update();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_update)
  return _msg;
}
inline void RelationInfo::set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(_impl_.relation_update_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.relation_update_ = reinterpret_cast<::ai::inworld::packets::RelationInfo_RelationAttributes*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}

// -------------------------------------------------------------------

// MutationEvent

// .ai.inworld.packets.CancelResponses cancel_responses = 1;
inline bool MutationEvent::has_cancel_responses() const {
  return mutation_case() == kCancelResponses;
}
inline bool MutationEvent::_internal_has_cancel_responses() const {
  return mutation_case() == kCancelResponses;
}
inline void MutationEvent::set_has_cancel_responses() {
  _impl_._oneof_case_[0] = kCancelResponses;
}
inline void MutationEvent::clear_cancel_responses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kCancelResponses) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.cancel_responses_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::release_cancel_responses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (mutation_case() == kCancelResponses) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.cancel_responses_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::_internal_cancel_responses() const {
  return mutation_case() == kCancelResponses ? *_impl_.mutation_.cancel_responses_ : reinterpret_cast<::ai::inworld::packets::CancelResponses&>(::ai::inworld::packets::_CancelResponses_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::cancel_responses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_cancel_responses();
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::unsafe_arena_release_cancel_responses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (mutation_case() == kCancelResponses) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.cancel_responses_;
    _impl_.mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_cancel_responses();
    _impl_.mutation_.cancel_responses_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.cancel_responses)
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::_internal_mutable_cancel_responses() {
  if (mutation_case() != kCancelResponses) {
    clear_mutation();
    set_has_cancel_responses();
    _impl_.mutation_.cancel_responses_ = CreateMaybeMessage<::ai::inworld::packets::CancelResponses>(GetArena());
  }
  return _impl_.mutation_.cancel_responses_;
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::mutable_cancel_responses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::CancelResponses* _msg = _internal_mutable_cancel_responses();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.cancel_responses)
  return _msg;
}

// .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
inline bool MutationEvent::has_regenerate_response() const {
  return mutation_case() == kRegenerateResponse;
}
inline bool MutationEvent::_internal_has_regenerate_response() const {
  return mutation_case() == kRegenerateResponse;
}
inline void MutationEvent::set_has_regenerate_response() {
  _impl_._oneof_case_[0] = kRegenerateResponse;
}
inline void MutationEvent::clear_regenerate_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kRegenerateResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.regenerate_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::release_regenerate_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (mutation_case() == kRegenerateResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.regenerate_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::_internal_regenerate_response() const {
  return mutation_case() == kRegenerateResponse ? *_impl_.mutation_.regenerate_response_ : reinterpret_cast<::ai::inworld::packets::RegenerateResponse&>(::ai::inworld::packets::_RegenerateResponse_default_instance_);
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::regenerate_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_regenerate_response();
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::unsafe_arena_release_regenerate_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (mutation_case() == kRegenerateResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.regenerate_response_;
    _impl_.mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_regenerate_response();
    _impl_.mutation_.regenerate_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.regenerate_response)
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::_internal_mutable_regenerate_response() {
  if (mutation_case() != kRegenerateResponse) {
    clear_mutation();
    set_has_regenerate_response();
    _impl_.mutation_.regenerate_response_ = CreateMaybeMessage<::ai::inworld::packets::RegenerateResponse>(GetArena());
  }
  return _impl_.mutation_.regenerate_response_;
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::mutable_regenerate_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::RegenerateResponse* _msg = _internal_mutable_regenerate_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.regenerate_response)
  return _msg;
}

// .ai.inworld.packets.ApplyResponse apply_response = 3;
inline bool MutationEvent::has_apply_response() const {
  return mutation_case() == kApplyResponse;
}
inline bool MutationEvent::_internal_has_apply_response() const {
  return mutation_case() == kApplyResponse;
}
inline void MutationEvent::set_has_apply_response() {
  _impl_._oneof_case_[0] = kApplyResponse;
}
inline void MutationEvent::clear_apply_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kApplyResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.apply_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::release_apply_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.apply_response)
  if (mutation_case() == kApplyResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.apply_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::_internal_apply_response() const {
  return mutation_case() == kApplyResponse ? *_impl_.mutation_.apply_response_ : reinterpret_cast<::ai::inworld::packets::ApplyResponse&>(::ai::inworld::packets::_ApplyResponse_default_instance_);
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::apply_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_apply_response();
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::unsafe_arena_release_apply_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.apply_response)
  if (mutation_case() == kApplyResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.apply_response_;
    _impl_.mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_apply_response();
    _impl_.mutation_.apply_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.apply_response)
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::_internal_mutable_apply_response() {
  if (mutation_case() != kApplyResponse) {
    clear_mutation();
    set_has_apply_response();
    _impl_.mutation_.apply_response_ = CreateMaybeMessage<::ai::inworld::packets::ApplyResponse>(GetArena());
  }
  return _impl_.mutation_.apply_response_;
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::mutable_apply_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::ApplyResponse* _msg = _internal_mutable_apply_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.apply_response)
  return _msg;
}

// .ai.inworld.packets.LoadScene load_scene = 4;
inline bool MutationEvent::has_load_scene() const {
  return mutation_case() == kLoadScene;
}
inline bool MutationEvent::_internal_has_load_scene() const {
  return mutation_case() == kLoadScene;
}
inline void MutationEvent::set_has_load_scene() {
  _impl_._oneof_case_[0] = kLoadScene;
}
inline void MutationEvent::clear_load_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kLoadScene) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.load_scene_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::release_load_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_scene)
  if (mutation_case() == kLoadScene) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.load_scene_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::_internal_load_scene() const {
  return mutation_case() == kLoadScene ? *_impl_.mutation_.load_scene_ : reinterpret_cast<::ai::inworld::packets::LoadScene&>(::ai::inworld::packets::_LoadScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::load_scene() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_load_scene();
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::unsafe_arena_release_load_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_scene)
  if (mutation_case() == kLoadScene) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.load_scene_;
    _impl_.mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_scene(::ai::inworld::packets::LoadScene* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_load_scene();
    _impl_.mutation_.load_scene_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_scene)
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::_internal_mutable_load_scene() {
  if (mutation_case() != kLoadScene) {
    clear_mutation();
    set_has_load_scene();
    _impl_.mutation_.load_scene_ = CreateMaybeMessage<::ai::inworld::packets::LoadScene>(GetArena());
  }
  return _impl_.mutation_.load_scene_;
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::mutable_load_scene() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::LoadScene* _msg = _internal_mutable_load_scene();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_scene)
  return _msg;
}

// .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
inline bool MutationEvent::has_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse;
}
inline bool MutationEvent::_internal_has_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse;
}
inline void MutationEvent::set_has_modify_exact_response() {
  _impl_._oneof_case_[0] = kModifyExactResponse;
}
inline void MutationEvent::clear_modify_exact_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kModifyExactResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.modify_exact_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::release_modify_exact_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (mutation_case() == kModifyExactResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.modify_exact_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::_internal_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse ? *_impl_.mutation_.modify_exact_response_ : reinterpret_cast<::ai::inworld::packets::ModifyExactResponse&>(::ai::inworld::packets::_ModifyExactResponse_default_instance_);
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::modify_exact_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_modify_exact_response();
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::unsafe_arena_release_modify_exact_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (mutation_case() == kModifyExactResponse) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.modify_exact_response_;
    _impl_.mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_modify_exact_response();
    _impl_.mutation_.modify_exact_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.modify_exact_response)
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::_internal_mutable_modify_exact_response() {
  if (mutation_case() != kModifyExactResponse) {
    clear_mutation();
    set_has_modify_exact_response();
    _impl_.mutation_.modify_exact_response_ = CreateMaybeMessage<::ai::inworld::packets::ModifyExactResponse>(GetArena());
  }
  return _impl_.mutation_.modify_exact_response_;
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::mutable_modify_exact_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::ModifyExactResponse* _msg = _internal_mutable_modify_exact_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _msg;
}

// .ai.inworld.packets.LoadCharacters load_characters = 6;
inline bool MutationEvent::has_load_characters() const {
  return mutation_case() == kLoadCharacters;
}
inline bool MutationEvent::_internal_has_load_characters() const {
  return mutation_case() == kLoadCharacters;
}
inline void MutationEvent::set_has_load_characters() {
  _impl_._oneof_case_[0] = kLoadCharacters;
}
inline void MutationEvent::clear_load_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mutation_case() == kLoadCharacters) {
    if (GetArena() == nullptr) {
      delete _impl_.mutation_.load_characters_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::release_load_characters() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_characters)
  if (mutation_case() == kLoadCharacters) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.load_characters_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.load_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadCharacters& MutationEvent::_internal_load_characters() const {
  return mutation_case() == kLoadCharacters ? *_impl_.mutation_.load_characters_ : reinterpret_cast<::ai::inworld::packets::LoadCharacters&>(::ai::inworld::packets::_LoadCharacters_default_instance_);
}
inline const ::ai::inworld::packets::LoadCharacters& MutationEvent::load_characters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_characters)
  return _internal_load_characters();
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::unsafe_arena_release_load_characters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_characters)
  if (mutation_case() == kLoadCharacters) {
    clear_has_mutation();
    auto* temp = _impl_.mutation_.load_characters_;
    _impl_.mutation_.load_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_characters(::ai::inworld::packets::LoadCharacters* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mutation();
  if (value) {
    set_has_load_characters();
    _impl_.mutation_.load_characters_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_characters)
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::_internal_mutable_load_characters() {
  if (mutation_case() != kLoadCharacters) {
    clear_mutation();
    set_has_load_characters();
    _impl_.mutation_.load_characters_ = CreateMaybeMessage<::ai::inworld::packets::LoadCharacters>(GetArena());
  }
  return _impl_.mutation_.load_characters_;
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::mutable_load_characters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::LoadCharacters* _msg = _internal_mutable_load_characters();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_characters)
  return _msg;
}

inline bool MutationEvent::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void MutationEvent::clear_has_mutation() {
  _impl_._oneof_case_[0] = MUTATION_NOT_SET;
}
inline MutationEvent::MutationCase MutationEvent::mutation_case() const {
  return MutationEvent::MutationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionControlResponseEvent

// .ai.inworld.packets.LoadedScene loaded_scene = 1;
inline bool SessionControlResponseEvent::has_loaded_scene() const {
  return response_case() == kLoadedScene;
}
inline bool SessionControlResponseEvent::_internal_has_loaded_scene() const {
  return response_case() == kLoadedScene;
}
inline void SessionControlResponseEvent::set_has_loaded_scene() {
  _impl_._oneof_case_[0] = kLoadedScene;
}
inline void SessionControlResponseEvent::clear_loaded_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_case() == kLoadedScene) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.loaded_scene_;
    }
    clear_has_response();
  }
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::release_loaded_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  if (response_case() == kLoadedScene) {
    clear_has_response();
    auto* temp = _impl_.response_.loaded_scene_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.loaded_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadedScene& SessionControlResponseEvent::_internal_loaded_scene() const {
  return response_case() == kLoadedScene ? *_impl_.response_.loaded_scene_ : reinterpret_cast<::ai::inworld::packets::LoadedScene&>(::ai::inworld::packets::_LoadedScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadedScene& SessionControlResponseEvent::loaded_scene() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  return _internal_loaded_scene();
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::unsafe_arena_release_loaded_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  if (response_case() == kLoadedScene) {
    clear_has_response();
    auto* temp = _impl_.response_.loaded_scene_;
    _impl_.response_.loaded_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlResponseEvent::unsafe_arena_set_allocated_loaded_scene(::ai::inworld::packets::LoadedScene* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_loaded_scene();
    _impl_.response_.loaded_scene_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::_internal_mutable_loaded_scene() {
  if (response_case() != kLoadedScene) {
    clear_response();
    set_has_loaded_scene();
    _impl_.response_.loaded_scene_ = CreateMaybeMessage<::ai::inworld::packets::LoadedScene>(GetArena());
  }
  return _impl_.response_.loaded_scene_;
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::mutable_loaded_scene() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::LoadedScene* _msg = _internal_mutable_loaded_scene();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  return _msg;
}

// .ai.inworld.packets.LoadedCharacters loaded_characters = 2;
inline bool SessionControlResponseEvent::has_loaded_characters() const {
  return response_case() == kLoadedCharacters;
}
inline bool SessionControlResponseEvent::_internal_has_loaded_characters() const {
  return response_case() == kLoadedCharacters;
}
inline void SessionControlResponseEvent::set_has_loaded_characters() {
  _impl_._oneof_case_[0] = kLoadedCharacters;
}
inline void SessionControlResponseEvent::clear_loaded_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (response_case() == kLoadedCharacters) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.loaded_characters_;
    }
    clear_has_response();
  }
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::release_loaded_characters() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  if (response_case() == kLoadedCharacters) {
    clear_has_response();
    auto* temp = _impl_.response_.loaded_characters_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.loaded_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadedCharacters& SessionControlResponseEvent::_internal_loaded_characters() const {
  return response_case() == kLoadedCharacters ? *_impl_.response_.loaded_characters_ : reinterpret_cast<::ai::inworld::packets::LoadedCharacters&>(::ai::inworld::packets::_LoadedCharacters_default_instance_);
}
inline const ::ai::inworld::packets::LoadedCharacters& SessionControlResponseEvent::loaded_characters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  return _internal_loaded_characters();
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::unsafe_arena_release_loaded_characters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  if (response_case() == kLoadedCharacters) {
    clear_has_response();
    auto* temp = _impl_.response_.loaded_characters_;
    _impl_.response_.loaded_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlResponseEvent::unsafe_arena_set_allocated_loaded_characters(::ai::inworld::packets::LoadedCharacters* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_loaded_characters();
    _impl_.response_.loaded_characters_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::_internal_mutable_loaded_characters() {
  if (response_case() != kLoadedCharacters) {
    clear_response();
    set_has_loaded_characters();
    _impl_.response_.loaded_characters_ = CreateMaybeMessage<::ai::inworld::packets::LoadedCharacters>(GetArena());
  }
  return _impl_.response_.loaded_characters_;
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::mutable_loaded_characters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::LoadedCharacters* _msg = _internal_mutable_loaded_characters();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  return _msg;
}

inline bool SessionControlResponseEvent::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void SessionControlResponseEvent::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline SessionControlResponseEvent::ResponseCase SessionControlResponseEvent::response_case() const {
  return SessionControlResponseEvent::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CancelResponses

// string interaction_id = 1;
inline void CancelResponses::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponses::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelResponses::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.interaction_id)
  return _s;
}
inline const std::string& CancelResponses::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void CancelResponses::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* CancelResponses::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* CancelResponses::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponses.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void CancelResponses::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponses.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponses::_internal_utterance_id_size() const {
  return _internal_utterance_id().size();
}
inline int CancelResponses::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponses::clear_utterance_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utterance_id_.Clear();
}
inline std::string* CancelResponses::add_utterance_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_utterance_id()->Add();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _s;
}
inline const std::string& CancelResponses::utterance_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_utterance_id().Get(index);
}
inline std::string* CancelResponses::mutable_utterance_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_mutable_utterance_id()->Mutable(index);
}
inline void CancelResponses::set_utterance_id(int index, const std::string& value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, std::string&& value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_utterance_id()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, absl::string_view value) {
  _internal_mutable_utterance_id()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_utterance_id()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ai.inworld.packets.CancelResponses.utterance_id)
}
inline const ::google::protobuf_inworld::RepeatedPtrField<std::string>&
CancelResponses::utterance_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_utterance_id();
}
inline ::google::protobuf_inworld::RepeatedPtrField<std::string>*
CancelResponses::mutable_utterance_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponses.utterance_id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_utterance_id();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<std::string>&
CancelResponses::_internal_utterance_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utterance_id_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<std::string>*
CancelResponses::_internal_mutable_utterance_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.utterance_id_;
}

// -------------------------------------------------------------------

// RegenerateResponse

// string interaction_id = 1;
inline void RegenerateResponse::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& RegenerateResponse::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegenerateResponse::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _s;
}
inline const std::string& RegenerateResponse::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void RegenerateResponse::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* RegenerateResponse::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* RegenerateResponse::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void RegenerateResponse::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RegenerateResponse.interaction_id)
}

// -------------------------------------------------------------------

// ApplyResponse

// .ai.inworld.packets.PacketId packet_id = 1;
inline bool ApplyResponse::has_packet_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_id_ != nullptr);
  return value;
}
inline void ApplyResponse::clear_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_id_ != nullptr) _impl_.packet_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::_internal_packet_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::packet_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_packet_id();
}
inline void ApplyResponse::unsafe_arena_set_allocated_packet_id(::ai::inworld::packets::PacketId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::release_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::PacketId* released = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::unsafe_arena_release_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ApplyResponse.packet_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::_internal_mutable_packet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(p);
  }
  return _impl_.packet_id_;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::mutable_packet_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ApplyResponse.packet_id)
  return _msg;
}
inline void ApplyResponse::set_allocated_packet_id(::ai::inworld::packets::PacketId* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::PacketId*>(_impl_.packet_id_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::PacketId*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.packet_id_ = reinterpret_cast<::ai::inworld::packets::PacketId*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}

// -------------------------------------------------------------------

// LoadScene

// string name = 1;
inline void LoadScene::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoadScene::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadScene.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadScene::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadScene.name)
  return _s;
}
inline const std::string& LoadScene::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void LoadScene::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* LoadScene::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* LoadScene::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadScene.name)
  return _impl_.name_.Release();
}
inline void LoadScene::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadScene.name)
}

// -------------------------------------------------------------------

// LoadedScene

// repeated .ai.inworld.packets.Agent agents = 1;
inline int LoadedScene::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int LoadedScene::agents_size() const {
  return _internal_agents_size();
}
inline void LoadedScene::clear_agents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agents_.Clear();
}
inline ::ai::inworld::packets::Agent* LoadedScene::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedScene.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* LoadedScene::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadedScene.agents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_agents();
}
inline const ::ai::inworld::packets::Agent& LoadedScene::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedScene.agents)
  return _internal_agents().Get(index);
}
inline ::ai::inworld::packets::Agent* LoadedScene::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadedScene.agents)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& LoadedScene::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadedScene.agents)
  return _internal_agents();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>&
LoadedScene::_internal_agents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agents_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>*
LoadedScene::_internal_mutable_agents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.agents_;
}

// -------------------------------------------------------------------

// LoadCharacters_CharacterName

// string name = 1;
inline void LoadCharacters_CharacterName::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoadCharacters_CharacterName::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadCharacters_CharacterName::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadCharacters.CharacterName.name)
}
inline std::string* LoadCharacters_CharacterName::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return _s;
}
inline const std::string& LoadCharacters_CharacterName::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void LoadCharacters_CharacterName::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* LoadCharacters_CharacterName::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* LoadCharacters_CharacterName::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return _impl_.name_.Release();
}
inline void LoadCharacters_CharacterName::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadCharacters.CharacterName.name)
}

// .ai.inworld.language_codes.LanguageCode language_code = 2;
inline void LoadCharacters_CharacterName::clear_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_code_ = 0;
}
inline ::ai::inworld::language_codes::LanguageCode LoadCharacters_CharacterName::language_code() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.CharacterName.language_code)
  return _internal_language_code();
}
inline void LoadCharacters_CharacterName::set_language_code(::ai::inworld::language_codes::LanguageCode value) {
  _internal_set_language_code(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadCharacters.CharacterName.language_code)
}
inline ::ai::inworld::language_codes::LanguageCode LoadCharacters_CharacterName::_internal_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::language_codes::LanguageCode>(_impl_.language_code_);
}
inline void LoadCharacters_CharacterName::_internal_set_language_code(::ai::inworld::language_codes::LanguageCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_code_ = value;
}

// -------------------------------------------------------------------

// LoadCharacters

// repeated .ai.inworld.packets.LoadCharacters.CharacterName name = 1;
inline int LoadCharacters::_internal_name_size() const {
  return _internal_name().size();
}
inline int LoadCharacters::name_size() const {
  return _internal_name_size();
}
inline void LoadCharacters::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.Clear();
}
inline ::ai::inworld::packets::LoadCharacters_CharacterName* LoadCharacters::mutable_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadCharacters.name)
  return _internal_mutable_name()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>* LoadCharacters::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadCharacters.name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_name();
}
inline const ::ai::inworld::packets::LoadCharacters_CharacterName& LoadCharacters::name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.name)
  return _internal_name().Get(index);
}
inline ::ai::inworld::packets::LoadCharacters_CharacterName* LoadCharacters::add_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::LoadCharacters_CharacterName* _add = _internal_mutable_name()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadCharacters.name)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>& LoadCharacters::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadCharacters.name)
  return _internal_name();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>&
LoadCharacters::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadCharacters_CharacterName>*
LoadCharacters::_internal_mutable_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.name_;
}

// -------------------------------------------------------------------

// LoadedCharacters

// repeated .ai.inworld.packets.Agent agents = 1;
inline int LoadedCharacters::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int LoadedCharacters::agents_size() const {
  return _internal_agents_size();
}
inline void LoadedCharacters::clear_agents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agents_.Clear();
}
inline ::ai::inworld::packets::Agent* LoadedCharacters::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedCharacters.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* LoadedCharacters::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadedCharacters.agents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_agents();
}
inline const ::ai::inworld::packets::Agent& LoadedCharacters::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedCharacters.agents)
  return _internal_agents().Get(index);
}
inline ::ai::inworld::packets::Agent* LoadedCharacters::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadedCharacters.agents)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& LoadedCharacters::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadedCharacters.agents)
  return _internal_agents();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>&
LoadedCharacters::_internal_agents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agents_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>*
LoadedCharacters::_internal_mutable_agents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.agents_;
}

// -------------------------------------------------------------------

// UnloadCharacters

// repeated .ai.inworld.packets.Agent agents = 1;
inline int UnloadCharacters::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int UnloadCharacters::agents_size() const {
  return _internal_agents_size();
}
inline void UnloadCharacters::clear_agents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agents_.Clear();
}
inline ::ai::inworld::packets::Agent* UnloadCharacters::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.UnloadCharacters.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>* UnloadCharacters::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.UnloadCharacters.agents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_agents();
}
inline const ::ai::inworld::packets::Agent& UnloadCharacters::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.UnloadCharacters.agents)
  return _internal_agents().Get(index);
}
inline ::ai::inworld::packets::Agent* UnloadCharacters::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.UnloadCharacters.agents)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>& UnloadCharacters::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.UnloadCharacters.agents)
  return _internal_agents();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>&
UnloadCharacters::_internal_agents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agents_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Agent>*
UnloadCharacters::_internal_mutable_agents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.agents_;
}

// -------------------------------------------------------------------

// ModifyExactResponse

// string interaction_id = 1;
inline void ModifyExactResponse::clear_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::interaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModifyExactResponse::set_interaction_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::mutable_interaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _s;
}
inline const std::string& ModifyExactResponse::_internal_interaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_id_.Get();
}
inline void ModifyExactResponse::_internal_set_interaction_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_id_.Set(value, GetArena());
}
inline std::string* ModifyExactResponse::_internal_mutable_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_id_.Mutable( GetArena());
}
inline std::string* ModifyExactResponse::release_interaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void ModifyExactResponse::set_allocated_interaction_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_id_.IsDefault()) {
          _impl_.interaction_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.interaction_id)
}

// string exact_text = 2;
inline void ModifyExactResponse::clear_exact_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exact_text_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::exact_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_exact_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModifyExactResponse::set_exact_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exact_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::mutable_exact_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_exact_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _s;
}
inline const std::string& ModifyExactResponse::_internal_exact_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exact_text_.Get();
}
inline void ModifyExactResponse::_internal_set_exact_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exact_text_.Set(value, GetArena());
}
inline std::string* ModifyExactResponse::_internal_mutable_exact_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.exact_text_.Mutable( GetArena());
}
inline std::string* ModifyExactResponse::release_exact_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _impl_.exact_text_.Release();
}
inline void ModifyExactResponse::set_allocated_exact_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exact_text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.exact_text_.IsDefault()) {
          _impl_.exact_text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.exact_text)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent_Agent

// string agent_id = 1;
inline void LoadSceneOutputEvent_Agent::clear_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadSceneOutputEvent_Agent::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_agent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agent_id_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_agent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _impl_.agent_id_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_agent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.agent_id_.IsDefault()) {
          _impl_.agent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}

// string brain_name = 2;
inline void LoadSceneOutputEvent_Agent::clear_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brain_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::brain_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_brain_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadSceneOutputEvent_Agent::set_brain_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brain_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_brain_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brain_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_brain_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brain_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_brain_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brain_name_.Set(value, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.brain_name_.Mutable( GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _impl_.brain_name_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_brain_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brain_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brain_name_.IsDefault()) {
          _impl_.brain_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}

// string given_name = 3;
inline void LoadSceneOutputEvent_Agent::clear_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.given_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::given_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_given_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoadSceneOutputEvent_Agent::set_given_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.given_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_given_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_given_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_given_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.given_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_given_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.given_name_.Set(value, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.given_name_.Mutable( GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _impl_.given_name_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_given_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.given_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.given_name_.IsDefault()) {
          _impl_.given_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent

// repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
inline int LoadSceneOutputEvent::_internal_agents_size() const {
  return _internal_agents().size();
}
inline int LoadSceneOutputEvent::agents_size() const {
  return _internal_agents_size();
}
inline void LoadSceneOutputEvent::clear_agents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agents_.Clear();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::mutable_agents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_mutable_agents()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>* LoadSceneOutputEvent::mutable_agents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_agents();
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::agents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_agents().Get(index);
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::add_agents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* _add = _internal_mutable_agents()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>& LoadSceneOutputEvent::agents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_agents();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>&
LoadSceneOutputEvent::_internal_agents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agents_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::LoadSceneOutputEvent_Agent>*
LoadSceneOutputEvent::_internal_mutable_agents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.agents_;
}

// -------------------------------------------------------------------

// Agent

// string agent_id = 1;
inline void Agent::clear_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& Agent::agent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.agent_id)
  return _internal_agent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_agent_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.agent_id)
}
inline std::string* Agent::mutable_agent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.agent_id)
  return _s;
}
inline const std::string& Agent::_internal_agent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.agent_id_.Get();
}
inline void Agent::_internal_set_agent_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_id_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.agent_id_.Mutable( GetArena());
}
inline std::string* Agent::release_agent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.agent_id)
  return _impl_.agent_id_.Release();
}
inline void Agent::set_allocated_agent_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.agent_id_.IsDefault()) {
          _impl_.agent_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.agent_id)
}

// string brain_name = 2;
inline void Agent::clear_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brain_name_.ClearToEmpty();
}
inline const std::string& Agent::brain_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.brain_name)
  return _internal_brain_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_brain_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brain_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.brain_name)
}
inline std::string* Agent::mutable_brain_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brain_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.brain_name)
  return _s;
}
inline const std::string& Agent::_internal_brain_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brain_name_.Get();
}
inline void Agent::_internal_set_brain_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brain_name_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.brain_name_.Mutable( GetArena());
}
inline std::string* Agent::release_brain_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.brain_name)
  return _impl_.brain_name_.Release();
}
inline void Agent::set_allocated_brain_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brain_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brain_name_.IsDefault()) {
          _impl_.brain_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.brain_name)
}

// string given_name = 3;
inline void Agent::clear_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.given_name_.ClearToEmpty();
}
inline const std::string& Agent::given_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.given_name)
  return _internal_given_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Agent::set_given_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.given_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.given_name)
}
inline std::string* Agent::mutable_given_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_given_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.given_name)
  return _s;
}
inline const std::string& Agent::_internal_given_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.given_name_.Get();
}
inline void Agent::_internal_set_given_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.given_name_.Set(value, GetArena());
}
inline std::string* Agent::_internal_mutable_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.given_name_.Mutable( GetArena());
}
inline std::string* Agent::release_given_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.given_name)
  return _impl_.given_name_.Release();
}
inline void Agent::set_allocated_given_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.given_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.given_name_.IsDefault()) {
          _impl_.given_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.given_name)
}

// -------------------------------------------------------------------

// DebugInfoEvent

// .ai.inworld.packets.RelationInfo relation = 1;
inline bool DebugInfoEvent::has_relation() const {
  return info_case() == kRelation;
}
inline bool DebugInfoEvent::_internal_has_relation() const {
  return info_case() == kRelation;
}
inline void DebugInfoEvent::set_has_relation() {
  _impl_._oneof_case_[0] = kRelation;
}
inline void DebugInfoEvent::clear_relation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (info_case() == kRelation) {
    if (GetArena() == nullptr) {
      delete _impl_.info_.relation_;
    }
    clear_has_info();
  }
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::release_relation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (info_case() == kRelation) {
    clear_has_info();
    auto* temp = _impl_.info_.relation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::_internal_relation() const {
  return info_case() == kRelation ? *_impl_.info_.relation_ : reinterpret_cast<::ai::inworld::packets::RelationInfo&>(::ai::inworld::packets::_RelationInfo_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::relation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_relation();
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::unsafe_arena_release_relation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (info_case() == kRelation) {
    clear_has_info();
    auto* temp = _impl_.info_.relation_;
    _impl_.info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugInfoEvent::unsafe_arena_set_allocated_relation(::ai::inworld::packets::RelationInfo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_info();
  if (value) {
    set_has_relation();
    _impl_.info_.relation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DebugInfoEvent.relation)
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::_internal_mutable_relation() {
  if (info_case() != kRelation) {
    clear_info();
    set_has_relation();
    _impl_.info_.relation_ = CreateMaybeMessage<::ai::inworld::packets::RelationInfo>(GetArena());
  }
  return _impl_.info_.relation_;
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::mutable_relation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::RelationInfo* _msg = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DebugInfoEvent.relation)
  return _msg;
}

inline bool DebugInfoEvent::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void DebugInfoEvent::clear_has_info() {
  _impl_._oneof_case_[0] = INFO_NOT_SET;
}
inline DebugInfoEvent::InfoCase DebugInfoEvent::info_case() const {
  return DebugInfoEvent::InfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionControlEvent

// .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
inline bool SessionControlEvent::has_session_configuration() const {
  return session_control_case() == kSessionConfiguration;
}
inline bool SessionControlEvent::_internal_has_session_configuration() const {
  return session_control_case() == kSessionConfiguration;
}
inline void SessionControlEvent::set_has_session_configuration() {
  _impl_._oneof_case_[0] = kSessionConfiguration;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::release_session_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.session_configuration)
  if (session_control_case() == kSessionConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.session_configuration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.session_control_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionControlEvent::_internal_session_configuration() const {
  return session_control_case() == kSessionConfiguration ? *_impl_.session_control_.session_configuration_ : reinterpret_cast<::ai::inworld::engine::configuration::SessionConfiguration&>(::ai::inworld::engine::configuration::_SessionConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionControlEvent::session_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.session_configuration)
  return _internal_session_configuration();
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::unsafe_arena_release_session_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.session_configuration)
  if (session_control_case() == kSessionConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.session_configuration_;
    _impl_.session_control_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_session_control();
  if (value) {
    set_has_session_configuration();
    _impl_.session_control_.session_configuration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.session_configuration)
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::_internal_mutable_session_configuration() {
  if (session_control_case() != kSessionConfiguration) {
    clear_session_control();
    set_has_session_configuration();
    _impl_.session_control_.session_configuration_ = CreateMaybeMessage<::ai::inworld::engine::configuration::SessionConfiguration>(GetArena());
  }
  return _impl_.session_control_.session_configuration_;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::mutable_session_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::engine::configuration::SessionConfiguration* _msg = _internal_mutable_session_configuration();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.session_configuration)
  return _msg;
}

// .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
inline bool SessionControlEvent::has_user_configuration() const {
  return session_control_case() == kUserConfiguration;
}
inline bool SessionControlEvent::_internal_has_user_configuration() const {
  return session_control_case() == kUserConfiguration;
}
inline void SessionControlEvent::set_has_user_configuration() {
  _impl_._oneof_case_[0] = kUserConfiguration;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::release_user_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.user_configuration)
  if (session_control_case() == kUserConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.user_configuration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.session_control_.user_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionControlEvent::_internal_user_configuration() const {
  return session_control_case() == kUserConfiguration ? *_impl_.session_control_.user_configuration_ : reinterpret_cast<::ai::inworld::engine::configuration::UserConfiguration&>(::ai::inworld::engine::configuration::_UserConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionControlEvent::user_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.user_configuration)
  return _internal_user_configuration();
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::unsafe_arena_release_user_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.user_configuration)
  if (session_control_case() == kUserConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.user_configuration_;
    _impl_.session_control_.user_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_session_control();
  if (value) {
    set_has_user_configuration();
    _impl_.session_control_.user_configuration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.user_configuration)
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::_internal_mutable_user_configuration() {
  if (session_control_case() != kUserConfiguration) {
    clear_session_control();
    set_has_user_configuration();
    _impl_.session_control_.user_configuration_ = CreateMaybeMessage<::ai::inworld::engine::configuration::UserConfiguration>(GetArena());
  }
  return _impl_.session_control_.user_configuration_;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::mutable_user_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::engine::configuration::UserConfiguration* _msg = _internal_mutable_user_configuration();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.user_configuration)
  return _msg;
}

// .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
inline bool SessionControlEvent::has_client_configuration() const {
  return session_control_case() == kClientConfiguration;
}
inline bool SessionControlEvent::_internal_has_client_configuration() const {
  return session_control_case() == kClientConfiguration;
}
inline void SessionControlEvent::set_has_client_configuration() {
  _impl_._oneof_case_[0] = kClientConfiguration;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::release_client_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.client_configuration)
  if (session_control_case() == kClientConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.client_configuration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.session_control_.client_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionControlEvent::_internal_client_configuration() const {
  return session_control_case() == kClientConfiguration ? *_impl_.session_control_.client_configuration_ : reinterpret_cast<::ai::inworld::engine::configuration::ClientConfiguration&>(::ai::inworld::engine::configuration::_ClientConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionControlEvent::client_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.client_configuration)
  return _internal_client_configuration();
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.client_configuration)
  if (session_control_case() == kClientConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.client_configuration_;
    _impl_.session_control_.client_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_session_control();
  if (value) {
    set_has_client_configuration();
    _impl_.session_control_.client_configuration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.client_configuration)
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::_internal_mutable_client_configuration() {
  if (session_control_case() != kClientConfiguration) {
    clear_session_control();
    set_has_client_configuration();
    _impl_.session_control_.client_configuration_ = CreateMaybeMessage<::ai::inworld::engine::configuration::ClientConfiguration>(GetArena());
  }
  return _impl_.session_control_.client_configuration_;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::mutable_client_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::engine::configuration::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.client_configuration)
  return _msg;
}

// .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
inline bool SessionControlEvent::has_capabilities_configuration() const {
  return session_control_case() == kCapabilitiesConfiguration;
}
inline bool SessionControlEvent::_internal_has_capabilities_configuration() const {
  return session_control_case() == kCapabilitiesConfiguration;
}
inline void SessionControlEvent::set_has_capabilities_configuration() {
  _impl_._oneof_case_[0] = kCapabilitiesConfiguration;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::release_capabilities_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  if (session_control_case() == kCapabilitiesConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.capabilities_configuration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.session_control_.capabilities_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionControlEvent::_internal_capabilities_configuration() const {
  return session_control_case() == kCapabilitiesConfiguration ? *_impl_.session_control_.capabilities_configuration_ : reinterpret_cast<::ai::inworld::engine::configuration::CapabilitiesConfiguration&>(::ai::inworld::engine::configuration::_CapabilitiesConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionControlEvent::capabilities_configuration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  return _internal_capabilities_configuration();
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::unsafe_arena_release_capabilities_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  if (session_control_case() == kCapabilitiesConfiguration) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.capabilities_configuration_;
    _impl_.session_control_.capabilities_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_session_control();
  if (value) {
    set_has_capabilities_configuration();
    _impl_.session_control_.capabilities_configuration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::_internal_mutable_capabilities_configuration() {
  if (session_control_case() != kCapabilitiesConfiguration) {
    clear_session_control();
    set_has_capabilities_configuration();
    _impl_.session_control_.capabilities_configuration_ = CreateMaybeMessage<::ai::inworld::engine::configuration::CapabilitiesConfiguration>(GetArena());
  }
  return _impl_.session_control_.capabilities_configuration_;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::mutable_capabilities_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* _msg = _internal_mutable_capabilities_configuration();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  return _msg;
}

// .ai.inworld.packets.Continuation continuation = 5;
inline bool SessionControlEvent::has_continuation() const {
  return session_control_case() == kContinuation;
}
inline bool SessionControlEvent::_internal_has_continuation() const {
  return session_control_case() == kContinuation;
}
inline void SessionControlEvent::set_has_continuation() {
  _impl_._oneof_case_[0] = kContinuation;
}
inline void SessionControlEvent::clear_continuation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (session_control_case() == kContinuation) {
    if (GetArena() == nullptr) {
      delete _impl_.session_control_.continuation_;
    }
    clear_has_session_control();
  }
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::release_continuation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.continuation)
  if (session_control_case() == kContinuation) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.continuation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf_inworld::internal::DuplicateIfNonNull(temp);
    }
    _impl_.session_control_.continuation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::Continuation& SessionControlEvent::_internal_continuation() const {
  return session_control_case() == kContinuation ? *_impl_.session_control_.continuation_ : reinterpret_cast<::ai::inworld::packets::Continuation&>(::ai::inworld::packets::_Continuation_default_instance_);
}
inline const ::ai::inworld::packets::Continuation& SessionControlEvent::continuation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.continuation)
  return _internal_continuation();
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::unsafe_arena_release_continuation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.continuation)
  if (session_control_case() == kContinuation) {
    clear_has_session_control();
    auto* temp = _impl_.session_control_.continuation_;
    _impl_.session_control_.continuation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_continuation(::ai::inworld::packets::Continuation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_session_control();
  if (value) {
    set_has_continuation();
    _impl_.session_control_.continuation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.continuation)
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::_internal_mutable_continuation() {
  if (session_control_case() != kContinuation) {
    clear_session_control();
    set_has_continuation();
    _impl_.session_control_.continuation_ = CreateMaybeMessage<::ai::inworld::packets::Continuation>(GetArena());
  }
  return _impl_.session_control_.continuation_;
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::mutable_continuation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Continuation* _msg = _internal_mutable_continuation();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.continuation)
  return _msg;
}

inline bool SessionControlEvent::has_session_control() const {
  return session_control_case() != SESSION_CONTROL_NOT_SET;
}
inline void SessionControlEvent::clear_has_session_control() {
  _impl_._oneof_case_[0] = SESSION_CONTROL_NOT_SET;
}
inline SessionControlEvent::SessionControlCase SessionControlEvent::session_control_case() const {
  return SessionControlEvent::SessionControlCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Continuation_ContinuationInfo

// .google.protobuf.Timestamp passed_time = 1;
inline bool Continuation_ContinuationInfo::has_passed_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.passed_time_ != nullptr);
  return value;
}
inline const ::google::protobuf_inworld::Timestamp& Continuation_ContinuationInfo::_internal_passed_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf_inworld::Timestamp* p = _impl_.passed_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf_inworld::Timestamp&>(::google::protobuf_inworld::_Timestamp_default_instance_);
}
inline const ::google::protobuf_inworld::Timestamp& Continuation_ContinuationInfo::passed_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
  return _internal_passed_time();
}
inline void Continuation_ContinuationInfo::unsafe_arena_set_allocated_passed_time(::google::protobuf_inworld::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.passed_time_);
  }
  _impl_.passed_time_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
}
inline ::google::protobuf_inworld::Timestamp* Continuation_ContinuationInfo::release_passed_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Timestamp* released = _impl_.passed_time_;
  _impl_.passed_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf_inworld::Timestamp* Continuation_ContinuationInfo::unsafe_arena_release_passed_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf_inworld::Timestamp* temp = _impl_.passed_time_;
  _impl_.passed_time_ = nullptr;
  return temp;
}
inline ::google::protobuf_inworld::Timestamp* Continuation_ContinuationInfo::_internal_mutable_passed_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.passed_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf_inworld::Timestamp>(GetArena());
    _impl_.passed_time_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(p);
  }
  return _impl_.passed_time_;
}
inline ::google::protobuf_inworld::Timestamp* Continuation_ContinuationInfo::mutable_passed_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf_inworld::Timestamp* _msg = _internal_mutable_passed_time();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
  return _msg;
}
inline void Continuation_ContinuationInfo::set_allocated_passed_time(::google::protobuf_inworld::Timestamp* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.passed_time_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.passed_time_ = reinterpret_cast<::google::protobuf_inworld::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
}

// -------------------------------------------------------------------

// Continuation

// .ai.inworld.packets.Continuation.ContinuationInfo continuation_info = 1;
inline bool Continuation::has_continuation_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.continuation_info_ != nullptr);
  return value;
}
inline void Continuation::clear_continuation_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.continuation_info_ != nullptr) _impl_.continuation_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::Continuation_ContinuationInfo& Continuation::_internal_continuation_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Continuation_ContinuationInfo* p = _impl_.continuation_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Continuation_ContinuationInfo&>(::ai::inworld::packets::_Continuation_ContinuationInfo_default_instance_);
}
inline const ::ai::inworld::packets::Continuation_ContinuationInfo& Continuation::continuation_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.continuation_info)
  return _internal_continuation_info();
}
inline void Continuation::unsafe_arena_set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.continuation_info_);
  }
  _impl_.continuation_info_ = reinterpret_cast<::ai::inworld::packets::Continuation_ContinuationInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.continuation_info)
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::release_continuation_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Continuation_ContinuationInfo* released = _impl_.continuation_info_;
  _impl_.continuation_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::unsafe_arena_release_continuation_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.continuation_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Continuation_ContinuationInfo* temp = _impl_.continuation_info_;
  _impl_.continuation_info_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::_internal_mutable_continuation_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.continuation_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Continuation_ContinuationInfo>(GetArena());
    _impl_.continuation_info_ = reinterpret_cast<::ai::inworld::packets::Continuation_ContinuationInfo*>(p);
  }
  return _impl_.continuation_info_;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::mutable_continuation_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Continuation_ContinuationInfo* _msg = _internal_mutable_continuation_info();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.continuation_info)
  return _msg;
}
inline void Continuation::set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Continuation_ContinuationInfo*>(_impl_.continuation_info_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Continuation_ContinuationInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.continuation_info_ = reinterpret_cast<::ai::inworld::packets::Continuation_ContinuationInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.continuation_info)
}

// .ai.inworld.packets.Continuation.ContinuationType continuation_type = 2;
inline void Continuation::clear_continuation_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.continuation_type_ = 0;
}
inline ::ai::inworld::packets::Continuation_ContinuationType Continuation::continuation_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.continuation_type)
  return _internal_continuation_type();
}
inline void Continuation::set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value) {
  _internal_set_continuation_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Continuation.continuation_type)
}
inline ::ai::inworld::packets::Continuation_ContinuationType Continuation::_internal_continuation_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::packets::Continuation_ContinuationType>(_impl_.continuation_type_);
}
inline void Continuation::_internal_set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.continuation_type_ = value;
}

// .ai.inworld.packets.DialogHistory dialog_history = 3;
inline bool Continuation::has_dialog_history() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dialog_history_ != nullptr);
  return value;
}
inline void Continuation::clear_dialog_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dialog_history_ != nullptr) _impl_.dialog_history_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::packets::DialogHistory& Continuation::_internal_dialog_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::DialogHistory* p = _impl_.dialog_history_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::DialogHistory&>(::ai::inworld::packets::_DialogHistory_default_instance_);
}
inline const ::ai::inworld::packets::DialogHistory& Continuation::dialog_history() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.dialog_history)
  return _internal_dialog_history();
}
inline void Continuation::unsafe_arena_set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.dialog_history_);
  }
  _impl_.dialog_history_ = reinterpret_cast<::ai::inworld::packets::DialogHistory*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.dialog_history)
}
inline ::ai::inworld::packets::DialogHistory* Continuation::release_dialog_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::DialogHistory* released = _impl_.dialog_history_;
  _impl_.dialog_history_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::unsafe_arena_release_dialog_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.dialog_history)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::packets::DialogHistory* temp = _impl_.dialog_history_;
  _impl_.dialog_history_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::_internal_mutable_dialog_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dialog_history_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::DialogHistory>(GetArena());
    _impl_.dialog_history_ = reinterpret_cast<::ai::inworld::packets::DialogHistory*>(p);
  }
  return _impl_.dialog_history_;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::mutable_dialog_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::DialogHistory* _msg = _internal_mutable_dialog_history();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.dialog_history)
  return _msg;
}
inline void Continuation::set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::DialogHistory*>(_impl_.dialog_history_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::DialogHistory*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dialog_history_ = reinterpret_cast<::ai::inworld::packets::DialogHistory*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.dialog_history)
}

// bytes externally_saved_state = 4;
inline void Continuation::clear_externally_saved_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.externally_saved_state_.ClearToEmpty();
}
inline const std::string& Continuation::externally_saved_state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.externally_saved_state)
  return _internal_externally_saved_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Continuation::set_externally_saved_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.externally_saved_state_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Continuation.externally_saved_state)
}
inline std::string* Continuation::mutable_externally_saved_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_externally_saved_state();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.externally_saved_state)
  return _s;
}
inline const std::string& Continuation::_internal_externally_saved_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.externally_saved_state_.Get();
}
inline void Continuation::_internal_set_externally_saved_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.externally_saved_state_.Set(value, GetArena());
}
inline std::string* Continuation::_internal_mutable_externally_saved_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.externally_saved_state_.Mutable( GetArena());
}
inline std::string* Continuation::release_externally_saved_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.externally_saved_state)
  return _impl_.externally_saved_state_.Release();
}
inline void Continuation::set_allocated_externally_saved_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.externally_saved_state_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.externally_saved_state_.IsDefault()) {
          _impl_.externally_saved_state_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.externally_saved_state)
}

// -------------------------------------------------------------------

// DialogHistory_HistoryItem

// .ai.inworld.packets.Actor actor = 1;
inline bool DialogHistory_HistoryItem::has_actor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actor_ != nullptr);
  return value;
}
inline void DialogHistory_HistoryItem::clear_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.actor_ != nullptr) _impl_.actor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::Actor& DialogHistory_HistoryItem::_internal_actor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Actor* p = _impl_.actor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& DialogHistory_HistoryItem::actor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.HistoryItem.actor)
  return _internal_actor();
}
inline void DialogHistory_HistoryItem::unsafe_arena_set_allocated_actor(::ai::inworld::packets::Actor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.actor_);
  }
  _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.actor)
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::release_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* released = _impl_.actor_;
  _impl_.actor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::unsafe_arena_release_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DialogHistory.HistoryItem.actor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* temp = _impl_.actor_;
  _impl_.actor_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::_internal_mutable_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.actor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(p);
  }
  return _impl_.actor_;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::mutable_actor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_actor();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.HistoryItem.actor)
  return _msg;
}
inline void DialogHistory_HistoryItem::set_allocated_actor(::ai::inworld::packets::Actor* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Actor*>(_impl_.actor_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Actor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.actor)
}

// string text = 2;
inline void DialogHistory_HistoryItem::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& DialogHistory_HistoryItem::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DialogHistory_HistoryItem::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DialogHistory.HistoryItem.text)
}
inline std::string* DialogHistory_HistoryItem::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return _s;
}
inline const std::string& DialogHistory_HistoryItem::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void DialogHistory_HistoryItem::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* DialogHistory_HistoryItem::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* DialogHistory_HistoryItem::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return _impl_.text_.Release();
}
inline void DialogHistory_HistoryItem::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.text)
}

// -------------------------------------------------------------------

// DialogHistory

// repeated .ai.inworld.packets.DialogHistory.HistoryItem history = 1;
inline int DialogHistory::_internal_history_size() const {
  return _internal_history().size();
}
inline int DialogHistory::history_size() const {
  return _internal_history_size();
}
inline void DialogHistory::clear_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.history_.Clear();
}
inline ::ai::inworld::packets::DialogHistory_HistoryItem* DialogHistory::mutable_history(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.history)
  return _internal_mutable_history()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>* DialogHistory::mutable_history()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DialogHistory.history)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_history();
}
inline const ::ai::inworld::packets::DialogHistory_HistoryItem& DialogHistory::history(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.history)
  return _internal_history().Get(index);
}
inline ::ai::inworld::packets::DialogHistory_HistoryItem* DialogHistory::add_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::DialogHistory_HistoryItem* _add = _internal_mutable_history()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DialogHistory.history)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>& DialogHistory::history() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DialogHistory.history)
  return _internal_history();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>&
DialogHistory::_internal_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.history_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::DialogHistory_HistoryItem>*
DialogHistory::_internal_mutable_history() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.history_;
}

// -------------------------------------------------------------------

// Relations_Relation

// string type = 1;
inline void Relations_Relation::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Relations_Relation::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.Relation.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relations_Relation::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Relations.Relation.type)
}
inline std::string* Relations_Relation::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.Relation.type)
  return _s;
}
inline const std::string& Relations_Relation::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Relations_Relation::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Relations_Relation::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Relations_Relation::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.Relation.type)
  return _impl_.type_.Release();
}
inline void Relations_Relation::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.Relation.type)
}

// string label = 2;
inline void Relations_Relation::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.label_.ClearToEmpty();
}
inline const std::string& Relations_Relation::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.Relation.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relations_Relation::set_label(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Relations.Relation.label)
}
inline std::string* Relations_Relation::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.Relation.label)
  return _s;
}
inline const std::string& Relations_Relation::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.label_.Get();
}
inline void Relations_Relation::_internal_set_label(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.label_.Set(value, GetArena());
}
inline std::string* Relations_Relation::_internal_mutable_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* Relations_Relation::release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.Relation.label)
  return _impl_.label_.Release();
}
inline void Relations_Relation::set_allocated_label(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.label_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.Relation.label)
}

// -------------------------------------------------------------------

// Relations

// .ai.inworld.packets.Actor actor = 1;
inline bool Relations::has_actor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.actor_ != nullptr);
  return value;
}
inline void Relations::clear_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.actor_ != nullptr) _impl_.actor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::packets::Actor& Relations::_internal_actor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::packets::Actor* p = _impl_.actor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Relations::actor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.actor)
  return _internal_actor();
}
inline void Relations::unsafe_arena_set_allocated_actor(::ai::inworld::packets::Actor* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf_inworld::MessageLite*>(_impl_.actor_);
  }
  _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Relations.actor)
}
inline ::ai::inworld::packets::Actor* Relations::release_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* released = _impl_.actor_;
  _impl_.actor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf_inworld::MessageLite*>(released);
  released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf_inworld::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::packets::Actor* Relations::unsafe_arena_release_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.actor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::packets::Actor* temp = _impl_.actor_;
  _impl_.actor_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Relations::_internal_mutable_actor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.actor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(p);
  }
  return _impl_.actor_;
}
inline ::ai::inworld::packets::Actor* Relations::mutable_actor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_actor();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.actor)
  return _msg;
}
inline void Relations::set_allocated_actor(::ai::inworld::packets::Actor* value) {
  ::google::protobuf_inworld::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::packets::Actor*>(_impl_.actor_);
  }

  if (value != nullptr) {
    ::google::protobuf_inworld::Arena* submessage_arena = reinterpret_cast<::ai::inworld::packets::Actor*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf_inworld::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.actor_ = reinterpret_cast<::ai::inworld::packets::Actor*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.actor)
}

// repeated .ai.inworld.packets.Relations.Relation relations = 2;
inline int Relations::_internal_relations_size() const {
  return _internal_relations().size();
}
inline int Relations::relations_size() const {
  return _internal_relations_size();
}
inline void Relations::clear_relations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relations_.Clear();
}
inline ::ai::inworld::packets::Relations_Relation* Relations::mutable_relations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.relations)
  return _internal_mutable_relations()->Mutable(index);
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>* Relations::mutable_relations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.Relations.relations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_relations();
}
inline const ::ai::inworld::packets::Relations_Relation& Relations::relations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.relations)
  return _internal_relations().Get(index);
}
inline ::ai::inworld::packets::Relations_Relation* Relations::add_relations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::packets::Relations_Relation* _add = _internal_mutable_relations()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.Relations.relations)
  return _add;
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>& Relations::relations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.Relations.relations)
  return _internal_relations();
}
inline const ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>&
Relations::_internal_relations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relations_;
}
inline ::google::protobuf_inworld::RepeatedPtrField<::ai::inworld::packets::Relations_Relation>*
Relations::_internal_mutable_relations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.relations_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace packets
}  // namespace inworld
}  // namespace ai


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ai::inworld::packets::Actor_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::Actor_Type>() {
  return ::ai::inworld::packets::Actor_Type_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::TextEvent_SourceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::TextEvent_SourceType>() {
  return ::ai::inworld::packets::TextEvent_SourceType_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::ControlEvent_Action> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::ControlEvent_Action>() {
  return ::ai::inworld::packets::ControlEvent_Action_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::EmotionEvent_SpaffCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::EmotionEvent_SpaffCode>() {
  return ::ai::inworld::packets::EmotionEvent_SpaffCode_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::EmotionEvent_Strength> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::EmotionEvent_Strength>() {
  return ::ai::inworld::packets::EmotionEvent_Strength_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::DataChunk_DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::DataChunk_DataType>() {
  return ::ai::inworld::packets::DataChunk_DataType_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::DataChunk_AudioFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::DataChunk_AudioFormat>() {
  return ::ai::inworld::packets::DataChunk_AudioFormat_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::Continuation_ContinuationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::Continuation_ContinuationType>() {
  return ::ai::inworld::packets::Continuation_ContinuationType_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::packets::Playback> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::packets::Playback>() {
  return ::ai::inworld::packets::Playback_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto_2epb_2eh
