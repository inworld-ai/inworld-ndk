// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ai/inworld/studio/v1alpha/workspaces.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "ai/inworld/studio/v1alpha/impression_event_data.pb.h"
#include "ai/inworld/studio/v1alpha/language_code.pb.h"
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "ai/inworld/options/options.pb.h"
#include "ai/inworld/language_codes/language_codes.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
namespace ai {
namespace inworld {
namespace studio {
namespace v1alpha {
class CloneWorkspaceRequest;
struct CloneWorkspaceRequestDefaultTypeInternal;
extern CloneWorkspaceRequestDefaultTypeInternal _CloneWorkspaceRequest_default_instance_;
class CreateWorkspaceRequest;
struct CreateWorkspaceRequestDefaultTypeInternal;
extern CreateWorkspaceRequestDefaultTypeInternal _CreateWorkspaceRequest_default_instance_;
class DeleteWorkspaceRequest;
struct DeleteWorkspaceRequestDefaultTypeInternal;
extern DeleteWorkspaceRequestDefaultTypeInternal _DeleteWorkspaceRequest_default_instance_;
class GenerateResourceNameRequest;
struct GenerateResourceNameRequestDefaultTypeInternal;
extern GenerateResourceNameRequestDefaultTypeInternal _GenerateResourceNameRequest_default_instance_;
class GenerateResourceNameResponse;
struct GenerateResourceNameResponseDefaultTypeInternal;
extern GenerateResourceNameResponseDefaultTypeInternal _GenerateResourceNameResponse_default_instance_;
class GetWorkspaceLimitInfoRequest;
struct GetWorkspaceLimitInfoRequestDefaultTypeInternal;
extern GetWorkspaceLimitInfoRequestDefaultTypeInternal _GetWorkspaceLimitInfoRequest_default_instance_;
class GetWorkspaceRequest;
struct GetWorkspaceRequestDefaultTypeInternal;
extern GetWorkspaceRequestDefaultTypeInternal _GetWorkspaceRequest_default_instance_;
class GetWorkspaceShareInfoRequest;
struct GetWorkspaceShareInfoRequestDefaultTypeInternal;
extern GetWorkspaceShareInfoRequestDefaultTypeInternal _GetWorkspaceShareInfoRequest_default_instance_;
class ImpressionEventRequest;
struct ImpressionEventRequestDefaultTypeInternal;
extern ImpressionEventRequestDefaultTypeInternal _ImpressionEventRequest_default_instance_;
class ListWorkspacesRequest;
struct ListWorkspacesRequestDefaultTypeInternal;
extern ListWorkspacesRequestDefaultTypeInternal _ListWorkspacesRequest_default_instance_;
class ListWorkspacesResponse;
struct ListWorkspacesResponseDefaultTypeInternal;
extern ListWorkspacesResponseDefaultTypeInternal _ListWorkspacesResponse_default_instance_;
class ShareWorkspaceRequest;
struct ShareWorkspaceRequestDefaultTypeInternal;
extern ShareWorkspaceRequestDefaultTypeInternal _ShareWorkspaceRequest_default_instance_;
class UpdateWorkspaceRequest;
struct UpdateWorkspaceRequestDefaultTypeInternal;
extern UpdateWorkspaceRequestDefaultTypeInternal _UpdateWorkspaceRequest_default_instance_;
class Workspace;
struct WorkspaceDefaultTypeInternal;
extern WorkspaceDefaultTypeInternal _Workspace_default_instance_;
class WorkspaceLimitInfo;
struct WorkspaceLimitInfoDefaultTypeInternal;
extern WorkspaceLimitInfoDefaultTypeInternal _WorkspaceLimitInfo_default_instance_;
class WorkspaceLimitInfo_BillingAccountLimit;
struct WorkspaceLimitInfo_BillingAccountLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_BillingAccountLimitDefaultTypeInternal _WorkspaceLimitInfo_BillingAccountLimit_default_instance_;
class WorkspaceLimitInfo_CharacterLimit;
struct WorkspaceLimitInfo_CharacterLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CharacterLimitDefaultTypeInternal _WorkspaceLimitInfo_CharacterLimit_default_instance_;
class WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit;
struct WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimitDefaultTypeInternal _WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_;
class WorkspaceLimitInfo_CommonKnowledgeLimit;
struct WorkspaceLimitInfo_CommonKnowledgeLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_CommonKnowledgeLimitDefaultTypeInternal _WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_;
class WorkspaceLimitInfo_SceneLimit;
struct WorkspaceLimitInfo_SceneLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_SceneLimitDefaultTypeInternal _WorkspaceLimitInfo_SceneLimit_default_instance_;
class WorkspaceLimitInfo_TextListLimit;
struct WorkspaceLimitInfo_TextListLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_TextListLimitDefaultTypeInternal _WorkspaceLimitInfo_TextListLimit_default_instance_;
class WorkspaceLimitInfo_WorkspaceLimit;
struct WorkspaceLimitInfo_WorkspaceLimitDefaultTypeInternal;
extern WorkspaceLimitInfo_WorkspaceLimitDefaultTypeInternal _WorkspaceLimitInfo_WorkspaceLimit_default_instance_;
class WorkspaceShareInfo;
struct WorkspaceShareInfoDefaultTypeInternal;
extern WorkspaceShareInfoDefaultTypeInternal _WorkspaceShareInfo_default_instance_;
class Workspace_Meta;
struct Workspace_MetaDefaultTypeInternal;
extern Workspace_MetaDefaultTypeInternal _Workspace_Meta_default_instance_;
}  // namespace v1alpha
}  // namespace studio
}  // namespace inworld
}  // namespace ai
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ai {
namespace inworld {
namespace studio {
namespace v1alpha {
enum Workspace_RuntimeAccess : int {
  Workspace_RuntimeAccess_RUNTIME_ACCESS_UNSPECIFIED = 0,
  Workspace_RuntimeAccess_RUNTIME_ACCESS_PRIVATE = 1,
  Workspace_RuntimeAccess_RUNTIME_ACCESS_PUBLIC = 2,
  Workspace_RuntimeAccess_Workspace_RuntimeAccess_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Workspace_RuntimeAccess_Workspace_RuntimeAccess_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Workspace_RuntimeAccess_IsValid(int value);
extern const uint32_t Workspace_RuntimeAccess_internal_data_[];
constexpr Workspace_RuntimeAccess Workspace_RuntimeAccess_RuntimeAccess_MIN = static_cast<Workspace_RuntimeAccess>(0);
constexpr Workspace_RuntimeAccess Workspace_RuntimeAccess_RuntimeAccess_MAX = static_cast<Workspace_RuntimeAccess>(2);
constexpr int Workspace_RuntimeAccess_RuntimeAccess_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Workspace_RuntimeAccess_descriptor();
template <typename T>
const std::string& Workspace_RuntimeAccess_Name(T value) {
  static_assert(std::is_same<T, Workspace_RuntimeAccess>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RuntimeAccess_Name().");
  return Workspace_RuntimeAccess_Name(static_cast<Workspace_RuntimeAccess>(value));
}
template <>
inline const std::string& Workspace_RuntimeAccess_Name(Workspace_RuntimeAccess value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Workspace_RuntimeAccess_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Workspace_RuntimeAccess_Parse(absl::string_view name, Workspace_RuntimeAccess* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Workspace_RuntimeAccess>(
      Workspace_RuntimeAccess_descriptor(), name, value);
}
enum GenerateResourceNameRequest_ResourceType : int {
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_UNSPECIFIED = 0,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_WORKSPACE = 1,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_CHARACTER = 2,
  GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_SCENE = 3,
  GenerateResourceNameRequest_ResourceType_GenerateResourceNameRequest_ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GenerateResourceNameRequest_ResourceType_GenerateResourceNameRequest_ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GenerateResourceNameRequest_ResourceType_IsValid(int value);
extern const uint32_t GenerateResourceNameRequest_ResourceType_internal_data_[];
constexpr GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest_ResourceType_ResourceType_MIN = static_cast<GenerateResourceNameRequest_ResourceType>(0);
constexpr GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest_ResourceType_ResourceType_MAX = static_cast<GenerateResourceNameRequest_ResourceType>(3);
constexpr int GenerateResourceNameRequest_ResourceType_ResourceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GenerateResourceNameRequest_ResourceType_descriptor();
template <typename T>
const std::string& GenerateResourceNameRequest_ResourceType_Name(T value) {
  static_assert(std::is_same<T, GenerateResourceNameRequest_ResourceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResourceType_Name().");
  return GenerateResourceNameRequest_ResourceType_Name(static_cast<GenerateResourceNameRequest_ResourceType>(value));
}
template <>
inline const std::string& GenerateResourceNameRequest_ResourceType_Name(GenerateResourceNameRequest_ResourceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GenerateResourceNameRequest_ResourceType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool GenerateResourceNameRequest_ResourceType_Parse(absl::string_view name, GenerateResourceNameRequest_ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenerateResourceNameRequest_ResourceType>(
      GenerateResourceNameRequest_ResourceType_descriptor(), name, value);
}
enum WorkspaceItemView : int {
  WORKSPACE_ITEM_VIEW_UNSPECIFIED = 0,
  WORKSPACE_ITEM_VIEW_DEFAULT = 1,
  WORKSPACE_ITEM_VIEW_WITH_META = 2,
  WorkspaceItemView_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WorkspaceItemView_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WorkspaceItemView_IsValid(int value);
extern const uint32_t WorkspaceItemView_internal_data_[];
constexpr WorkspaceItemView WorkspaceItemView_MIN = static_cast<WorkspaceItemView>(0);
constexpr WorkspaceItemView WorkspaceItemView_MAX = static_cast<WorkspaceItemView>(2);
constexpr int WorkspaceItemView_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
WorkspaceItemView_descriptor();
template <typename T>
const std::string& WorkspaceItemView_Name(T value) {
  static_assert(std::is_same<T, WorkspaceItemView>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WorkspaceItemView_Name().");
  return WorkspaceItemView_Name(static_cast<WorkspaceItemView>(value));
}
template <>
inline const std::string& WorkspaceItemView_Name(WorkspaceItemView value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WorkspaceItemView_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool WorkspaceItemView_Parse(absl::string_view name, WorkspaceItemView* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkspaceItemView>(
      WorkspaceItemView_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkspaceShareInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceShareInfo) */ {
 public:
  inline WorkspaceShareInfo() : WorkspaceShareInfo(nullptr) {}
  ~WorkspaceShareInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceShareInfo(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceShareInfo(const WorkspaceShareInfo& from)
      : WorkspaceShareInfo(nullptr, from) {}
  WorkspaceShareInfo(WorkspaceShareInfo&& from) noexcept
    : WorkspaceShareInfo() {
    *this = ::std::move(from);
  }

  inline WorkspaceShareInfo& operator=(const WorkspaceShareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceShareInfo& operator=(WorkspaceShareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceShareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceShareInfo* internal_default_instance() {
    return reinterpret_cast<const WorkspaceShareInfo*>(
               &_WorkspaceShareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WorkspaceShareInfo& a, WorkspaceShareInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceShareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceShareInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceShareInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceShareInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceShareInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceShareInfo& from) {
    WorkspaceShareInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceShareInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceShareInfo";
  }
  protected:
  explicit WorkspaceShareInfo(::google::protobuf::Arena* arena);
  WorkspaceShareInfo(::google::protobuf::Arena* arena, const WorkspaceShareInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 1,
  };
  // repeated string emails = 1;
  int emails_size() const;
  private:
  int _internal_emails_size() const;

  public:
  void clear_emails() ;
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, std::size_t size);
  void set_emails(int index, absl::string_view value);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, std::size_t size);
  void add_emails(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& emails() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_emails();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_emails() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_emails();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceShareInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> emails_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_WorkspaceLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit) */ {
 public:
  inline WorkspaceLimitInfo_WorkspaceLimit() : WorkspaceLimitInfo_WorkspaceLimit(nullptr) {}
  ~WorkspaceLimitInfo_WorkspaceLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_WorkspaceLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_WorkspaceLimit(const WorkspaceLimitInfo_WorkspaceLimit& from)
      : WorkspaceLimitInfo_WorkspaceLimit(nullptr, from) {}
  WorkspaceLimitInfo_WorkspaceLimit(WorkspaceLimitInfo_WorkspaceLimit&& from) noexcept
    : WorkspaceLimitInfo_WorkspaceLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_WorkspaceLimit& operator=(const WorkspaceLimitInfo_WorkspaceLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_WorkspaceLimit& operator=(WorkspaceLimitInfo_WorkspaceLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_WorkspaceLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_WorkspaceLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_WorkspaceLimit*>(
               &_WorkspaceLimitInfo_WorkspaceLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WorkspaceLimitInfo_WorkspaceLimit& a, WorkspaceLimitInfo_WorkspaceLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_WorkspaceLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_WorkspaceLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_WorkspaceLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_WorkspaceLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_WorkspaceLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_WorkspaceLimit& from) {
    WorkspaceLimitInfo_WorkspaceLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_WorkspaceLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_WorkspaceLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_WorkspaceLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_WorkspaceLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameMaxLengthFieldNumber = 1,
    kTotalCharactersFieldNumber = 2,
    kTotalScenesFieldNumber = 3,
    kTotalTriggersFieldNumber = 4,
    kTotalVoicesFieldNumber = 5,
    kTotalCommonKnowledgeFieldNumber = 6,
  };
  // int32 display_name_max_length = 1;
  void clear_display_name_max_length() ;
  ::int32_t display_name_max_length() const;
  void set_display_name_max_length(::int32_t value);

  private:
  ::int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(::int32_t value);

  public:
  // int32 total_characters = 2;
  void clear_total_characters() ;
  ::int32_t total_characters() const;
  void set_total_characters(::int32_t value);

  private:
  ::int32_t _internal_total_characters() const;
  void _internal_set_total_characters(::int32_t value);

  public:
  // int32 total_scenes = 3;
  void clear_total_scenes() ;
  ::int32_t total_scenes() const;
  void set_total_scenes(::int32_t value);

  private:
  ::int32_t _internal_total_scenes() const;
  void _internal_set_total_scenes(::int32_t value);

  public:
  // int32 total_triggers = 4;
  void clear_total_triggers() ;
  ::int32_t total_triggers() const;
  void set_total_triggers(::int32_t value);

  private:
  ::int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(::int32_t value);

  public:
  // int32 total_voices = 5;
  void clear_total_voices() ;
  ::int32_t total_voices() const;
  void set_total_voices(::int32_t value);

  private:
  ::int32_t _internal_total_voices() const;
  void _internal_set_total_voices(::int32_t value);

  public:
  // int32 total_common_knowledge = 6;
  void clear_total_common_knowledge() ;
  ::int32_t total_common_knowledge() const;
  void set_total_common_knowledge(::int32_t value);

  private:
  ::int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t display_name_max_length_;
    ::int32_t total_characters_;
    ::int32_t total_scenes_;
    ::int32_t total_triggers_;
    ::int32_t total_voices_;
    ::int32_t total_common_knowledge_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_TextListLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit) */ {
 public:
  inline WorkspaceLimitInfo_TextListLimit() : WorkspaceLimitInfo_TextListLimit(nullptr) {}
  ~WorkspaceLimitInfo_TextListLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_TextListLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_TextListLimit(const WorkspaceLimitInfo_TextListLimit& from)
      : WorkspaceLimitInfo_TextListLimit(nullptr, from) {}
  WorkspaceLimitInfo_TextListLimit(WorkspaceLimitInfo_TextListLimit&& from) noexcept
    : WorkspaceLimitInfo_TextListLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_TextListLimit& operator=(const WorkspaceLimitInfo_TextListLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_TextListLimit& operator=(WorkspaceLimitInfo_TextListLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_TextListLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_TextListLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_TextListLimit*>(
               &_WorkspaceLimitInfo_TextListLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WorkspaceLimitInfo_TextListLimit& a, WorkspaceLimitInfo_TextListLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_TextListLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_TextListLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_TextListLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_TextListLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_TextListLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_TextListLimit& from) {
    WorkspaceLimitInfo_TextListLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_TextListLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_TextListLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_TextListLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_TextListLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemMaxLengthFieldNumber = 1,
    kTotalItemsFieldNumber = 2,
  };
  // int32 item_max_length = 1;
  void clear_item_max_length() ;
  ::int32_t item_max_length() const;
  void set_item_max_length(::int32_t value);

  private:
  ::int32_t _internal_item_max_length() const;
  void _internal_set_item_max_length(::int32_t value);

  public:
  // int32 total_items = 2;
  void clear_total_items() ;
  ::int32_t total_items() const;
  void set_total_items(::int32_t value);

  private:
  ::int32_t _internal_total_items() const;
  void _internal_set_total_items(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t item_max_length_;
    ::int32_t total_items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_SceneLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit) */ {
 public:
  inline WorkspaceLimitInfo_SceneLimit() : WorkspaceLimitInfo_SceneLimit(nullptr) {}
  ~WorkspaceLimitInfo_SceneLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_SceneLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_SceneLimit(const WorkspaceLimitInfo_SceneLimit& from)
      : WorkspaceLimitInfo_SceneLimit(nullptr, from) {}
  WorkspaceLimitInfo_SceneLimit(WorkspaceLimitInfo_SceneLimit&& from) noexcept
    : WorkspaceLimitInfo_SceneLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_SceneLimit& operator=(const WorkspaceLimitInfo_SceneLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_SceneLimit& operator=(WorkspaceLimitInfo_SceneLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_SceneLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_SceneLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_SceneLimit*>(
               &_WorkspaceLimitInfo_SceneLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WorkspaceLimitInfo_SceneLimit& a, WorkspaceLimitInfo_SceneLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_SceneLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_SceneLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_SceneLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_SceneLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_SceneLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_SceneLimit& from) {
    WorkspaceLimitInfo_SceneLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_SceneLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_SceneLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_SceneLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_SceneLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionMaxLengthFieldNumber = 1,
    kTotalCharactersFieldNumber = 2,
    kTotalTriggersFieldNumber = 3,
    kDisplayNameMaxLengthFieldNumber = 4,
    kTotalCommonKnowledgeFieldNumber = 5,
    kSceneTriggerDescriptionMaxLengthFieldNumber = 6,
  };
  // int32 description_max_length = 1;
  void clear_description_max_length() ;
  ::int32_t description_max_length() const;
  void set_description_max_length(::int32_t value);

  private:
  ::int32_t _internal_description_max_length() const;
  void _internal_set_description_max_length(::int32_t value);

  public:
  // int32 total_characters = 2;
  void clear_total_characters() ;
  ::int32_t total_characters() const;
  void set_total_characters(::int32_t value);

  private:
  ::int32_t _internal_total_characters() const;
  void _internal_set_total_characters(::int32_t value);

  public:
  // int32 total_triggers = 3;
  void clear_total_triggers() ;
  ::int32_t total_triggers() const;
  void set_total_triggers(::int32_t value);

  private:
  ::int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(::int32_t value);

  public:
  // int32 display_name_max_length = 4;
  void clear_display_name_max_length() ;
  ::int32_t display_name_max_length() const;
  void set_display_name_max_length(::int32_t value);

  private:
  ::int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(::int32_t value);

  public:
  // int32 total_common_knowledge = 5;
  void clear_total_common_knowledge() ;
  ::int32_t total_common_knowledge() const;
  void set_total_common_knowledge(::int32_t value);

  private:
  ::int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(::int32_t value);

  public:
  // int32 scene_trigger_description_max_length = 6;
  void clear_scene_trigger_description_max_length() ;
  ::int32_t scene_trigger_description_max_length() const;
  void set_scene_trigger_description_max_length(::int32_t value);

  private:
  ::int32_t _internal_scene_trigger_description_max_length() const;
  void _internal_set_scene_trigger_description_max_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t description_max_length_;
    ::int32_t total_characters_;
    ::int32_t total_triggers_;
    ::int32_t display_name_max_length_;
    ::int32_t total_common_knowledge_;
    ::int32_t scene_trigger_description_max_length_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_BillingAccountLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit) */ {
 public:
  inline WorkspaceLimitInfo_BillingAccountLimit() : WorkspaceLimitInfo_BillingAccountLimit(nullptr) {}
  ~WorkspaceLimitInfo_BillingAccountLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_BillingAccountLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_BillingAccountLimit(const WorkspaceLimitInfo_BillingAccountLimit& from)
      : WorkspaceLimitInfo_BillingAccountLimit(nullptr, from) {}
  WorkspaceLimitInfo_BillingAccountLimit(WorkspaceLimitInfo_BillingAccountLimit&& from) noexcept
    : WorkspaceLimitInfo_BillingAccountLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_BillingAccountLimit& operator=(const WorkspaceLimitInfo_BillingAccountLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_BillingAccountLimit& operator=(WorkspaceLimitInfo_BillingAccountLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_BillingAccountLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_BillingAccountLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_BillingAccountLimit*>(
               &_WorkspaceLimitInfo_BillingAccountLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WorkspaceLimitInfo_BillingAccountLimit& a, WorkspaceLimitInfo_BillingAccountLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_BillingAccountLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_BillingAccountLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_BillingAccountLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_BillingAccountLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_BillingAccountLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_BillingAccountLimit& from) {
    WorkspaceLimitInfo_BillingAccountLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_BillingAccountLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_BillingAccountLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_BillingAccountLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_BillingAccountLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalWorkspacesFieldNumber = 1,
  };
  // int32 total_workspaces = 1;
  void clear_total_workspaces() ;
  ::int32_t total_workspaces() const;
  void set_total_workspaces(::int32_t value);

  private:
  ::int32_t _internal_total_workspaces() const;
  void _internal_set_total_workspaces(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t total_workspaces_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class Workspace_Meta final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.Workspace.Meta) */ {
 public:
  inline Workspace_Meta() : Workspace_Meta(nullptr) {}
  ~Workspace_Meta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Workspace_Meta(::google::protobuf::internal::ConstantInitialized);

  inline Workspace_Meta(const Workspace_Meta& from)
      : Workspace_Meta(nullptr, from) {}
  Workspace_Meta(Workspace_Meta&& from) noexcept
    : Workspace_Meta() {
    *this = ::std::move(from);
  }

  inline Workspace_Meta& operator=(const Workspace_Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workspace_Meta& operator=(Workspace_Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workspace_Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workspace_Meta* internal_default_instance() {
    return reinterpret_cast<const Workspace_Meta*>(
               &_Workspace_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Workspace_Meta& a, Workspace_Meta& b) {
    a.Swap(&b);
  }
  inline void Swap(Workspace_Meta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workspace_Meta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workspace_Meta* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Workspace_Meta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Workspace_Meta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Workspace_Meta& from) {
    Workspace_Meta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Workspace_Meta* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.Workspace.Meta";
  }
  protected:
  explicit Workspace_Meta(::google::protobuf::Arena* arena);
  Workspace_Meta(::google::protobuf::Arena* arena, const Workspace_Meta& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalCharactersFieldNumber = 1,
    kTotalScenesFieldNumber = 2,
    kTotalTriggersFieldNumber = 3,
    kTotalCommonKnowledgeFieldNumber = 4,
  };
  // int32 total_characters = 1;
  void clear_total_characters() ;
  ::int32_t total_characters() const;
  void set_total_characters(::int32_t value);

  private:
  ::int32_t _internal_total_characters() const;
  void _internal_set_total_characters(::int32_t value);

  public:
  // int32 total_scenes = 2;
  void clear_total_scenes() ;
  ::int32_t total_scenes() const;
  void set_total_scenes(::int32_t value);

  private:
  ::int32_t _internal_total_scenes() const;
  void _internal_set_total_scenes(::int32_t value);

  public:
  // int32 total_triggers = 3;
  void clear_total_triggers() ;
  ::int32_t total_triggers() const;
  void set_total_triggers(::int32_t value);

  private:
  ::int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(::int32_t value);

  public:
  // int32 total_common_knowledge = 4;
  void clear_total_common_knowledge() ;
  ::int32_t total_common_knowledge() const;
  void set_total_common_knowledge(::int32_t value);

  private:
  ::int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.Workspace.Meta)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t total_characters_;
    ::int32_t total_scenes_;
    ::int32_t total_triggers_;
    ::int32_t total_common_knowledge_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class ShareWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ShareWorkspaceRequest) */ {
 public:
  inline ShareWorkspaceRequest() : ShareWorkspaceRequest(nullptr) {}
  ~ShareWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShareWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline ShareWorkspaceRequest(const ShareWorkspaceRequest& from)
      : ShareWorkspaceRequest(nullptr, from) {}
  ShareWorkspaceRequest(ShareWorkspaceRequest&& from) noexcept
    : ShareWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline ShareWorkspaceRequest& operator=(const ShareWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareWorkspaceRequest& operator=(ShareWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const ShareWorkspaceRequest*>(
               &_ShareWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ShareWorkspaceRequest& a, ShareWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShareWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShareWorkspaceRequest& from) {
    ShareWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShareWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.ShareWorkspaceRequest";
  }
  protected:
  explicit ShareWorkspaceRequest(::google::protobuf::Arena* arena);
  ShareWorkspaceRequest(::google::protobuf::Arena* arena, const ShareWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated string emails = 2 [(.ai.inworld.options.examples) = {
  int emails_size() const;
  private:
  int _internal_emails_size() const;

  public:
  void clear_emails() ;
  const std::string& emails(int index) const;
  std::string* mutable_emails(int index);
  void set_emails(int index, const std::string& value);
  void set_emails(int index, std::string&& value);
  void set_emails(int index, const char* value);
  void set_emails(int index, const char* value, std::size_t size);
  void set_emails(int index, absl::string_view value);
  std::string* add_emails();
  void add_emails(const std::string& value);
  void add_emails(std::string&& value);
  void add_emails(const char* value);
  void add_emails(const char* value, std::size_t size);
  void add_emails(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& emails() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_emails();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_emails() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_emails();

  public:
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ShareWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> emails_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class ListWorkspacesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ListWorkspacesRequest) */ {
 public:
  inline ListWorkspacesRequest() : ListWorkspacesRequest(nullptr) {}
  ~ListWorkspacesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListWorkspacesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListWorkspacesRequest(const ListWorkspacesRequest& from)
      : ListWorkspacesRequest(nullptr, from) {}
  ListWorkspacesRequest(ListWorkspacesRequest&& from) noexcept
    : ListWorkspacesRequest() {
    *this = ::std::move(from);
  }

  inline ListWorkspacesRequest& operator=(const ListWorkspacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkspacesRequest& operator=(ListWorkspacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkspacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkspacesRequest* internal_default_instance() {
    return reinterpret_cast<const ListWorkspacesRequest*>(
               &_ListWorkspacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListWorkspacesRequest& a, ListWorkspacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkspacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkspacesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkspacesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkspacesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListWorkspacesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListWorkspacesRequest& from) {
    ListWorkspacesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListWorkspacesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.ListWorkspacesRequest";
  }
  protected:
  explicit ListWorkspacesRequest(::google::protobuf::Arena* arena);
  ListWorkspacesRequest(::google::protobuf::Arena* arena, const ListWorkspacesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // int32 page_size = 1;
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ListWorkspacesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class GetWorkspaceShareInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest) */ {
 public:
  inline GetWorkspaceShareInfoRequest() : GetWorkspaceShareInfoRequest(nullptr) {}
  ~GetWorkspaceShareInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWorkspaceShareInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetWorkspaceShareInfoRequest(const GetWorkspaceShareInfoRequest& from)
      : GetWorkspaceShareInfoRequest(nullptr, from) {}
  GetWorkspaceShareInfoRequest(GetWorkspaceShareInfoRequest&& from) noexcept
    : GetWorkspaceShareInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceShareInfoRequest& operator=(const GetWorkspaceShareInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceShareInfoRequest& operator=(GetWorkspaceShareInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceShareInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceShareInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceShareInfoRequest*>(
               &_GetWorkspaceShareInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetWorkspaceShareInfoRequest& a, GetWorkspaceShareInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceShareInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceShareInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceShareInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceShareInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceShareInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceShareInfoRequest& from) {
    GetWorkspaceShareInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetWorkspaceShareInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest";
  }
  protected:
  explicit GetWorkspaceShareInfoRequest(::google::protobuf::Arena* arena);
  GetWorkspaceShareInfoRequest(::google::protobuf::Arena* arena, const GetWorkspaceShareInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class GetWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceRequest) */ {
 public:
  inline GetWorkspaceRequest() : GetWorkspaceRequest(nullptr) {}
  ~GetWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetWorkspaceRequest(const GetWorkspaceRequest& from)
      : GetWorkspaceRequest(nullptr, from) {}
  GetWorkspaceRequest(GetWorkspaceRequest&& from) noexcept
    : GetWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceRequest& operator=(const GetWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceRequest& operator=(GetWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceRequest*>(
               &_GetWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetWorkspaceRequest& a, GetWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceRequest& from) {
    GetWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceRequest";
  }
  protected:
  explicit GetWorkspaceRequest(::google::protobuf::Arena* arena);
  GetWorkspaceRequest(::google::protobuf::Arena* arena, const GetWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kViewFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceItemView view = 2;
  void clear_view() ;
  ::ai::inworld::studio::v1alpha::WorkspaceItemView view() const;
  void set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value);

  private:
  ::ai::inworld::studio::v1alpha::WorkspaceItemView _internal_view() const;
  void _internal_set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    int view_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class GetWorkspaceLimitInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest) */ {
 public:
  inline GetWorkspaceLimitInfoRequest() : GetWorkspaceLimitInfoRequest(nullptr) {}
  ~GetWorkspaceLimitInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWorkspaceLimitInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetWorkspaceLimitInfoRequest(const GetWorkspaceLimitInfoRequest& from)
      : GetWorkspaceLimitInfoRequest(nullptr, from) {}
  GetWorkspaceLimitInfoRequest(GetWorkspaceLimitInfoRequest&& from) noexcept
    : GetWorkspaceLimitInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkspaceLimitInfoRequest& operator=(const GetWorkspaceLimitInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWorkspaceLimitInfoRequest& operator=(GetWorkspaceLimitInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWorkspaceLimitInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWorkspaceLimitInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkspaceLimitInfoRequest*>(
               &_GetWorkspaceLimitInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetWorkspaceLimitInfoRequest& a, GetWorkspaceLimitInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWorkspaceLimitInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWorkspaceLimitInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWorkspaceLimitInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWorkspaceLimitInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetWorkspaceLimitInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetWorkspaceLimitInfoRequest& from) {
    GetWorkspaceLimitInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetWorkspaceLimitInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest";
  }
  protected:
  explicit GetWorkspaceLimitInfoRequest(::google::protobuf::Arena* arena);
  GetWorkspaceLimitInfoRequest(::google::protobuf::Arena* arena, const GetWorkspaceLimitInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class GenerateResourceNameResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GenerateResourceNameResponse) */ {
 public:
  inline GenerateResourceNameResponse() : GenerateResourceNameResponse(nullptr) {}
  ~GenerateResourceNameResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateResourceNameResponse(::google::protobuf::internal::ConstantInitialized);

  inline GenerateResourceNameResponse(const GenerateResourceNameResponse& from)
      : GenerateResourceNameResponse(nullptr, from) {}
  GenerateResourceNameResponse(GenerateResourceNameResponse&& from) noexcept
    : GenerateResourceNameResponse() {
    *this = ::std::move(from);
  }

  inline GenerateResourceNameResponse& operator=(const GenerateResourceNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateResourceNameResponse& operator=(GenerateResourceNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateResourceNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateResourceNameResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateResourceNameResponse*>(
               &_GenerateResourceNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GenerateResourceNameResponse& a, GenerateResourceNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateResourceNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateResourceNameResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateResourceNameResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateResourceNameResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateResourceNameResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenerateResourceNameResponse& from) {
    GenerateResourceNameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenerateResourceNameResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.GenerateResourceNameResponse";
  }
  protected:
  explicit GenerateResourceNameResponse(::google::protobuf::Arena* arena);
  GenerateResourceNameResponse(::google::protobuf::Arena* arena, const GenerateResourceNameResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceFieldNumber = 1,
  };
  // string resource = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_resource() ;
  const std::string& resource() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resource(Arg_&& arg, Args_... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* value);

  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(
      const std::string& value);
  std::string* _internal_mutable_resource();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GenerateResourceNameResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr resource_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class GenerateResourceNameRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.GenerateResourceNameRequest) */ {
 public:
  inline GenerateResourceNameRequest() : GenerateResourceNameRequest(nullptr) {}
  ~GenerateResourceNameRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenerateResourceNameRequest(::google::protobuf::internal::ConstantInitialized);

  inline GenerateResourceNameRequest(const GenerateResourceNameRequest& from)
      : GenerateResourceNameRequest(nullptr, from) {}
  GenerateResourceNameRequest(GenerateResourceNameRequest&& from) noexcept
    : GenerateResourceNameRequest() {
    *this = ::std::move(from);
  }

  inline GenerateResourceNameRequest& operator=(const GenerateResourceNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateResourceNameRequest& operator=(GenerateResourceNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateResourceNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateResourceNameRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateResourceNameRequest*>(
               &_GenerateResourceNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GenerateResourceNameRequest& a, GenerateResourceNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateResourceNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateResourceNameRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateResourceNameRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateResourceNameRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenerateResourceNameRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenerateResourceNameRequest& from) {
    GenerateResourceNameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenerateResourceNameRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.GenerateResourceNameRequest";
  }
  protected:
  explicit GenerateResourceNameRequest(::google::protobuf::Arena* arena);
  GenerateResourceNameRequest(::google::protobuf::Arena* arena, const GenerateResourceNameRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ResourceType = GenerateResourceNameRequest_ResourceType;
  static constexpr ResourceType RESOURCE_TYPE_UNSPECIFIED = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_UNSPECIFIED;
  static constexpr ResourceType RESOURCE_TYPE_WORKSPACE = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_WORKSPACE;
  static constexpr ResourceType RESOURCE_TYPE_CHARACTER = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_CHARACTER;
  static constexpr ResourceType RESOURCE_TYPE_SCENE = GenerateResourceNameRequest_ResourceType_RESOURCE_TYPE_SCENE;
  static inline bool ResourceType_IsValid(int value) {
    return GenerateResourceNameRequest_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN = GenerateResourceNameRequest_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX = GenerateResourceNameRequest_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE = GenerateResourceNameRequest_ResourceType_ResourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ResourceType_descriptor() {
    return GenerateResourceNameRequest_ResourceType_descriptor();
  }
  template <typename T>
  static inline const std::string& ResourceType_Name(T value) {
    return GenerateResourceNameRequest_ResourceType_Name(value);
  }
  static inline bool ResourceType_Parse(absl::string_view name, ResourceType* value) {
    return GenerateResourceNameRequest_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kResourceTypeFieldNumber = 3,
  };
  // string workspace = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_workspace() ;
  const std::string& workspace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workspace(Arg_&& arg, Args_... args);
  std::string* mutable_workspace();
  PROTOBUF_NODISCARD std::string* release_workspace();
  void set_allocated_workspace(std::string* value);

  private:
  const std::string& _internal_workspace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workspace(
      const std::string& value);
  std::string* _internal_mutable_workspace();

  public:
  // string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // .ai.inworld.studio.v1alpha.GenerateResourceNameRequest.ResourceType resource_type = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_resource_type() ;
  ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType resource_type() const;
  void set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value);

  private:
  ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.GenerateResourceNameRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr workspace_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    int resource_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class DeleteWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest) */ {
 public:
  inline DeleteWorkspaceRequest() : DeleteWorkspaceRequest(nullptr) {}
  ~DeleteWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteWorkspaceRequest(const DeleteWorkspaceRequest& from)
      : DeleteWorkspaceRequest(nullptr, from) {}
  DeleteWorkspaceRequest(DeleteWorkspaceRequest&& from) noexcept
    : DeleteWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteWorkspaceRequest& operator=(const DeleteWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteWorkspaceRequest& operator=(DeleteWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteWorkspaceRequest*>(
               &_DeleteWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteWorkspaceRequest& a, DeleteWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteWorkspaceRequest& from) {
    DeleteWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.DeleteWorkspaceRequest";
  }
  protected:
  explicit DeleteWorkspaceRequest(::google::protobuf::Arena* arena);
  DeleteWorkspaceRequest(::google::protobuf::Arena* arena, const DeleteWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kForceFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bool force = 2;
  void clear_force() ;
  bool force() const;
  void set_force(bool value);

  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool force_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class CloneWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.CloneWorkspaceRequest) */ {
 public:
  inline CloneWorkspaceRequest() : CloneWorkspaceRequest(nullptr) {}
  ~CloneWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CloneWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline CloneWorkspaceRequest(const CloneWorkspaceRequest& from)
      : CloneWorkspaceRequest(nullptr, from) {}
  CloneWorkspaceRequest(CloneWorkspaceRequest&& from) noexcept
    : CloneWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline CloneWorkspaceRequest& operator=(const CloneWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloneWorkspaceRequest& operator=(CloneWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloneWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloneWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const CloneWorkspaceRequest*>(
               &_CloneWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CloneWorkspaceRequest& a, CloneWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloneWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloneWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloneWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloneWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloneWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CloneWorkspaceRequest& from) {
    CloneWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CloneWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.CloneWorkspaceRequest";
  }
  protected:
  explicit CloneWorkspaceRequest(::google::protobuf::Arena* arena);
  CloneWorkspaceRequest(::google::protobuf::Arena* arena, const CloneWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTargetWorkspaceFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string target_workspace = 2;
  void clear_target_workspace() ;
  const std::string& target_workspace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_workspace(Arg_&& arg, Args_... args);
  std::string* mutable_target_workspace();
  PROTOBUF_NODISCARD std::string* release_target_workspace();
  void set_allocated_target_workspace(std::string* value);

  private:
  const std::string& _internal_target_workspace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_workspace(
      const std::string& value);
  std::string* _internal_mutable_target_workspace();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.CloneWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr target_workspace_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_CommonKnowledgeLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit) */ {
 public:
  inline WorkspaceLimitInfo_CommonKnowledgeLimit() : WorkspaceLimitInfo_CommonKnowledgeLimit(nullptr) {}
  ~WorkspaceLimitInfo_CommonKnowledgeLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CommonKnowledgeLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_CommonKnowledgeLimit(const WorkspaceLimitInfo_CommonKnowledgeLimit& from)
      : WorkspaceLimitInfo_CommonKnowledgeLimit(nullptr, from) {}
  WorkspaceLimitInfo_CommonKnowledgeLimit(WorkspaceLimitInfo_CommonKnowledgeLimit&& from) noexcept
    : WorkspaceLimitInfo_CommonKnowledgeLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CommonKnowledgeLimit& operator=(const WorkspaceLimitInfo_CommonKnowledgeLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CommonKnowledgeLimit& operator=(WorkspaceLimitInfo_CommonKnowledgeLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CommonKnowledgeLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CommonKnowledgeLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CommonKnowledgeLimit*>(
               &_WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WorkspaceLimitInfo_CommonKnowledgeLimit& a, WorkspaceLimitInfo_CommonKnowledgeLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CommonKnowledgeLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CommonKnowledgeLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CommonKnowledgeLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CommonKnowledgeLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CommonKnowledgeLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CommonKnowledgeLimit& from) {
    WorkspaceLimitInfo_CommonKnowledgeLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_CommonKnowledgeLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CommonKnowledgeLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_CommonKnowledgeLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_CommonKnowledgeLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryRecordsFieldNumber = 3,
    kDisplayNameMaxLengthFieldNumber = 1,
    kDescriptionMaxLengthFieldNumber = 2,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit memory_records = 3;
  bool has_memory_records() const;
  void clear_memory_records() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& memory_records() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_memory_records();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_memory_records();
  void set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  void unsafe_arena_set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_memory_records();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_memory_records() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_memory_records();

  public:
  // int32 display_name_max_length = 1;
  void clear_display_name_max_length() ;
  ::int32_t display_name_max_length() const;
  void set_display_name_max_length(::int32_t value);

  private:
  ::int32_t _internal_display_name_max_length() const;
  void _internal_set_display_name_max_length(::int32_t value);

  public:
  // int32 description_max_length = 2;
  void clear_description_max_length() ;
  ::int32_t description_max_length() const;
  void set_description_max_length(::int32_t value);

  private:
  ::int32_t _internal_description_max_length() const;
  void _internal_set_description_max_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* memory_records_;
    ::int32_t display_name_max_length_;
    ::int32_t description_max_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit) */ {
 public:
  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() : WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(nullptr) {}
  ~WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from)
      : WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(nullptr, from) {}
  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&& from) noexcept
    : WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& operator=(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& operator=(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(
               &_WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& a, WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from) {
    WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHobbyOrInterestsFieldNumber = 5,
    kNicknamesFieldNumber = 6,
    kPersonalityAdjectivesFieldNumber = 7,
    kCoreMaxLengthFieldNumber = 1,
    kExampleDialogMaxLengthFieldNumber = 2,
    kMotivationMaxLengthFieldNumber = 3,
    kCharacterRoleMaxLengthFieldNumber = 4,
    kFlawsMaxLengthFieldNumber = 8,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit hobby_or_interests = 5;
  bool has_hobby_or_interests() const;
  void clear_hobby_or_interests() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& hobby_or_interests() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_hobby_or_interests();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_hobby_or_interests();
  void set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  void unsafe_arena_set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_hobby_or_interests();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_hobby_or_interests() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_hobby_or_interests();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit nicknames = 6;
  bool has_nicknames() const;
  void clear_nicknames() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& nicknames() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_nicknames();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_nicknames();
  void set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  void unsafe_arena_set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_nicknames();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_nicknames() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_nicknames();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit personality_adjectives = 7;
  bool has_personality_adjectives() const;
  void clear_personality_adjectives() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& personality_adjectives() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* release_personality_adjectives();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* mutable_personality_adjectives();
  void set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  void unsafe_arena_set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* unsafe_arena_release_personality_adjectives();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& _internal_personality_adjectives() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _internal_mutable_personality_adjectives();

  public:
  // int32 core_max_length = 1;
  void clear_core_max_length() ;
  ::int32_t core_max_length() const;
  void set_core_max_length(::int32_t value);

  private:
  ::int32_t _internal_core_max_length() const;
  void _internal_set_core_max_length(::int32_t value);

  public:
  // int32 example_dialog_max_length = 2;
  void clear_example_dialog_max_length() ;
  ::int32_t example_dialog_max_length() const;
  void set_example_dialog_max_length(::int32_t value);

  private:
  ::int32_t _internal_example_dialog_max_length() const;
  void _internal_set_example_dialog_max_length(::int32_t value);

  public:
  // int32 motivation_max_length = 3;
  void clear_motivation_max_length() ;
  ::int32_t motivation_max_length() const;
  void set_motivation_max_length(::int32_t value);

  private:
  ::int32_t _internal_motivation_max_length() const;
  void _internal_set_motivation_max_length(::int32_t value);

  public:
  // int32 character_role_max_length = 4;
  void clear_character_role_max_length() ;
  ::int32_t character_role_max_length() const;
  void set_character_role_max_length(::int32_t value);

  private:
  ::int32_t _internal_character_role_max_length() const;
  void _internal_set_character_role_max_length(::int32_t value);

  public:
  // int32 flaws_max_length = 8;
  void clear_flaws_max_length() ;
  ::int32_t flaws_max_length() const;
  void set_flaws_max_length(::int32_t value);

  private:
  ::int32_t _internal_flaws_max_length() const;
  void _internal_set_flaws_max_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* hobby_or_interests_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* nicknames_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* personality_adjectives_;
    ::int32_t core_max_length_;
    ::int32_t example_dialog_max_length_;
    ::int32_t motivation_max_length_;
    ::int32_t character_role_max_length_;
    ::int32_t flaws_max_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class Workspace final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.Workspace) */ {
 public:
  inline Workspace() : Workspace(nullptr) {}
  ~Workspace() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Workspace(::google::protobuf::internal::ConstantInitialized);

  inline Workspace(const Workspace& from)
      : Workspace(nullptr, from) {}
  Workspace(Workspace&& from) noexcept
    : Workspace() {
    *this = ::std::move(from);
  }

  inline Workspace& operator=(const Workspace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workspace& operator=(Workspace&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workspace& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workspace* internal_default_instance() {
    return reinterpret_cast<const Workspace*>(
               &_Workspace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Workspace& a, Workspace& b) {
    a.Swap(&b);
  }
  inline void Swap(Workspace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workspace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workspace* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Workspace>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Workspace& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Workspace& from) {
    Workspace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Workspace* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.Workspace";
  }
  protected:
  explicit Workspace(::google::protobuf::Arena* arena);
  Workspace(::google::protobuf::Arena* arena, const Workspace& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Meta = Workspace_Meta;

  using RuntimeAccess = Workspace_RuntimeAccess;
  static constexpr RuntimeAccess RUNTIME_ACCESS_UNSPECIFIED = Workspace_RuntimeAccess_RUNTIME_ACCESS_UNSPECIFIED;
  static constexpr RuntimeAccess RUNTIME_ACCESS_PRIVATE = Workspace_RuntimeAccess_RUNTIME_ACCESS_PRIVATE;
  static constexpr RuntimeAccess RUNTIME_ACCESS_PUBLIC = Workspace_RuntimeAccess_RUNTIME_ACCESS_PUBLIC;
  static inline bool RuntimeAccess_IsValid(int value) {
    return Workspace_RuntimeAccess_IsValid(value);
  }
  static constexpr RuntimeAccess RuntimeAccess_MIN = Workspace_RuntimeAccess_RuntimeAccess_MIN;
  static constexpr RuntimeAccess RuntimeAccess_MAX = Workspace_RuntimeAccess_RuntimeAccess_MAX;
  static constexpr int RuntimeAccess_ARRAYSIZE = Workspace_RuntimeAccess_RuntimeAccess_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RuntimeAccess_descriptor() {
    return Workspace_RuntimeAccess_descriptor();
  }
  template <typename T>
  static inline const std::string& RuntimeAccess_Name(T value) {
    return Workspace_RuntimeAccess_Name(value);
  }
  static inline bool RuntimeAccess_Parse(absl::string_view name, RuntimeAccess* value) {
    return Workspace_RuntimeAccess_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExperimentalFeaturesFieldNumber = 3,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kBillingAccountFieldNumber = 4,
    kMetaFieldNumber = 5,
    kRuntimeAccessFieldNumber = 6,
    kPrimaryLanguageCodeFieldNumber = 7,
    kPrimaryLanguageFieldNumber = 8,
  };
  // repeated string experimental_features = 3;
  int experimental_features_size() const;
  private:
  int _internal_experimental_features_size() const;

  public:
  void clear_experimental_features() ;
  const std::string& experimental_features(int index) const;
  std::string* mutable_experimental_features(int index);
  void set_experimental_features(int index, const std::string& value);
  void set_experimental_features(int index, std::string&& value);
  void set_experimental_features(int index, const char* value);
  void set_experimental_features(int index, const char* value, std::size_t size);
  void set_experimental_features(int index, absl::string_view value);
  std::string* add_experimental_features();
  void add_experimental_features(const std::string& value);
  void add_experimental_features(std::string&& value);
  void add_experimental_features(const char* value);
  void add_experimental_features(const char* value, std::size_t size);
  void add_experimental_features(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& experimental_features() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_experimental_features();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_experimental_features() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_experimental_features();

  public:
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.ai.inworld.options.examples) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string billing_account = 4 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_billing_account() ;
  const std::string& billing_account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_billing_account(Arg_&& arg, Args_... args);
  std::string* mutable_billing_account();
  PROTOBUF_NODISCARD std::string* release_billing_account();
  void set_allocated_billing_account(std::string* value);

  private:
  const std::string& _internal_billing_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_account(
      const std::string& value);
  std::string* _internal_mutable_billing_account();

  public:
  // .ai.inworld.studio.v1alpha.Workspace.Meta meta = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_meta() const;
  void clear_meta() ;
  const ::ai::inworld::studio::v1alpha::Workspace_Meta& meta() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace_Meta* release_meta();
  ::ai::inworld::studio::v1alpha::Workspace_Meta* mutable_meta();
  void set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* value);
  void unsafe_arena_set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* value);
  ::ai::inworld::studio::v1alpha::Workspace_Meta* unsafe_arena_release_meta();

  private:
  const ::ai::inworld::studio::v1alpha::Workspace_Meta& _internal_meta() const;
  ::ai::inworld::studio::v1alpha::Workspace_Meta* _internal_mutable_meta();

  public:
  // .ai.inworld.studio.v1alpha.Workspace.RuntimeAccess runtime_access = 6;
  void clear_runtime_access() ;
  ::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess runtime_access() const;
  void set_runtime_access(::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess value);

  private:
  ::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess _internal_runtime_access() const;
  void _internal_set_runtime_access(::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess value);

  public:
  // .ai.inworld.studio.v1alpha.LanguageCode primary_language_code = 7 [deprecated = true];
  [[deprecated]]  void clear_primary_language_code() ;
  [[deprecated]] ::ai::inworld::studio::v1alpha::LanguageCode primary_language_code() const;
  [[deprecated]] void set_primary_language_code(::ai::inworld::studio::v1alpha::LanguageCode value);

  private:
  ::ai::inworld::studio::v1alpha::LanguageCode _internal_primary_language_code() const;
  void _internal_set_primary_language_code(::ai::inworld::studio::v1alpha::LanguageCode value);

  public:
  // .ai.inworld.language_codes.LanguageCode primary_language = 8;
  void clear_primary_language() ;
  ::ai::inworld::language_codes::LanguageCode primary_language() const;
  void set_primary_language(::ai::inworld::language_codes::LanguageCode value);

  private:
  ::ai::inworld::language_codes::LanguageCode _internal_primary_language() const;
  void _internal_set_primary_language(::ai::inworld::language_codes::LanguageCode value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.Workspace)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      104, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> experimental_features_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr billing_account_;
    ::ai::inworld::studio::v1alpha::Workspace_Meta* meta_;
    int runtime_access_;
    int primary_language_code_;
    int primary_language_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo_CharacterLimit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit) */ {
 public:
  inline WorkspaceLimitInfo_CharacterLimit() : WorkspaceLimitInfo_CharacterLimit(nullptr) {}
  ~WorkspaceLimitInfo_CharacterLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo_CharacterLimit(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo_CharacterLimit(const WorkspaceLimitInfo_CharacterLimit& from)
      : WorkspaceLimitInfo_CharacterLimit(nullptr, from) {}
  WorkspaceLimitInfo_CharacterLimit(WorkspaceLimitInfo_CharacterLimit&& from) noexcept
    : WorkspaceLimitInfo_CharacterLimit() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo_CharacterLimit& operator=(const WorkspaceLimitInfo_CharacterLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo_CharacterLimit& operator=(WorkspaceLimitInfo_CharacterLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo_CharacterLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo_CharacterLimit* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo_CharacterLimit*>(
               &_WorkspaceLimitInfo_CharacterLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WorkspaceLimitInfo_CharacterLimit& a, WorkspaceLimitInfo_CharacterLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo_CharacterLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo_CharacterLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo_CharacterLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo_CharacterLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo_CharacterLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo_CharacterLimit& from) {
    WorkspaceLimitInfo_CharacterLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo_CharacterLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit";
  }
  protected:
  explicit WorkspaceLimitInfo_CharacterLimit(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo_CharacterLimit(::google::protobuf::Arena* arena, const WorkspaceLimitInfo_CharacterLimit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CharacterDescriptionLimit = WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit;

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterDescriptionFieldNumber = 4,
    kNameMaxLengthFieldNumber = 1,
    kTotalTriggersFieldNumber = 2,
    kTotalCommonKnowledgeFieldNumber = 3,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit character_description = 4;
  bool has_character_description() const;
  void clear_character_description() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& character_description() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* release_character_description();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* mutable_character_description();
  void set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* value);
  void unsafe_arena_set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* unsafe_arena_release_character_description();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& _internal_character_description() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* _internal_mutable_character_description();

  public:
  // int32 name_max_length = 1;
  void clear_name_max_length() ;
  ::int32_t name_max_length() const;
  void set_name_max_length(::int32_t value);

  private:
  ::int32_t _internal_name_max_length() const;
  void _internal_set_name_max_length(::int32_t value);

  public:
  // int32 total_triggers = 2;
  void clear_total_triggers() ;
  ::int32_t total_triggers() const;
  void set_total_triggers(::int32_t value);

  private:
  ::int32_t _internal_total_triggers() const;
  void _internal_set_total_triggers(::int32_t value);

  public:
  // int32 total_common_knowledge = 3;
  void clear_total_common_knowledge() ;
  ::int32_t total_common_knowledge() const;
  void set_total_common_knowledge(::int32_t value);

  private:
  ::int32_t _internal_total_common_knowledge() const;
  void _internal_set_total_common_knowledge(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* character_description_;
    ::int32_t name_max_length_;
    ::int32_t total_triggers_;
    ::int32_t total_common_knowledge_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class UpdateWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest) */ {
 public:
  inline UpdateWorkspaceRequest() : UpdateWorkspaceRequest(nullptr) {}
  ~UpdateWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateWorkspaceRequest(const UpdateWorkspaceRequest& from)
      : UpdateWorkspaceRequest(nullptr, from) {}
  UpdateWorkspaceRequest(UpdateWorkspaceRequest&& from) noexcept
    : UpdateWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateWorkspaceRequest& operator=(const UpdateWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkspaceRequest& operator=(UpdateWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkspaceRequest*>(
               &_UpdateWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateWorkspaceRequest& a, UpdateWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateWorkspaceRequest& from) {
    UpdateWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.UpdateWorkspaceRequest";
  }
  protected:
  explicit UpdateWorkspaceRequest(::google::protobuf::Arena* arena);
  UpdateWorkspaceRequest(::google::protobuf::Arena* arena, const UpdateWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_workspace() const;
  void clear_workspace() ;
  const ::ai::inworld::studio::v1alpha::Workspace& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace* release_workspace();
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value);
  void unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value);
  ::ai::inworld::studio::v1alpha::Workspace* unsafe_arena_release_workspace();

  private:
  const ::ai::inworld::studio::v1alpha::Workspace& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::Workspace* _internal_mutable_workspace();

  public:
  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_update_mask() const;
  void clear_update_mask() ;
  const ::google::protobuf::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_update_mask();
  ::google::protobuf::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_update_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_update_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_update_mask();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::Workspace* workspace_;
    ::google::protobuf::FieldMask* update_mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class ListWorkspacesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ListWorkspacesResponse) */ {
 public:
  inline ListWorkspacesResponse() : ListWorkspacesResponse(nullptr) {}
  ~ListWorkspacesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListWorkspacesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListWorkspacesResponse(const ListWorkspacesResponse& from)
      : ListWorkspacesResponse(nullptr, from) {}
  ListWorkspacesResponse(ListWorkspacesResponse&& from) noexcept
    : ListWorkspacesResponse() {
    *this = ::std::move(from);
  }

  inline ListWorkspacesResponse& operator=(const ListWorkspacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkspacesResponse& operator=(ListWorkspacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkspacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkspacesResponse* internal_default_instance() {
    return reinterpret_cast<const ListWorkspacesResponse*>(
               &_ListWorkspacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListWorkspacesResponse& a, ListWorkspacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkspacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkspacesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkspacesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkspacesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListWorkspacesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListWorkspacesResponse& from) {
    ListWorkspacesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListWorkspacesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.ListWorkspacesResponse";
  }
  protected:
  explicit ListWorkspacesResponse(::google::protobuf::Arena* arena);
  ListWorkspacesResponse(::google::protobuf::Arena* arena, const ListWorkspacesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .ai.inworld.studio.v1alpha.Workspace workspaces = 1;
  int workspaces_size() const;
  private:
  int _internal_workspaces_size() const;

  public:
  void clear_workspaces() ;
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspaces(int index);
  ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >*
      mutable_workspaces();
  private:
  const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>& _internal_workspaces() const;
  ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>* _internal_mutable_workspaces();
  public:
  const ::ai::inworld::studio::v1alpha::Workspace& workspaces(int index) const;
  ::ai::inworld::studio::v1alpha::Workspace* add_workspaces();
  const ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace >&
      workspaces() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* value);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ListWorkspacesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      72, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::Workspace > workspaces_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class ImpressionEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.ImpressionEventRequest) */ {
 public:
  inline ImpressionEventRequest() : ImpressionEventRequest(nullptr) {}
  ~ImpressionEventRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ImpressionEventRequest(::google::protobuf::internal::ConstantInitialized);

  inline ImpressionEventRequest(const ImpressionEventRequest& from)
      : ImpressionEventRequest(nullptr, from) {}
  ImpressionEventRequest(ImpressionEventRequest&& from) noexcept
    : ImpressionEventRequest() {
    *this = ::std::move(from);
  }

  inline ImpressionEventRequest& operator=(const ImpressionEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImpressionEventRequest& operator=(ImpressionEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImpressionEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImpressionEventRequest* internal_default_instance() {
    return reinterpret_cast<const ImpressionEventRequest*>(
               &_ImpressionEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ImpressionEventRequest& a, ImpressionEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImpressionEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImpressionEventRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImpressionEventRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImpressionEventRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImpressionEventRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ImpressionEventRequest& from) {
    ImpressionEventRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImpressionEventRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.ImpressionEventRequest";
  }
  protected:
  explicit ImpressionEventRequest(::google::protobuf::Arena* arena);
  ImpressionEventRequest(::google::protobuf::Arena* arena, const ImpressionEventRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .ai.inworld.studio.v1alpha.ImpressionEventData data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::ai::inworld::studio::v1alpha::ImpressionEventData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::ImpressionEventData >*
      mutable_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>* _internal_mutable_data();
  public:
  const ::ai::inworld::studio::v1alpha::ImpressionEventData& data(int index) const;
  ::ai::inworld::studio::v1alpha::ImpressionEventData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::ImpressionEventData >&
      data() const;
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.ImpressionEventRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::ai::inworld::studio::v1alpha::ImpressionEventData > data_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class CreateWorkspaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.CreateWorkspaceRequest) */ {
 public:
  inline CreateWorkspaceRequest() : CreateWorkspaceRequest(nullptr) {}
  ~CreateWorkspaceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateWorkspaceRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateWorkspaceRequest(const CreateWorkspaceRequest& from)
      : CreateWorkspaceRequest(nullptr, from) {}
  CreateWorkspaceRequest(CreateWorkspaceRequest&& from) noexcept
    : CreateWorkspaceRequest() {
    *this = ::std::move(from);
  }

  inline CreateWorkspaceRequest& operator=(const CreateWorkspaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateWorkspaceRequest& operator=(CreateWorkspaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateWorkspaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateWorkspaceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateWorkspaceRequest*>(
               &_CreateWorkspaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateWorkspaceRequest& a, CreateWorkspaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateWorkspaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateWorkspaceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateWorkspaceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateWorkspaceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateWorkspaceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateWorkspaceRequest& from) {
    CreateWorkspaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateWorkspaceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.CreateWorkspaceRequest";
  }
  protected:
  explicit CreateWorkspaceRequest(::google::protobuf::Arena* arena);
  CreateWorkspaceRequest(::google::protobuf::Arena* arena, const CreateWorkspaceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkspaceFieldNumber = 1,
  };
  // .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_workspace() const;
  void clear_workspace() ;
  const ::ai::inworld::studio::v1alpha::Workspace& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::Workspace* release_workspace();
  ::ai::inworld::studio::v1alpha::Workspace* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value);
  void unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value);
  ::ai::inworld::studio::v1alpha::Workspace* unsafe_arena_release_workspace();

  private:
  const ::ai::inworld::studio::v1alpha::Workspace& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::Workspace* _internal_mutable_workspace();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.CreateWorkspaceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::Workspace* workspace_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};// -------------------------------------------------------------------

class WorkspaceLimitInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ai.inworld.studio.v1alpha.WorkspaceLimitInfo) */ {
 public:
  inline WorkspaceLimitInfo() : WorkspaceLimitInfo(nullptr) {}
  ~WorkspaceLimitInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorkspaceLimitInfo(::google::protobuf::internal::ConstantInitialized);

  inline WorkspaceLimitInfo(const WorkspaceLimitInfo& from)
      : WorkspaceLimitInfo(nullptr, from) {}
  WorkspaceLimitInfo(WorkspaceLimitInfo&& from) noexcept
    : WorkspaceLimitInfo() {
    *this = ::std::move(from);
  }

  inline WorkspaceLimitInfo& operator=(const WorkspaceLimitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkspaceLimitInfo& operator=(WorkspaceLimitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkspaceLimitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkspaceLimitInfo* internal_default_instance() {
    return reinterpret_cast<const WorkspaceLimitInfo*>(
               &_WorkspaceLimitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkspaceLimitInfo& a, WorkspaceLimitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkspaceLimitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkspaceLimitInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkspaceLimitInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkspaceLimitInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkspaceLimitInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorkspaceLimitInfo& from) {
    WorkspaceLimitInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkspaceLimitInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ai.inworld.studio.v1alpha.WorkspaceLimitInfo";
  }
  protected:
  explicit WorkspaceLimitInfo(::google::protobuf::Arena* arena);
  WorkspaceLimitInfo(::google::protobuf::Arena* arena, const WorkspaceLimitInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextListLimit = WorkspaceLimitInfo_TextListLimit;
  using CharacterLimit = WorkspaceLimitInfo_CharacterLimit;
  using SceneLimit = WorkspaceLimitInfo_SceneLimit;
  using WorkspaceLimit = WorkspaceLimitInfo_WorkspaceLimit;
  using BillingAccountLimit = WorkspaceLimitInfo_BillingAccountLimit;
  using CommonKnowledgeLimit = WorkspaceLimitInfo_CommonKnowledgeLimit;

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterFieldNumber = 1,
    kSceneFieldNumber = 2,
    kWorkspaceFieldNumber = 3,
    kBillingAccountFieldNumber = 4,
    kCommonKnowledgeFieldNumber = 5,
  };
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit character = 1;
  bool has_character() const;
  void clear_character() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& character() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* release_character();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* mutable_character();
  void set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* value);
  void unsafe_arena_set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* unsafe_arena_release_character();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& _internal_character() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* _internal_mutable_character();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit scene = 2;
  bool has_scene() const;
  void clear_scene() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& scene() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* release_scene();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* mutable_scene();
  void set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* value);
  void unsafe_arena_set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* unsafe_arena_release_scene();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& _internal_scene() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* _internal_mutable_scene();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit workspace = 3;
  bool has_workspace() const;
  void clear_workspace() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& workspace() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* release_workspace();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* mutable_workspace();
  void set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* value);
  void unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* unsafe_arena_release_workspace();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& _internal_workspace() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* _internal_mutable_workspace();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit billing_account = 4;
  bool has_billing_account() const;
  void clear_billing_account() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& billing_account() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* release_billing_account();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* mutable_billing_account();
  void set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* value);
  void unsafe_arena_set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* unsafe_arena_release_billing_account();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& _internal_billing_account() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* _internal_mutable_billing_account();

  public:
  // .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit common_knowledge = 5;
  bool has_common_knowledge() const;
  void clear_common_knowledge() ;
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& common_knowledge() const;
  PROTOBUF_NODISCARD ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* release_common_knowledge();
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* mutable_common_knowledge();
  void set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* value);
  void unsafe_arena_set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* value);
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* unsafe_arena_release_common_knowledge();

  private:
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& _internal_common_knowledge() const;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* _internal_mutable_common_knowledge();

  public:
  // @@protoc_insertion_point(class_scope:ai.inworld.studio.v1alpha.WorkspaceLimitInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* character_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* scene_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* workspace_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* billing_account_;
    ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* common_knowledge_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWorkspaceRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
}
inline std::string* GetWorkspaceRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetWorkspaceRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetWorkspaceRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetWorkspaceRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceRequest.name)
}

// .ai.inworld.studio.v1alpha.WorkspaceItemView view = 2;
inline void GetWorkspaceRequest::clear_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.view_ = 0;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceItemView GetWorkspaceRequest::view() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceRequest.view)
  return _internal_view();
}
inline void GetWorkspaceRequest::set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceRequest.view)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceItemView GetWorkspaceRequest::_internal_view() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::studio::v1alpha::WorkspaceItemView>(_impl_.view_);
}
inline void GetWorkspaceRequest::_internal_set_view(::ai::inworld::studio::v1alpha::WorkspaceItemView value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.view_ = value;
}

// -------------------------------------------------------------------

// ListWorkspacesRequest

// int32 page_size = 1;
inline void ListWorkspacesRequest::clear_page_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_size_ = 0;
}
inline ::int32_t ListWorkspacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_size)
  return _internal_page_size();
}
inline void ListWorkspacesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_size)
}
inline ::int32_t ListWorkspacesRequest::_internal_page_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_size_;
}
inline void ListWorkspacesRequest::_internal_set_page_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListWorkspacesRequest::clear_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListWorkspacesRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListWorkspacesRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
}
inline std::string* ListWorkspacesRequest::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _s;
}
inline const std::string& ListWorkspacesRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListWorkspacesRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* ListWorkspacesRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* ListWorkspacesRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListWorkspacesRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ListWorkspacesRequest.page_token)
}

// -------------------------------------------------------------------

// CreateWorkspaceRequest

// .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateWorkspaceRequest::has_workspace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.workspace_ != nullptr);
  return value;
}
inline void CreateWorkspaceRequest::clear_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.workspace_ != nullptr) _impl_.workspace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::Workspace& CreateWorkspaceRequest::_internal_workspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::Workspace* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace&>(::ai::inworld::studio::v1alpha::_Workspace_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace& CreateWorkspaceRequest::workspace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
  return _internal_workspace();
}
inline void CreateWorkspaceRequest::unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace* released = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::unsafe_arena_release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::_internal_mutable_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace>(GetArena());
    _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(p);
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::Workspace* CreateWorkspaceRequest::mutable_workspace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::Workspace* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
  return _msg;
}
inline void CreateWorkspaceRequest::set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(_impl_.workspace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.CreateWorkspaceRequest.workspace)
}

// -------------------------------------------------------------------

// UpdateWorkspaceRequest

// .ai.inworld.studio.v1alpha.Workspace workspace = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateWorkspaceRequest::has_workspace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.workspace_ != nullptr);
  return value;
}
inline void UpdateWorkspaceRequest::clear_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.workspace_ != nullptr) _impl_.workspace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::Workspace& UpdateWorkspaceRequest::_internal_workspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::Workspace* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace&>(::ai::inworld::studio::v1alpha::_Workspace_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace& UpdateWorkspaceRequest::workspace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
  return _internal_workspace();
}
inline void UpdateWorkspaceRequest::unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace* released = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::unsafe_arena_release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::_internal_mutable_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace>(GetArena());
    _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(p);
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::Workspace* UpdateWorkspaceRequest::mutable_workspace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::Workspace* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
  return _msg;
}
inline void UpdateWorkspaceRequest::set_allocated_workspace(::ai::inworld::studio::v1alpha::Workspace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(_impl_.workspace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.workspace)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateWorkspaceRequest::has_update_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& UpdateWorkspaceRequest::_internal_update_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& UpdateWorkspaceRequest::update_mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateWorkspaceRequest::unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
}
inline ::google::protobuf::FieldMask* UpdateWorkspaceRequest::release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FieldMask* UpdateWorkspaceRequest::unsafe_arena_release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* UpdateWorkspaceRequest::_internal_mutable_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FieldMask>(GetArena());
    _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.update_mask_;
}
inline ::google::protobuf::FieldMask* UpdateWorkspaceRequest::mutable_update_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
  return _msg;
}
inline void UpdateWorkspaceRequest::set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.UpdateWorkspaceRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteWorkspaceRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteWorkspaceRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteWorkspaceRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
}
inline std::string* DeleteWorkspaceRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _s;
}
inline const std::string& DeleteWorkspaceRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DeleteWorkspaceRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DeleteWorkspaceRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DeleteWorkspaceRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteWorkspaceRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.name)
}

// bool force = 2;
inline void DeleteWorkspaceRequest::clear_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_ = false;
}
inline bool DeleteWorkspaceRequest::force() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.force)
  return _internal_force();
}
inline void DeleteWorkspaceRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.DeleteWorkspaceRequest.force)
}
inline bool DeleteWorkspaceRequest::_internal_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_;
}
inline void DeleteWorkspaceRequest::_internal_set_force(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_ = value;
}

// -------------------------------------------------------------------

// CloneWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CloneWorkspaceRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CloneWorkspaceRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloneWorkspaceRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.name)
}
inline std::string* CloneWorkspaceRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.name)
  return _s;
}
inline const std::string& CloneWorkspaceRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CloneWorkspaceRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CloneWorkspaceRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CloneWorkspaceRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void CloneWorkspaceRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.name)
}

// string target_workspace = 2;
inline void CloneWorkspaceRequest::clear_target_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_workspace_.ClearToEmpty();
}
inline const std::string& CloneWorkspaceRequest::target_workspace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.target_workspace)
  return _internal_target_workspace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CloneWorkspaceRequest::set_target_workspace(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_workspace_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.target_workspace)
}
inline std::string* CloneWorkspaceRequest::mutable_target_workspace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.target_workspace)
  return _s;
}
inline const std::string& CloneWorkspaceRequest::_internal_target_workspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_workspace_.Get();
}
inline void CloneWorkspaceRequest::_internal_set_target_workspace(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_workspace_.Set(value, GetArena());
}
inline std::string* CloneWorkspaceRequest::_internal_mutable_target_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_workspace_.Mutable( GetArena());
}
inline std::string* CloneWorkspaceRequest::release_target_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.target_workspace)
  return _impl_.target_workspace_.Release();
}
inline void CloneWorkspaceRequest::set_allocated_target_workspace(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_workspace_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_workspace_.IsDefault()) {
          _impl_.target_workspace_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.CloneWorkspaceRequest.target_workspace)
}

// -------------------------------------------------------------------

// ImpressionEventRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ImpressionEventRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ImpressionEventRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ImpressionEventRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImpressionEventRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ImpressionEventRequest.name)
}
inline std::string* ImpressionEventRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ImpressionEventRequest.name)
  return _s;
}
inline const std::string& ImpressionEventRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ImpressionEventRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ImpressionEventRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ImpressionEventRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ImpressionEventRequest.name)
  return _impl_.name_.Release();
}
inline void ImpressionEventRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ImpressionEventRequest.name)
}

// repeated .ai.inworld.studio.v1alpha.ImpressionEventData data = 2;
inline int ImpressionEventRequest::_internal_data_size() const {
  return _internal_data().size();
}
inline int ImpressionEventRequest::data_size() const {
  return _internal_data_size();
}
inline ::ai::inworld::studio::v1alpha::ImpressionEventData* ImpressionEventRequest::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ImpressionEventRequest.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>* ImpressionEventRequest::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.ImpressionEventRequest.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::ai::inworld::studio::v1alpha::ImpressionEventData& ImpressionEventRequest::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ImpressionEventRequest.data)
  return _internal_data().Get(index);
}
inline ::ai::inworld::studio::v1alpha::ImpressionEventData* ImpressionEventRequest::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::studio::v1alpha::ImpressionEventData* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ImpressionEventRequest.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>& ImpressionEventRequest::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.ImpressionEventRequest.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>&
ImpressionEventRequest::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::ImpressionEventData>*
ImpressionEventRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// Workspace_Meta

// int32 total_characters = 1;
inline void Workspace_Meta::clear_total_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_characters_ = 0;
}
inline ::int32_t Workspace_Meta::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_characters)
  return _internal_total_characters();
}
inline void Workspace_Meta::set_total_characters(::int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_characters)
}
inline ::int32_t Workspace_Meta::_internal_total_characters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_characters_;
}
inline void Workspace_Meta::_internal_set_total_characters(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_characters_ = value;
}

// int32 total_scenes = 2;
inline void Workspace_Meta::clear_total_scenes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_scenes_ = 0;
}
inline ::int32_t Workspace_Meta::total_scenes() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_scenes)
  return _internal_total_scenes();
}
inline void Workspace_Meta::set_total_scenes(::int32_t value) {
  _internal_set_total_scenes(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_scenes)
}
inline ::int32_t Workspace_Meta::_internal_total_scenes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_scenes_;
}
inline void Workspace_Meta::_internal_set_total_scenes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_scenes_ = value;
}

// int32 total_triggers = 3;
inline void Workspace_Meta::clear_total_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_triggers_ = 0;
}
inline ::int32_t Workspace_Meta::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_triggers)
  return _internal_total_triggers();
}
inline void Workspace_Meta::set_total_triggers(::int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_triggers)
}
inline ::int32_t Workspace_Meta::_internal_total_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_triggers_;
}
inline void Workspace_Meta::_internal_set_total_triggers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_triggers_ = value;
}

// int32 total_common_knowledge = 4;
inline void Workspace_Meta::clear_total_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_common_knowledge_ = 0;
}
inline ::int32_t Workspace_Meta::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.Meta.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void Workspace_Meta::set_total_common_knowledge(::int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.Meta.total_common_knowledge)
}
inline ::int32_t Workspace_Meta::_internal_total_common_knowledge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_common_knowledge_;
}
inline void Workspace_Meta::_internal_set_total_common_knowledge(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_common_knowledge_ = value;
}

// -------------------------------------------------------------------

// Workspace

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.ai.inworld.options.examples) = {
inline void Workspace::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Workspace::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workspace::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.name)
}
inline std::string* Workspace::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.name)
  return _s;
}
inline const std::string& Workspace::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Workspace::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Workspace::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Workspace::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.name)
  return _impl_.name_.Release();
}
inline void Workspace::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.name)
}

// string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
inline void Workspace::clear_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Workspace::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workspace::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.display_name)
}
inline std::string* Workspace::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _s;
}
inline const std::string& Workspace::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void Workspace::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* Workspace::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* Workspace::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.display_name)
  return _impl_.display_name_.Release();
}
inline void Workspace::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.display_name)
}

// repeated string experimental_features = 3;
inline int Workspace::_internal_experimental_features_size() const {
  return _internal_experimental_features().size();
}
inline int Workspace::experimental_features_size() const {
  return _internal_experimental_features_size();
}
inline void Workspace::clear_experimental_features() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.experimental_features_.Clear();
}
inline std::string* Workspace::add_experimental_features()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_experimental_features()->Add();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _s;
}
inline const std::string& Workspace::experimental_features(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _internal_experimental_features().Get(index);
}
inline std::string* Workspace::mutable_experimental_features(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _internal_mutable_experimental_features()->Mutable(index);
}
inline void Workspace::set_experimental_features(int index, const std::string& value) {
  _internal_mutable_experimental_features()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, std::string&& value) {
  _internal_mutable_experimental_features()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_experimental_features()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_experimental_features()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::set_experimental_features(int index, absl::string_view value) {
  _internal_mutable_experimental_features()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_experimental_features()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_experimental_features()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_experimental_features()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_experimental_features()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline void Workspace::add_experimental_features(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_experimental_features()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ai.inworld.studio.v1alpha.Workspace.experimental_features)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Workspace::experimental_features() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  return _internal_experimental_features();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Workspace::mutable_experimental_features() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.Workspace.experimental_features)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_experimental_features();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Workspace::_internal_experimental_features() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.experimental_features_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Workspace::_internal_mutable_experimental_features() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.experimental_features_;
}

// string billing_account = 4 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void Workspace::clear_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.billing_account_.ClearToEmpty();
}
inline const std::string& Workspace::billing_account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _internal_billing_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workspace::set_billing_account(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.billing_account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.billing_account)
}
inline std::string* Workspace::mutable_billing_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_billing_account();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _s;
}
inline const std::string& Workspace::_internal_billing_account() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.billing_account_.Get();
}
inline void Workspace::_internal_set_billing_account(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.billing_account_.Set(value, GetArena());
}
inline std::string* Workspace::_internal_mutable_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.billing_account_.Mutable( GetArena());
}
inline std::string* Workspace::release_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.billing_account)
  return _impl_.billing_account_.Release();
}
inline void Workspace::set_allocated_billing_account(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.billing_account_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.billing_account_.IsDefault()) {
          _impl_.billing_account_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.billing_account)
}

// .ai.inworld.studio.v1alpha.Workspace.Meta meta = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Workspace::has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline void Workspace::clear_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::Workspace_Meta& Workspace::_internal_meta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::Workspace_Meta* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::Workspace_Meta&>(::ai::inworld::studio::v1alpha::_Workspace_Meta_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::Workspace_Meta& Workspace::meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.meta)
  return _internal_meta();
}
inline void Workspace::unsafe_arena_set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace_Meta*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.Workspace.meta)
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::release_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace_Meta* released = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::unsafe_arena_release_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.Workspace.meta)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::Workspace_Meta* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::_internal_mutable_meta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::Workspace_Meta>(GetArena());
    _impl_.meta_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace_Meta*>(p);
  }
  return _impl_.meta_;
}
inline ::ai::inworld::studio::v1alpha::Workspace_Meta* Workspace::mutable_meta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::Workspace_Meta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.Workspace.meta)
  return _msg;
}
inline void Workspace::set_allocated_meta(::ai::inworld::studio::v1alpha::Workspace_Meta* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace_Meta*>(_impl_.meta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace_Meta*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.meta_ = reinterpret_cast<::ai::inworld::studio::v1alpha::Workspace_Meta*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.Workspace.meta)
}

// .ai.inworld.studio.v1alpha.Workspace.RuntimeAccess runtime_access = 6;
inline void Workspace::clear_runtime_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runtime_access_ = 0;
}
inline ::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess Workspace::runtime_access() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.runtime_access)
  return _internal_runtime_access();
}
inline void Workspace::set_runtime_access(::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess value) {
  _internal_set_runtime_access(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.runtime_access)
}
inline ::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess Workspace::_internal_runtime_access() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess>(_impl_.runtime_access_);
}
inline void Workspace::_internal_set_runtime_access(::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.runtime_access_ = value;
}

// .ai.inworld.studio.v1alpha.LanguageCode primary_language_code = 7 [deprecated = true];
inline void Workspace::clear_primary_language_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_language_code_ = 0;
}
inline ::ai::inworld::studio::v1alpha::LanguageCode Workspace::primary_language_code() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.primary_language_code)
  return _internal_primary_language_code();
}
inline void Workspace::set_primary_language_code(::ai::inworld::studio::v1alpha::LanguageCode value) {
  _internal_set_primary_language_code(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.primary_language_code)
}
inline ::ai::inworld::studio::v1alpha::LanguageCode Workspace::_internal_primary_language_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::studio::v1alpha::LanguageCode>(_impl_.primary_language_code_);
}
inline void Workspace::_internal_set_primary_language_code(::ai::inworld::studio::v1alpha::LanguageCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.primary_language_code_ = value;
}

// .ai.inworld.language_codes.LanguageCode primary_language = 8;
inline void Workspace::clear_primary_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.primary_language_ = 0;
}
inline ::ai::inworld::language_codes::LanguageCode Workspace::primary_language() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.Workspace.primary_language)
  return _internal_primary_language();
}
inline void Workspace::set_primary_language(::ai::inworld::language_codes::LanguageCode value) {
  _internal_set_primary_language(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.Workspace.primary_language)
}
inline ::ai::inworld::language_codes::LanguageCode Workspace::_internal_primary_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::language_codes::LanguageCode>(_impl_.primary_language_);
}
inline void Workspace::_internal_set_primary_language(::ai::inworld::language_codes::LanguageCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.primary_language_ = value;
}

// -------------------------------------------------------------------

// ListWorkspacesResponse

// repeated .ai.inworld.studio.v1alpha.Workspace workspaces = 1;
inline int ListWorkspacesResponse::_internal_workspaces_size() const {
  return _internal_workspaces().size();
}
inline int ListWorkspacesResponse::workspaces_size() const {
  return _internal_workspaces_size();
}
inline void ListWorkspacesResponse::clear_workspaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workspaces_.Clear();
}
inline ::ai::inworld::studio::v1alpha::Workspace* ListWorkspacesResponse::mutable_workspaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _internal_mutable_workspaces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>* ListWorkspacesResponse::mutable_workspaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_workspaces();
}
inline const ::ai::inworld::studio::v1alpha::Workspace& ListWorkspacesResponse::workspaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _internal_workspaces().Get(index);
}
inline ::ai::inworld::studio::v1alpha::Workspace* ListWorkspacesResponse::add_workspaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ai::inworld::studio::v1alpha::Workspace* _add = _internal_mutable_workspaces()->Add();
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>& ListWorkspacesResponse::workspaces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.ListWorkspacesResponse.workspaces)
  return _internal_workspaces();
}
inline const ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>&
ListWorkspacesResponse::_internal_workspaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workspaces_;
}
inline ::google::protobuf::RepeatedPtrField<::ai::inworld::studio::v1alpha::Workspace>*
ListWorkspacesResponse::_internal_mutable_workspaces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.workspaces_;
}

// string next_page_token = 2;
inline void ListWorkspacesResponse::clear_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListWorkspacesResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListWorkspacesResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
}
inline std::string* ListWorkspacesResponse::mutable_next_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _s;
}
inline const std::string& ListWorkspacesResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListWorkspacesResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArena());
}
inline std::string* ListWorkspacesResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline std::string* ListWorkspacesResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListWorkspacesResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ListWorkspacesResponse.next_page_token)
}

// -------------------------------------------------------------------

// ShareWorkspaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ShareWorkspaceRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ShareWorkspaceRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShareWorkspaceRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
}
inline std::string* ShareWorkspaceRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _s;
}
inline const std::string& ShareWorkspaceRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ShareWorkspaceRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ShareWorkspaceRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ShareWorkspaceRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
  return _impl_.name_.Release();
}
inline void ShareWorkspaceRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.name)
}

// repeated string emails = 2 [(.ai.inworld.options.examples) = {
inline int ShareWorkspaceRequest::_internal_emails_size() const {
  return _internal_emails().size();
}
inline int ShareWorkspaceRequest::emails_size() const {
  return _internal_emails_size();
}
inline void ShareWorkspaceRequest::clear_emails() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emails_.Clear();
}
inline std::string* ShareWorkspaceRequest::add_emails()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_emails()->Add();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _s;
}
inline const std::string& ShareWorkspaceRequest::emails(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _internal_emails().Get(index);
}
inline std::string* ShareWorkspaceRequest::mutable_emails(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _internal_mutable_emails()->Mutable(index);
}
inline void ShareWorkspaceRequest::set_emails(int index, const std::string& value) {
  _internal_mutable_emails()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, std::string&& value) {
  _internal_mutable_emails()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_emails()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_emails()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::set_emails(int index, absl::string_view value) {
  _internal_mutable_emails()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline void ShareWorkspaceRequest::add_emails(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ShareWorkspaceRequest::emails() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  return _internal_emails();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ShareWorkspaceRequest::mutable_emails() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.ShareWorkspaceRequest.emails)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_emails();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ShareWorkspaceRequest::_internal_emails() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.emails_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ShareWorkspaceRequest::_internal_mutable_emails() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.emails_;
}

// -------------------------------------------------------------------

// GenerateResourceNameRequest

// string workspace = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GenerateResourceNameRequest::clear_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workspace_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameRequest::workspace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _internal_workspace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateResourceNameRequest::set_workspace(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.workspace_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
}
inline std::string* GenerateResourceNameRequest::mutable_workspace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _s;
}
inline const std::string& GenerateResourceNameRequest::_internal_workspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workspace_.Get();
}
inline void GenerateResourceNameRequest::_internal_set_workspace(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.workspace_.Set(value, GetArena());
}
inline std::string* GenerateResourceNameRequest::_internal_mutable_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.workspace_.Mutable( GetArena());
}
inline std::string* GenerateResourceNameRequest::release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
  return _impl_.workspace_.Release();
}
inline void GenerateResourceNameRequest::set_allocated_workspace(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workspace_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workspace_.IsDefault()) {
          _impl_.workspace_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.workspace)
}

// string display_name = 2 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameRequest::clear_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameRequest::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateResourceNameRequest::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
}
inline std::string* GenerateResourceNameRequest::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _s;
}
inline const std::string& GenerateResourceNameRequest::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void GenerateResourceNameRequest::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* GenerateResourceNameRequest::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* GenerateResourceNameRequest::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
  return _impl_.display_name_.Release();
}
inline void GenerateResourceNameRequest::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.display_name)
}

// .ai.inworld.studio.v1alpha.GenerateResourceNameRequest.ResourceType resource_type = 3 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameRequest::clear_resource_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_type_ = 0;
}
inline ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest::resource_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.resource_type)
  return _internal_resource_type();
}
inline void GenerateResourceNameRequest::set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameRequest.resource_type)
}
inline ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType GenerateResourceNameRequest::_internal_resource_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType>(_impl_.resource_type_);
}
inline void GenerateResourceNameRequest::_internal_set_resource_type(::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resource_type_ = value;
}

// -------------------------------------------------------------------

// GenerateResourceNameResponse

// string resource = 1 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateResourceNameResponse::clear_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_.ClearToEmpty();
}
inline const std::string& GenerateResourceNameResponse::resource() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _internal_resource();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenerateResourceNameResponse::set_resource(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resource_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
}
inline std::string* GenerateResourceNameResponse::mutable_resource() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _s;
}
inline const std::string& GenerateResourceNameResponse::_internal_resource() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resource_.Get();
}
inline void GenerateResourceNameResponse::_internal_set_resource(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resource_.Set(value, GetArena());
}
inline std::string* GenerateResourceNameResponse::_internal_mutable_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.resource_.Mutable( GetArena());
}
inline std::string* GenerateResourceNameResponse::release_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
  return _impl_.resource_.Release();
}
inline void GenerateResourceNameResponse::set_allocated_resource(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resource_.IsDefault()) {
          _impl_.resource_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GenerateResourceNameResponse.resource)
}

// -------------------------------------------------------------------

// GetWorkspaceShareInfoRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceShareInfoRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceShareInfoRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWorkspaceShareInfoRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
}
inline std::string* GetWorkspaceShareInfoRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceShareInfoRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetWorkspaceShareInfoRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetWorkspaceShareInfoRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetWorkspaceShareInfoRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceShareInfoRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceShareInfoRequest.name)
}

// -------------------------------------------------------------------

// WorkspaceShareInfo

// repeated string emails = 1;
inline int WorkspaceShareInfo::_internal_emails_size() const {
  return _internal_emails().size();
}
inline int WorkspaceShareInfo::emails_size() const {
  return _internal_emails_size();
}
inline void WorkspaceShareInfo::clear_emails() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emails_.Clear();
}
inline std::string* WorkspaceShareInfo::add_emails()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_emails()->Add();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _s;
}
inline const std::string& WorkspaceShareInfo::emails(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _internal_emails().Get(index);
}
inline std::string* WorkspaceShareInfo::mutable_emails(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _internal_mutable_emails()->Mutable(index);
}
inline void WorkspaceShareInfo::set_emails(int index, const std::string& value) {
  _internal_mutable_emails()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, std::string&& value) {
  _internal_mutable_emails()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_emails()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_emails()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::set_emails(int index, absl::string_view value) {
  _internal_mutable_emails()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline void WorkspaceShareInfo::add_emails(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_emails()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WorkspaceShareInfo::emails() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  return _internal_emails();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WorkspaceShareInfo::mutable_emails() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.studio.v1alpha.WorkspaceShareInfo.emails)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_emails();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WorkspaceShareInfo::_internal_emails() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.emails_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WorkspaceShareInfo::_internal_mutable_emails() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.emails_;
}

// -------------------------------------------------------------------

// GetWorkspaceLimitInfoRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetWorkspaceLimitInfoRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetWorkspaceLimitInfoRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWorkspaceLimitInfoRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
}
inline std::string* GetWorkspaceLimitInfoRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _s;
}
inline const std::string& GetWorkspaceLimitInfoRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetWorkspaceLimitInfoRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetWorkspaceLimitInfoRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetWorkspaceLimitInfoRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetWorkspaceLimitInfoRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.GetWorkspaceLimitInfoRequest.name)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_TextListLimit

// int32 item_max_length = 1;
inline void WorkspaceLimitInfo_TextListLimit::clear_item_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_TextListLimit::item_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.item_max_length)
  return _internal_item_max_length();
}
inline void WorkspaceLimitInfo_TextListLimit::set_item_max_length(::int32_t value) {
  _internal_set_item_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.item_max_length)
}
inline ::int32_t WorkspaceLimitInfo_TextListLimit::_internal_item_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_max_length_;
}
inline void WorkspaceLimitInfo_TextListLimit::_internal_set_item_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_max_length_ = value;
}

// int32 total_items = 2;
inline void WorkspaceLimitInfo_TextListLimit::clear_total_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_items_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_TextListLimit::total_items() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.total_items)
  return _internal_total_items();
}
inline void WorkspaceLimitInfo_TextListLimit::set_total_items(::int32_t value) {
  _internal_set_total_items(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit.total_items)
}
inline ::int32_t WorkspaceLimitInfo_TextListLimit::_internal_total_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_items_;
}
inline void WorkspaceLimitInfo_TextListLimit::_internal_set_total_items(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_items_ = value;
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit

// int32 core_max_length = 1;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_core_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.core_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::core_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.core_max_length)
  return _internal_core_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_core_max_length(::int32_t value) {
  _internal_set_core_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.core_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_core_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.core_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_core_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.core_max_length_ = value;
}

// int32 example_dialog_max_length = 2;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_example_dialog_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.example_dialog_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::example_dialog_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.example_dialog_max_length)
  return _internal_example_dialog_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_example_dialog_max_length(::int32_t value) {
  _internal_set_example_dialog_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.example_dialog_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_example_dialog_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.example_dialog_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_example_dialog_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.example_dialog_max_length_ = value;
}

// int32 motivation_max_length = 3;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_motivation_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.motivation_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::motivation_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.motivation_max_length)
  return _internal_motivation_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_motivation_max_length(::int32_t value) {
  _internal_set_motivation_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.motivation_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_motivation_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.motivation_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_motivation_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.motivation_max_length_ = value;
}

// int32 character_role_max_length = 4;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_character_role_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_role_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::character_role_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.character_role_max_length)
  return _internal_character_role_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_character_role_max_length(::int32_t value) {
  _internal_set_character_role_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.character_role_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_character_role_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_role_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_character_role_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_role_max_length_ = value;
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit hobby_or_interests = 5;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_hobby_or_interests() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hobby_or_interests_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_hobby_or_interests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hobby_or_interests_ != nullptr) _impl_.hobby_or_interests_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_hobby_or_interests() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.hobby_or_interests_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::hobby_or_interests() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
  return _internal_hobby_or_interests();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hobby_or_interests_);
  }
  _impl_.hobby_or_interests_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_hobby_or_interests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* released = _impl_.hobby_or_interests_;
  _impl_.hobby_or_interests_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_hobby_or_interests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.hobby_or_interests_;
  _impl_.hobby_or_interests_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_hobby_or_interests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hobby_or_interests_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArena());
    _impl_.hobby_or_interests_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(p);
  }
  return _impl_.hobby_or_interests_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_hobby_or_interests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_hobby_or_interests();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_hobby_or_interests(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(_impl_.hobby_or_interests_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hobby_or_interests_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.hobby_or_interests)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit nicknames = 6;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_nicknames() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nicknames_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_nicknames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.nicknames_ != nullptr) _impl_.nicknames_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_nicknames() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.nicknames_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::nicknames() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
  return _internal_nicknames();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nicknames_);
  }
  _impl_.nicknames_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_nicknames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* released = _impl_.nicknames_;
  _impl_.nicknames_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_nicknames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.nicknames_;
  _impl_.nicknames_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_nicknames() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.nicknames_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArena());
    _impl_.nicknames_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(p);
  }
  return _impl_.nicknames_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_nicknames() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_nicknames();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_nicknames(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(_impl_.nicknames_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.nicknames_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.nicknames)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit personality_adjectives = 7;
inline bool WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::has_personality_adjectives() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.personality_adjectives_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_personality_adjectives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.personality_adjectives_ != nullptr) _impl_.personality_adjectives_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_personality_adjectives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.personality_adjectives_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::personality_adjectives() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
  return _internal_personality_adjectives();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.personality_adjectives_);
  }
  _impl_.personality_adjectives_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::release_personality_adjectives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* released = _impl_.personality_adjectives_;
  _impl_.personality_adjectives_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::unsafe_arena_release_personality_adjectives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.personality_adjectives_;
  _impl_.personality_adjectives_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_mutable_personality_adjectives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.personality_adjectives_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArena());
    _impl_.personality_adjectives_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(p);
  }
  return _impl_.personality_adjectives_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::mutable_personality_adjectives() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_personality_adjectives();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_allocated_personality_adjectives(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(_impl_.personality_adjectives_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.personality_adjectives_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.personality_adjectives)
}

// int32 flaws_max_length = 8;
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::clear_flaws_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flaws_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::flaws_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.flaws_max_length)
  return _internal_flaws_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::set_flaws_max_length(::int32_t value) {
  _internal_set_flaws_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit.flaws_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_flaws_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flaws_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit::_internal_set_flaws_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flaws_max_length_ = value;
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CharacterLimit

// int32 name_max_length = 1;
inline void WorkspaceLimitInfo_CharacterLimit::clear_name_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.name_max_length)
  return _internal_name_max_length();
}
inline void WorkspaceLimitInfo_CharacterLimit::set_name_max_length(::int32_t value) {
  _internal_set_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.name_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::_internal_name_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_max_length_;
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_name_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_max_length_ = value;
}

// int32 total_triggers = 2;
inline void WorkspaceLimitInfo_CharacterLimit::clear_total_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_triggers_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_CharacterLimit::set_total_triggers(::int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_triggers)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::_internal_total_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_triggers_;
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_total_triggers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_triggers_ = value;
}

// int32 total_common_knowledge = 3;
inline void WorkspaceLimitInfo_CharacterLimit::clear_total_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_common_knowledge_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void WorkspaceLimitInfo_CharacterLimit::set_total_common_knowledge(::int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.total_common_knowledge)
}
inline ::int32_t WorkspaceLimitInfo_CharacterLimit::_internal_total_common_knowledge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_common_knowledge_;
}
inline void WorkspaceLimitInfo_CharacterLimit::_internal_set_total_common_knowledge(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_common_knowledge_ = value;
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.CharacterDescriptionLimit character_description = 4;
inline bool WorkspaceLimitInfo_CharacterLimit::has_character_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_description_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo_CharacterLimit::clear_character_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.character_description_ != nullptr) _impl_.character_description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& WorkspaceLimitInfo_CharacterLimit::_internal_character_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* p = _impl_.character_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit& WorkspaceLimitInfo_CharacterLimit::character_description() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
  return _internal_character_description();
}
inline void WorkspaceLimitInfo_CharacterLimit::unsafe_arena_set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_description_);
  }
  _impl_.character_description_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::release_character_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* released = _impl_.character_description_;
  _impl_.character_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::unsafe_arena_release_character_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* temp = _impl_.character_description_;
  _impl_.character_description_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::_internal_mutable_character_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.character_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit>(GetArena());
    _impl_.character_description_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(p);
  }
  return _impl_.character_description_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* WorkspaceLimitInfo_CharacterLimit::mutable_character_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* _msg = _internal_mutable_character_description();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
  return _msg;
}
inline void WorkspaceLimitInfo_CharacterLimit::set_allocated_character_description(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(_impl_.character_description_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_description_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit_CharacterDescriptionLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit.character_description)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_SceneLimit

// int32 description_max_length = 1;
inline void WorkspaceLimitInfo_SceneLimit::clear_description_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::description_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.description_max_length)
  return _internal_description_max_length();
}
inline void WorkspaceLimitInfo_SceneLimit::set_description_max_length(::int32_t value) {
  _internal_set_description_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.description_max_length)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_description_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_max_length_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_description_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_max_length_ = value;
}

// int32 total_characters = 2;
inline void WorkspaceLimitInfo_SceneLimit::clear_total_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_characters_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_characters)
  return _internal_total_characters();
}
inline void WorkspaceLimitInfo_SceneLimit::set_total_characters(::int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_characters)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_total_characters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_characters_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_total_characters(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_characters_ = value;
}

// int32 total_triggers = 3;
inline void WorkspaceLimitInfo_SceneLimit::clear_total_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_triggers_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_SceneLimit::set_total_triggers(::int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_triggers)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_total_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_triggers_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_total_triggers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_triggers_ = value;
}

// int32 display_name_max_length = 4;
inline void WorkspaceLimitInfo_SceneLimit::clear_display_name_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_SceneLimit::set_display_name_max_length(::int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.display_name_max_length)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_display_name_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_max_length_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_display_name_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_max_length_ = value;
}

// int32 total_common_knowledge = 5;
inline void WorkspaceLimitInfo_SceneLimit::clear_total_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_common_knowledge_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void WorkspaceLimitInfo_SceneLimit::set_total_common_knowledge(::int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.total_common_knowledge)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_total_common_knowledge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_common_knowledge_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_total_common_knowledge(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_common_knowledge_ = value;
}

// int32 scene_trigger_description_max_length = 6;
inline void WorkspaceLimitInfo_SceneLimit::clear_scene_trigger_description_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_trigger_description_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::scene_trigger_description_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.scene_trigger_description_max_length)
  return _internal_scene_trigger_description_max_length();
}
inline void WorkspaceLimitInfo_SceneLimit::set_scene_trigger_description_max_length(::int32_t value) {
  _internal_set_scene_trigger_description_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit.scene_trigger_description_max_length)
}
inline ::int32_t WorkspaceLimitInfo_SceneLimit::_internal_scene_trigger_description_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_trigger_description_max_length_;
}
inline void WorkspaceLimitInfo_SceneLimit::_internal_set_scene_trigger_description_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scene_trigger_description_max_length_ = value;
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_WorkspaceLimit

// int32 display_name_max_length = 1;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_display_name_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_display_name_max_length(::int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.display_name_max_length)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_display_name_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_max_length_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_display_name_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_max_length_ = value;
}

// int32 total_characters = 2;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_characters_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::total_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_characters)
  return _internal_total_characters();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_characters(::int32_t value) {
  _internal_set_total_characters(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_characters)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_characters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_characters_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_characters(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_characters_ = value;
}

// int32 total_scenes = 3;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_scenes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_scenes_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::total_scenes() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_scenes)
  return _internal_total_scenes();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_scenes(::int32_t value) {
  _internal_set_total_scenes(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_scenes)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_scenes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_scenes_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_scenes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_scenes_ = value;
}

// int32 total_triggers = 4;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_triggers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_triggers_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::total_triggers() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_triggers)
  return _internal_total_triggers();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_triggers(::int32_t value) {
  _internal_set_total_triggers(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_triggers)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_triggers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_triggers_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_triggers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_triggers_ = value;
}

// int32 total_voices = 5;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_voices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_voices_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::total_voices() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_voices)
  return _internal_total_voices();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_voices(::int32_t value) {
  _internal_set_total_voices(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_voices)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_voices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_voices_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_voices(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_voices_ = value;
}

// int32 total_common_knowledge = 6;
inline void WorkspaceLimitInfo_WorkspaceLimit::clear_total_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_common_knowledge_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::total_common_knowledge() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_common_knowledge)
  return _internal_total_common_knowledge();
}
inline void WorkspaceLimitInfo_WorkspaceLimit::set_total_common_knowledge(::int32_t value) {
  _internal_set_total_common_knowledge(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit.total_common_knowledge)
}
inline ::int32_t WorkspaceLimitInfo_WorkspaceLimit::_internal_total_common_knowledge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_common_knowledge_;
}
inline void WorkspaceLimitInfo_WorkspaceLimit::_internal_set_total_common_knowledge(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_common_knowledge_ = value;
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_BillingAccountLimit

// int32 total_workspaces = 1;
inline void WorkspaceLimitInfo_BillingAccountLimit::clear_total_workspaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_workspaces_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_BillingAccountLimit::total_workspaces() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit.total_workspaces)
  return _internal_total_workspaces();
}
inline void WorkspaceLimitInfo_BillingAccountLimit::set_total_workspaces(::int32_t value) {
  _internal_set_total_workspaces(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit.total_workspaces)
}
inline ::int32_t WorkspaceLimitInfo_BillingAccountLimit::_internal_total_workspaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_workspaces_;
}
inline void WorkspaceLimitInfo_BillingAccountLimit::_internal_set_total_workspaces(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_workspaces_ = value;
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo_CommonKnowledgeLimit

// int32 display_name_max_length = 1;
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_display_name_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::display_name_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.display_name_max_length)
  return _internal_display_name_max_length();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_display_name_max_length(::int32_t value) {
  _internal_set_display_name_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.display_name_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_display_name_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_max_length_;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_set_display_name_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_max_length_ = value;
}

// int32 description_max_length = 2;
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_description_max_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_max_length_ = 0;
}
inline ::int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::description_max_length() const {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.description_max_length)
  return _internal_description_max_length();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_description_max_length(::int32_t value) {
  _internal_set_description_max_length(value);
  // @@protoc_insertion_point(field_set:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.description_max_length)
}
inline ::int32_t WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_description_max_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_max_length_;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_set_description_max_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_max_length_ = value;
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.TextListLimit memory_records = 3;
inline bool WorkspaceLimitInfo_CommonKnowledgeLimit::has_memory_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.memory_records_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::clear_memory_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.memory_records_ != nullptr) _impl_.memory_records_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_memory_records() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* p = _impl_.memory_records_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_TextListLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit& WorkspaceLimitInfo_CommonKnowledgeLimit::memory_records() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
  return _internal_memory_records();
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::unsafe_arena_set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.memory_records_);
  }
  _impl_.memory_records_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::release_memory_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* released = _impl_.memory_records_;
  _impl_.memory_records_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::unsafe_arena_release_memory_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* temp = _impl_.memory_records_;
  _impl_.memory_records_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::_internal_mutable_memory_records() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.memory_records_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit>(GetArena());
    _impl_.memory_records_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(p);
  }
  return _impl_.memory_records_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* WorkspaceLimitInfo_CommonKnowledgeLimit::mutable_memory_records() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* _msg = _internal_mutable_memory_records();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
  return _msg;
}
inline void WorkspaceLimitInfo_CommonKnowledgeLimit::set_allocated_memory_records(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(_impl_.memory_records_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.memory_records_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_TextListLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit.memory_records)
}

// -------------------------------------------------------------------

// WorkspaceLimitInfo

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CharacterLimit character = 1;
inline bool WorkspaceLimitInfo::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo::clear_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& WorkspaceLimitInfo::_internal_character() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CharacterLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit& WorkspaceLimitInfo::character() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
  return _internal_character();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::release_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* released = _impl_.character_;
  _impl_.character_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::unsafe_arena_release_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::_internal_mutable_character() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.character_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit>(GetArena());
    _impl_.character_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit*>(p);
  }
  return _impl_.character_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* WorkspaceLimitInfo::mutable_character() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_character(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit*>(_impl_.character_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.character_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CharacterLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.character)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.SceneLimit scene = 2;
inline bool WorkspaceLimitInfo::has_scene() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scene_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo::clear_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.scene_ != nullptr) _impl_.scene_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& WorkspaceLimitInfo::_internal_scene() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* p = _impl_.scene_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_SceneLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit& WorkspaceLimitInfo::scene() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
  return _internal_scene();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scene_);
  }
  _impl_.scene_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::release_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* released = _impl_.scene_;
  _impl_.scene_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::unsafe_arena_release_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* temp = _impl_.scene_;
  _impl_.scene_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::_internal_mutable_scene() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.scene_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit>(GetArena());
    _impl_.scene_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit*>(p);
  }
  return _impl_.scene_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* WorkspaceLimitInfo::mutable_scene() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* _msg = _internal_mutable_scene();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_scene(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit*>(_impl_.scene_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.scene_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_SceneLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.scene)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.WorkspaceLimit workspace = 3;
inline bool WorkspaceLimitInfo::has_workspace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.workspace_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo::clear_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.workspace_ != nullptr) _impl_.workspace_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& WorkspaceLimitInfo::_internal_workspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* p = _impl_.workspace_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_WorkspaceLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit& WorkspaceLimitInfo::workspace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
  return _internal_workspace();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.workspace_);
  }
  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* released = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::unsafe_arena_release_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* temp = _impl_.workspace_;
  _impl_.workspace_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::_internal_mutable_workspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.workspace_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit>(GetArena());
    _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit*>(p);
  }
  return _impl_.workspace_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* WorkspaceLimitInfo::mutable_workspace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* _msg = _internal_mutable_workspace();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_workspace(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit*>(_impl_.workspace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.workspace_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_WorkspaceLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.workspace)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.BillingAccountLimit billing_account = 4;
inline bool WorkspaceLimitInfo::has_billing_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.billing_account_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo::clear_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.billing_account_ != nullptr) _impl_.billing_account_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& WorkspaceLimitInfo::_internal_billing_account() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* p = _impl_.billing_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_BillingAccountLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit& WorkspaceLimitInfo::billing_account() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
  return _internal_billing_account();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.billing_account_);
  }
  _impl_.billing_account_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::release_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* released = _impl_.billing_account_;
  _impl_.billing_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::unsafe_arena_release_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* temp = _impl_.billing_account_;
  _impl_.billing_account_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::_internal_mutable_billing_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.billing_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit>(GetArena());
    _impl_.billing_account_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit*>(p);
  }
  return _impl_.billing_account_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* WorkspaceLimitInfo::mutable_billing_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* _msg = _internal_mutable_billing_account();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_billing_account(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit*>(_impl_.billing_account_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.billing_account_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_BillingAccountLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.billing_account)
}

// .ai.inworld.studio.v1alpha.WorkspaceLimitInfo.CommonKnowledgeLimit common_knowledge = 5;
inline bool WorkspaceLimitInfo::has_common_knowledge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_knowledge_ != nullptr);
  return value;
}
inline void WorkspaceLimitInfo::clear_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.common_knowledge_ != nullptr) _impl_.common_knowledge_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& WorkspaceLimitInfo::_internal_common_knowledge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* p = _impl_.common_knowledge_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit&>(::ai::inworld::studio::v1alpha::_WorkspaceLimitInfo_CommonKnowledgeLimit_default_instance_);
}
inline const ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit& WorkspaceLimitInfo::common_knowledge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
  return _internal_common_knowledge();
}
inline void WorkspaceLimitInfo::unsafe_arena_set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_knowledge_);
  }
  _impl_.common_knowledge_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::release_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* released = _impl_.common_knowledge_;
  _impl_.common_knowledge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::unsafe_arena_release_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* temp = _impl_.common_knowledge_;
  _impl_.common_knowledge_ = nullptr;
  return temp;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::_internal_mutable_common_knowledge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.common_knowledge_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit>(GetArena());
    _impl_.common_knowledge_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit*>(p);
  }
  return _impl_.common_knowledge_;
}
inline ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* WorkspaceLimitInfo::mutable_common_knowledge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* _msg = _internal_mutable_common_knowledge();
  // @@protoc_insertion_point(field_mutable:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
  return _msg;
}
inline void WorkspaceLimitInfo::set_allocated_common_knowledge(::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit*>(_impl_.common_knowledge_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.common_knowledge_ = reinterpret_cast<::ai::inworld::studio::v1alpha::WorkspaceLimitInfo_CommonKnowledgeLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.studio.v1alpha.WorkspaceLimitInfo.common_knowledge)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha
}  // namespace studio
}  // namespace inworld
}  // namespace ai


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess>() {
  return ::ai::inworld::studio::v1alpha::Workspace_RuntimeAccess_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType>() {
  return ::ai::inworld::studio::v1alpha::GenerateResourceNameRequest_ResourceType_descriptor();
}
template <>
struct is_proto_enum<::ai::inworld::studio::v1alpha::WorkspaceItemView> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ai::inworld::studio::v1alpha::WorkspaceItemView>() {
  return ::ai::inworld::studio::v1alpha::WorkspaceItemView_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fstudio_2fv1alpha_2fworkspaces_2eproto_2epb_2eh
