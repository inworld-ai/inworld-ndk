// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_packets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packets_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packets_2eproto;
namespace ai {
namespace inworld {
namespace packets {
class ActionEvent;
struct ActionEventDefaultTypeInternal;
extern ActionEventDefaultTypeInternal _ActionEvent_default_instance_;
class Actor;
struct ActorDefaultTypeInternal;
extern ActorDefaultTypeInternal _Actor_default_instance_;
class AdditionalPhonemeInfo;
struct AdditionalPhonemeInfoDefaultTypeInternal;
extern AdditionalPhonemeInfoDefaultTypeInternal _AdditionalPhonemeInfo_default_instance_;
class ApplyResponse;
struct ApplyResponseDefaultTypeInternal;
extern ApplyResponseDefaultTypeInternal _ApplyResponse_default_instance_;
class CancelResponses;
struct CancelResponsesDefaultTypeInternal;
extern CancelResponsesDefaultTypeInternal _CancelResponses_default_instance_;
class CancelResponsesEvent;
struct CancelResponsesEventDefaultTypeInternal;
extern CancelResponsesEventDefaultTypeInternal _CancelResponsesEvent_default_instance_;
class ControlEvent;
struct ControlEventDefaultTypeInternal;
extern ControlEventDefaultTypeInternal _ControlEvent_default_instance_;
class CustomEvent;
struct CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class CustomEvent_Parameter;
struct CustomEvent_ParameterDefaultTypeInternal;
extern CustomEvent_ParameterDefaultTypeInternal _CustomEvent_Parameter_default_instance_;
class DataChunk;
struct DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class DebugInfoEvent;
struct DebugInfoEventDefaultTypeInternal;
extern DebugInfoEventDefaultTypeInternal _DebugInfoEvent_default_instance_;
class EmotionEvent;
struct EmotionEventDefaultTypeInternal;
extern EmotionEventDefaultTypeInternal _EmotionEvent_default_instance_;
class InworldPacket;
struct InworldPacketDefaultTypeInternal;
extern InworldPacketDefaultTypeInternal _InworldPacket_default_instance_;
class LoadScene;
struct LoadSceneDefaultTypeInternal;
extern LoadSceneDefaultTypeInternal _LoadScene_default_instance_;
class LoadSceneOutputEvent;
struct LoadSceneOutputEventDefaultTypeInternal;
extern LoadSceneOutputEventDefaultTypeInternal _LoadSceneOutputEvent_default_instance_;
class LoadSceneOutputEvent_Agent;
struct LoadSceneOutputEvent_AgentDefaultTypeInternal;
extern LoadSceneOutputEvent_AgentDefaultTypeInternal _LoadSceneOutputEvent_Agent_default_instance_;
class ModifyExactResponse;
struct ModifyExactResponseDefaultTypeInternal;
extern ModifyExactResponseDefaultTypeInternal _ModifyExactResponse_default_instance_;
class MutationEvent;
struct MutationEventDefaultTypeInternal;
extern MutationEventDefaultTypeInternal _MutationEvent_default_instance_;
class NarratedAction;
struct NarratedActionDefaultTypeInternal;
extern NarratedActionDefaultTypeInternal _NarratedAction_default_instance_;
class PacketId;
struct PacketIdDefaultTypeInternal;
extern PacketIdDefaultTypeInternal _PacketId_default_instance_;
class RegenerateResponse;
struct RegenerateResponseDefaultTypeInternal;
extern RegenerateResponseDefaultTypeInternal _RegenerateResponse_default_instance_;
class RelationInfo;
struct RelationInfoDefaultTypeInternal;
extern RelationInfoDefaultTypeInternal _RelationInfo_default_instance_;
class RelationInfo_RelationAttributes;
struct RelationInfo_RelationAttributesDefaultTypeInternal;
extern RelationInfo_RelationAttributesDefaultTypeInternal _RelationInfo_RelationAttributes_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class TextEvent;
struct TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
}  // namespace packets
}  // namespace inworld
}  // namespace ai
PROTOBUF_NAMESPACE_OPEN
template<> ::ai::inworld::packets::ActionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ActionEvent>(Arena*);
template<> ::ai::inworld::packets::Actor* Arena::CreateMaybeMessage<::ai::inworld::packets::Actor>(Arena*);
template<> ::ai::inworld::packets::AdditionalPhonemeInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::AdditionalPhonemeInfo>(Arena*);
template<> ::ai::inworld::packets::ApplyResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ApplyResponse>(Arena*);
template<> ::ai::inworld::packets::CancelResponses* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponses>(Arena*);
template<> ::ai::inworld::packets::CancelResponsesEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponsesEvent>(Arena*);
template<> ::ai::inworld::packets::ControlEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ControlEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent_Parameter* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent_Parameter>(Arena*);
template<> ::ai::inworld::packets::DataChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::DataChunk>(Arena*);
template<> ::ai::inworld::packets::DebugInfoEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::DebugInfoEvent>(Arena*);
template<> ::ai::inworld::packets::EmotionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::EmotionEvent>(Arena*);
template<> ::ai::inworld::packets::InworldPacket* Arena::CreateMaybeMessage<::ai::inworld::packets::InworldPacket>(Arena*);
template<> ::ai::inworld::packets::LoadScene* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadScene>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent_Agent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent_Agent>(Arena*);
template<> ::ai::inworld::packets::ModifyExactResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ModifyExactResponse>(Arena*);
template<> ::ai::inworld::packets::MutationEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::MutationEvent>(Arena*);
template<> ::ai::inworld::packets::NarratedAction* Arena::CreateMaybeMessage<::ai::inworld::packets::NarratedAction>(Arena*);
template<> ::ai::inworld::packets::PacketId* Arena::CreateMaybeMessage<::ai::inworld::packets::PacketId>(Arena*);
template<> ::ai::inworld::packets::RegenerateResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::RegenerateResponse>(Arena*);
template<> ::ai::inworld::packets::RelationInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo>(Arena*);
template<> ::ai::inworld::packets::RelationInfo_RelationAttributes* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(Arena*);
template<> ::ai::inworld::packets::Routing* Arena::CreateMaybeMessage<::ai::inworld::packets::Routing>(Arena*);
template<> ::ai::inworld::packets::TextEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ai {
namespace inworld {
namespace packets {

enum Actor_Type : int {
  Actor_Type_UNKNOWN = 0,
  Actor_Type_PLAYER = 1,
  Actor_Type_AGENT = 2,
  Actor_Type_Actor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Actor_Type_Actor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Actor_Type_IsValid(int value);
constexpr Actor_Type Actor_Type_Type_MIN = Actor_Type_UNKNOWN;
constexpr Actor_Type Actor_Type_Type_MAX = Actor_Type_AGENT;
constexpr int Actor_Type_Type_ARRAYSIZE = Actor_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Actor_Type_descriptor();
template<typename T>
inline const std::string& Actor_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Actor_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Actor_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Actor_Type_descriptor(), enum_t_value);
}
inline bool Actor_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Actor_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Actor_Type>(
    Actor_Type_descriptor(), name, value);
}
enum TextEvent_SourceType : int {
  TextEvent_SourceType_UNKNOWN = 0,
  TextEvent_SourceType_SPEECH_TO_TEXT = 1,
  TextEvent_SourceType_TYPED_IN = 2,
  TextEvent_SourceType_GENERATED = 3,
  TextEvent_SourceType_FILLER = 4,
  TextEvent_SourceType_TextEvent_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TextEvent_SourceType_TextEvent_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TextEvent_SourceType_IsValid(int value);
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MIN = TextEvent_SourceType_UNKNOWN;
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MAX = TextEvent_SourceType_FILLER;
constexpr int TextEvent_SourceType_SourceType_ARRAYSIZE = TextEvent_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextEvent_SourceType_descriptor();
template<typename T>
inline const std::string& TextEvent_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextEvent_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextEvent_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextEvent_SourceType_descriptor(), enum_t_value);
}
inline bool TextEvent_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextEvent_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextEvent_SourceType>(
    TextEvent_SourceType_descriptor(), name, value);
}
enum ControlEvent_Action : int {
  ControlEvent_Action_UNKNOWN = 0,
  ControlEvent_Action_AUDIO_SESSION_START = 1,
  ControlEvent_Action_AUDIO_SESSION_END = 2,
  ControlEvent_Action_INTERACTION_END = 3,
  ControlEvent_Action_TTS_PLAYBACK_START = 4,
  ControlEvent_Action_TTS_PLAYBACK_END = 5,
  ControlEvent_Action_TTS_PLAYBACK_MUTE = 6,
  ControlEvent_Action_TTS_PLAYBACK_UNMUTE = 7,
  ControlEvent_Action_WARNING = 8,
  ControlEvent_Action_SESSION_END = 9,
  ControlEvent_Action_ControlEvent_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ControlEvent_Action_ControlEvent_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ControlEvent_Action_IsValid(int value);
constexpr ControlEvent_Action ControlEvent_Action_Action_MIN = ControlEvent_Action_UNKNOWN;
constexpr ControlEvent_Action ControlEvent_Action_Action_MAX = ControlEvent_Action_SESSION_END;
constexpr int ControlEvent_Action_Action_ARRAYSIZE = ControlEvent_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlEvent_Action_descriptor();
template<typename T>
inline const std::string& ControlEvent_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlEvent_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlEvent_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlEvent_Action_descriptor(), enum_t_value);
}
inline bool ControlEvent_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlEvent_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlEvent_Action>(
    ControlEvent_Action_descriptor(), name, value);
}
enum EmotionEvent_SpaffCode : int {
  EmotionEvent_SpaffCode_NEUTRAL = 0,
  EmotionEvent_SpaffCode_DISGUST = 1,
  EmotionEvent_SpaffCode_CONTEMPT = 2,
  EmotionEvent_SpaffCode_BELLIGERENCE = 3,
  EmotionEvent_SpaffCode_DOMINEERING = 4,
  EmotionEvent_SpaffCode_CRITICISM = 5,
  EmotionEvent_SpaffCode_ANGER = 6,
  EmotionEvent_SpaffCode_TENSION = 7,
  EmotionEvent_SpaffCode_TENSE_HUMOR = 8,
  EmotionEvent_SpaffCode_DEFENSIVENESS = 9,
  EmotionEvent_SpaffCode_WHINING = 10,
  EmotionEvent_SpaffCode_SADNESS = 11,
  EmotionEvent_SpaffCode_STONEWALLING = 12,
  EmotionEvent_SpaffCode_INTEREST = 13,
  EmotionEvent_SpaffCode_VALIDATION = 14,
  EmotionEvent_SpaffCode_AFFECTION = 15,
  EmotionEvent_SpaffCode_HUMOR = 16,
  EmotionEvent_SpaffCode_SURPRISE = 17,
  EmotionEvent_SpaffCode_JOY = 18,
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EmotionEvent_SpaffCode_IsValid(int value);
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MIN = EmotionEvent_SpaffCode_NEUTRAL;
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MAX = EmotionEvent_SpaffCode_JOY;
constexpr int EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE = EmotionEvent_SpaffCode_SpaffCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_SpaffCode_descriptor();
template<typename T>
inline const std::string& EmotionEvent_SpaffCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_SpaffCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_SpaffCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_SpaffCode_descriptor(), enum_t_value);
}
inline bool EmotionEvent_SpaffCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_SpaffCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_SpaffCode>(
    EmotionEvent_SpaffCode_descriptor(), name, value);
}
enum EmotionEvent_Strength : int {
  EmotionEvent_Strength_UNSPECIFIED = 0,
  EmotionEvent_Strength_WEAK = 1,
  EmotionEvent_Strength_STRONG = 2,
  EmotionEvent_Strength_NORMAL = 3,
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EmotionEvent_Strength_IsValid(int value);
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MIN = EmotionEvent_Strength_UNSPECIFIED;
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MAX = EmotionEvent_Strength_NORMAL;
constexpr int EmotionEvent_Strength_Strength_ARRAYSIZE = EmotionEvent_Strength_Strength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_Strength_descriptor();
template<typename T>
inline const std::string& EmotionEvent_Strength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_Strength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_Strength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_Strength_descriptor(), enum_t_value);
}
inline bool EmotionEvent_Strength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_Strength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_Strength>(
    EmotionEvent_Strength_descriptor(), name, value);
}
enum DataChunk_DataType : int {
  DataChunk_DataType_UNSPECIFIED = 0,
  DataChunk_DataType_AUDIO = 1,
  DataChunk_DataType_ANIMATION = 2,
  DataChunk_DataType_SILENCE = 3,
  DataChunk_DataType_STATE = 4,
  DataChunk_DataType_DataChunk_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataChunk_DataType_DataChunk_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataChunk_DataType_IsValid(int value);
constexpr DataChunk_DataType DataChunk_DataType_DataType_MIN = DataChunk_DataType_UNSPECIFIED;
constexpr DataChunk_DataType DataChunk_DataType_DataType_MAX = DataChunk_DataType_STATE;
constexpr int DataChunk_DataType_DataType_ARRAYSIZE = DataChunk_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_DataType_descriptor();
template<typename T>
inline const std::string& DataChunk_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_DataType_descriptor(), enum_t_value);
}
inline bool DataChunk_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_DataType>(
    DataChunk_DataType_descriptor(), name, value);
}
enum Playback : int {
  UNSPECIFIED = 0,
  INTERACTION = 1,
  INTERACTION_END = 2,
  UTTERANCE = 3,
  Playback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Playback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Playback_IsValid(int value);
constexpr Playback Playback_MIN = UNSPECIFIED;
constexpr Playback Playback_MAX = UTTERANCE;
constexpr int Playback_ARRAYSIZE = Playback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Playback_descriptor();
template<typename T>
inline const std::string& Playback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Playback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Playback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Playback_descriptor(), enum_t_value);
}
inline bool Playback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Playback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Playback>(
    Playback_descriptor(), name, value);
}
// ===================================================================

class Actor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Actor) */ {
 public:
  inline Actor() : Actor(nullptr) {}
  ~Actor() override;
  explicit PROTOBUF_CONSTEXPR Actor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Actor(const Actor& from);
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actor& operator=(Actor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Actor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }
  inline void Swap(Actor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Actor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Actor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Actor& from) {
    Actor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Actor";
  }
  protected:
  explicit Actor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Actor_Type Type;
  static constexpr Type UNKNOWN =
    Actor_Type_UNKNOWN;
  static constexpr Type PLAYER =
    Actor_Type_PLAYER;
  static constexpr Type AGENT =
    Actor_Type_AGENT;
  static inline bool Type_IsValid(int value) {
    return Actor_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Actor_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Actor_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Actor_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Actor_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Actor_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Actor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Actor.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::Actor_Type type() const;
  void set_type(::ai::inworld::packets::Actor_Type value);
  private:
  ::ai::inworld::packets::Actor_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::Actor_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Actor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class Routing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  explicit PROTOBUF_CONSTEXPR Routing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Routing& from) {
    Routing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // .ai.inworld.packets.Actor source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::ai::inworld::packets::Actor& source() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_source();
  ::ai::inworld::packets::Actor* mutable_source();
  void set_allocated_source(::ai::inworld::packets::Actor* source);
  private:
  const ::ai::inworld::packets::Actor& _internal_source() const;
  ::ai::inworld::packets::Actor* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::ai::inworld::packets::Actor* source);
  ::ai::inworld::packets::Actor* unsafe_arena_release_source();

  // .ai.inworld.packets.Actor target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::ai::inworld::packets::Actor& target() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Actor* release_target();
  ::ai::inworld::packets::Actor* mutable_target();
  void set_allocated_target(::ai::inworld::packets::Actor* target);
  private:
  const ::ai::inworld::packets::Actor& _internal_target() const;
  ::ai::inworld::packets::Actor* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::ai::inworld::packets::Actor* target);
  ::ai::inworld::packets::Actor* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Routing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::packets::Actor* source_;
    ::ai::inworld::packets::Actor* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class PacketId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PacketId) */ {
 public:
  inline PacketId() : PacketId(nullptr) {}
  ~PacketId() override;
  explicit PROTOBUF_CONSTEXPR PacketId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketId(const PacketId& from);
  PacketId(PacketId&& from) noexcept
    : PacketId() {
    *this = ::std::move(from);
  }

  inline PacketId& operator=(const PacketId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketId& operator=(PacketId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketId* internal_default_instance() {
    return reinterpret_cast<const PacketId*>(
               &_PacketId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketId& a, PacketId& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PacketId& from) {
    PacketId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PacketId";
  }
  protected:
  explicit PacketId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 3,
    kCorrelationIdFieldNumber = 4,
  };
  // string packet_id = 1;
  void clear_packet_id();
  const std::string& packet_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packet_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packet_id();
  PROTOBUF_NODISCARD std::string* release_packet_id();
  void set_allocated_packet_id(std::string* packet_id);
  private:
  const std::string& _internal_packet_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_id(const std::string& value);
  std::string* _internal_mutable_packet_id();
  public:

  // string utterance_id = 2;
  void clear_utterance_id();
  const std::string& utterance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utterance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utterance_id();
  PROTOBUF_NODISCARD std::string* release_utterance_id();
  void set_allocated_utterance_id(std::string* utterance_id);
  private:
  const std::string& _internal_utterance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utterance_id(const std::string& value);
  std::string* _internal_mutable_utterance_id();
  public:

  // string interaction_id = 3;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string correlation_id = 4;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PacketId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utterance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class InworldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.InworldPacket) */ {
 public:
  inline InworldPacket() : InworldPacket(nullptr) {}
  ~InworldPacket() override;
  explicit PROTOBUF_CONSTEXPR InworldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InworldPacket(const InworldPacket& from);
  InworldPacket(InworldPacket&& from) noexcept
    : InworldPacket() {
    *this = ::std::move(from);
  }

  inline InworldPacket& operator=(const InworldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InworldPacket& operator=(InworldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InworldPacket& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kText = 2,
    kControl = 3,
    kCustom = 8,
    kCancelResponses = 10,
    kEmotion = 11,
    kDataChunk = 12,
    kAction = 13,
    kMutation = 15,
    kLoadSceneOutput = 16,
    kDebugInfo = 18,
    PACKET_NOT_SET = 0,
  };

  static inline const InworldPacket* internal_default_instance() {
    return reinterpret_cast<const InworldPacket*>(
               &_InworldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InworldPacket& a, InworldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InworldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InworldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InworldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InworldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InworldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InworldPacket& from) {
    InworldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InworldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.InworldPacket";
  }
  protected:
  explicit InworldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kRoutingFieldNumber = 6,
    kPacketIdFieldNumber = 9,
    kTextFieldNumber = 2,
    kControlFieldNumber = 3,
    kCustomFieldNumber = 8,
    kCancelResponsesFieldNumber = 10,
    kEmotionFieldNumber = 11,
    kDataChunkFieldNumber = 12,
    kActionFieldNumber = 13,
    kMutationFieldNumber = 15,
    kLoadSceneOutputFieldNumber = 16,
    kDebugInfoFieldNumber = 18,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .ai.inworld.packets.Routing routing = 6;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::ai::inworld::packets::Routing& routing() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::Routing* release_routing();
  ::ai::inworld::packets::Routing* mutable_routing();
  void set_allocated_routing(::ai::inworld::packets::Routing* routing);
  private:
  const ::ai::inworld::packets::Routing& _internal_routing() const;
  ::ai::inworld::packets::Routing* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::ai::inworld::packets::Routing* routing);
  ::ai::inworld::packets::Routing* unsafe_arena_release_routing();

  // .ai.inworld.packets.PacketId packet_id = 9;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // .ai.inworld.packets.TextEvent text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::ai::inworld::packets::TextEvent& text() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::TextEvent* release_text();
  ::ai::inworld::packets::TextEvent* mutable_text();
  void set_allocated_text(::ai::inworld::packets::TextEvent* text);
  private:
  const ::ai::inworld::packets::TextEvent& _internal_text() const;
  ::ai::inworld::packets::TextEvent* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::ai::inworld::packets::TextEvent* text);
  ::ai::inworld::packets::TextEvent* unsafe_arena_release_text();

  // .ai.inworld.packets.ControlEvent control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::ai::inworld::packets::ControlEvent& control() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ControlEvent* release_control();
  ::ai::inworld::packets::ControlEvent* mutable_control();
  void set_allocated_control(::ai::inworld::packets::ControlEvent* control);
  private:
  const ::ai::inworld::packets::ControlEvent& _internal_control() const;
  ::ai::inworld::packets::ControlEvent* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::ai::inworld::packets::ControlEvent* control);
  ::ai::inworld::packets::ControlEvent* unsafe_arena_release_control();

  // .ai.inworld.packets.CustomEvent custom = 8;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::ai::inworld::packets::CustomEvent& custom() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CustomEvent* release_custom();
  ::ai::inworld::packets::CustomEvent* mutable_custom();
  void set_allocated_custom(::ai::inworld::packets::CustomEvent* custom);
  private:
  const ::ai::inworld::packets::CustomEvent& _internal_custom() const;
  ::ai::inworld::packets::CustomEvent* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::ai::inworld::packets::CustomEvent* custom);
  ::ai::inworld::packets::CustomEvent* unsafe_arena_release_custom();

  // .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_cancelresponses() const;
  private:
  bool _internal_has_cancelresponses() const;
  public:
  PROTOBUF_DEPRECATED void clear_cancelresponses();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::CancelResponsesEvent& cancelresponses() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* release_cancelresponses();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* mutable_cancelresponses();
  PROTOBUF_DEPRECATED void set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  private:
  const ::ai::inworld::packets::CancelResponsesEvent& _internal_cancelresponses() const;
  ::ai::inworld::packets::CancelResponsesEvent* _internal_mutable_cancelresponses();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_cancelresponses(
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* unsafe_arena_release_cancelresponses();

  // .ai.inworld.packets.EmotionEvent emotion = 11;
  bool has_emotion() const;
  private:
  bool _internal_has_emotion() const;
  public:
  void clear_emotion();
  const ::ai::inworld::packets::EmotionEvent& emotion() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::EmotionEvent* release_emotion();
  ::ai::inworld::packets::EmotionEvent* mutable_emotion();
  void set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion);
  private:
  const ::ai::inworld::packets::EmotionEvent& _internal_emotion() const;
  ::ai::inworld::packets::EmotionEvent* _internal_mutable_emotion();
  public:
  void unsafe_arena_set_allocated_emotion(
      ::ai::inworld::packets::EmotionEvent* emotion);
  ::ai::inworld::packets::EmotionEvent* unsafe_arena_release_emotion();

  // .ai.inworld.packets.DataChunk data_chunk = 12;
  bool has_data_chunk() const;
  private:
  bool _internal_has_data_chunk() const;
  public:
  void clear_data_chunk();
  const ::ai::inworld::packets::DataChunk& data_chunk() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DataChunk* release_data_chunk();
  ::ai::inworld::packets::DataChunk* mutable_data_chunk();
  void set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk);
  private:
  const ::ai::inworld::packets::DataChunk& _internal_data_chunk() const;
  ::ai::inworld::packets::DataChunk* _internal_mutable_data_chunk();
  public:
  void unsafe_arena_set_allocated_data_chunk(
      ::ai::inworld::packets::DataChunk* data_chunk);
  ::ai::inworld::packets::DataChunk* unsafe_arena_release_data_chunk();

  // .ai.inworld.packets.ActionEvent action = 13;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::ai::inworld::packets::ActionEvent& action() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ActionEvent* release_action();
  ::ai::inworld::packets::ActionEvent* mutable_action();
  void set_allocated_action(::ai::inworld::packets::ActionEvent* action);
  private:
  const ::ai::inworld::packets::ActionEvent& _internal_action() const;
  ::ai::inworld::packets::ActionEvent* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::ai::inworld::packets::ActionEvent* action);
  ::ai::inworld::packets::ActionEvent* unsafe_arena_release_action();

  // .ai.inworld.packets.MutationEvent mutation = 15;
  bool has_mutation() const;
  private:
  bool _internal_has_mutation() const;
  public:
  void clear_mutation();
  const ::ai::inworld::packets::MutationEvent& mutation() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::MutationEvent* release_mutation();
  ::ai::inworld::packets::MutationEvent* mutable_mutation();
  void set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation);
  private:
  const ::ai::inworld::packets::MutationEvent& _internal_mutation() const;
  ::ai::inworld::packets::MutationEvent* _internal_mutable_mutation();
  public:
  void unsafe_arena_set_allocated_mutation(
      ::ai::inworld::packets::MutationEvent* mutation);
  ::ai::inworld::packets::MutationEvent* unsafe_arena_release_mutation();

  // .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16;
  bool has_load_scene_output() const;
  private:
  bool _internal_has_load_scene_output() const;
  public:
  void clear_load_scene_output();
  const ::ai::inworld::packets::LoadSceneOutputEvent& load_scene_output() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadSceneOutputEvent* release_load_scene_output();
  ::ai::inworld::packets::LoadSceneOutputEvent* mutable_load_scene_output();
  void set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent& _internal_load_scene_output() const;
  ::ai::inworld::packets::LoadSceneOutputEvent* _internal_mutable_load_scene_output();
  public:
  void unsafe_arena_set_allocated_load_scene_output(
      ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  ::ai::inworld::packets::LoadSceneOutputEvent* unsafe_arena_release_load_scene_output();

  // .ai.inworld.packets.DebugInfoEvent debug_info = 18;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::ai::inworld::packets::DebugInfoEvent& debug_info() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::DebugInfoEvent* release_debug_info();
  ::ai::inworld::packets::DebugInfoEvent* mutable_debug_info();
  void set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info);
  private:
  const ::ai::inworld::packets::DebugInfoEvent& _internal_debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::ai::inworld::packets::DebugInfoEvent* debug_info);
  ::ai::inworld::packets::DebugInfoEvent* unsafe_arena_release_debug_info();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.InworldPacket)
 private:
  class _Internal;
  void set_has_text();
  void set_has_control();
  void set_has_custom();
  void set_has_cancelresponses();
  void set_has_emotion();
  void set_has_data_chunk();
  void set_has_action();
  void set_has_mutation();
  void set_has_load_scene_output();
  void set_has_debug_info();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::ai::inworld::packets::Routing* routing_;
    ::ai::inworld::packets::PacketId* packet_id_;
    union PacketUnion {
      constexpr PacketUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::TextEvent* text_;
      ::ai::inworld::packets::ControlEvent* control_;
      ::ai::inworld::packets::CustomEvent* custom_;
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses_;
      ::ai::inworld::packets::EmotionEvent* emotion_;
      ::ai::inworld::packets::DataChunk* data_chunk_;
      ::ai::inworld::packets::ActionEvent* action_;
      ::ai::inworld::packets::MutationEvent* mutation_;
      ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output_;
      ::ai::inworld::packets::DebugInfoEvent* debug_info_;
    } packet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  ~TextEvent() override;
  explicit PROTOBUF_CONSTEXPR TextEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextEvent(const TextEvent& from);
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextEvent& from) {
    TextEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent";
  }
  protected:
  explicit TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TextEvent_SourceType SourceType;
  static constexpr SourceType UNKNOWN =
    TextEvent_SourceType_UNKNOWN;
  static constexpr SourceType SPEECH_TO_TEXT =
    TextEvent_SourceType_SPEECH_TO_TEXT;
  static constexpr SourceType TYPED_IN =
    TextEvent_SourceType_TYPED_IN;
  static constexpr SourceType GENERATED =
    TextEvent_SourceType_GENERATED;
  static constexpr SourceType FILLER =
    TextEvent_SourceType_FILLER;
  static inline bool SourceType_IsValid(int value) {
    return TextEvent_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    TextEvent_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    TextEvent_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    TextEvent_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return TextEvent_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return TextEvent_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return TextEvent_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kSourceTypeFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.TextEvent.SourceType source_type = 2;
  void clear_source_type();
  ::ai::inworld::packets::TextEvent_SourceType source_type() const;
  void set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  private:
  ::ai::inworld::packets::TextEvent_SourceType _internal_source_type() const;
  void _internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  public:

  // bool final = 3;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int source_type_;
    bool final_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ControlEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ControlEvent) */ {
 public:
  inline ControlEvent() : ControlEvent(nullptr) {}
  ~ControlEvent() override;
  explicit PROTOBUF_CONSTEXPR ControlEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlEvent(const ControlEvent& from);
  ControlEvent(ControlEvent&& from) noexcept
    : ControlEvent() {
    *this = ::std::move(from);
  }

  inline ControlEvent& operator=(const ControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlEvent& operator=(ControlEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlEvent* internal_default_instance() {
    return reinterpret_cast<const ControlEvent*>(
               &_ControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControlEvent& a, ControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlEvent& from) {
    ControlEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ControlEvent";
  }
  protected:
  explicit ControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControlEvent_Action Action;
  static constexpr Action UNKNOWN =
    ControlEvent_Action_UNKNOWN;
  static constexpr Action AUDIO_SESSION_START =
    ControlEvent_Action_AUDIO_SESSION_START;
  static constexpr Action AUDIO_SESSION_END =
    ControlEvent_Action_AUDIO_SESSION_END;
  static constexpr Action INTERACTION_END =
    ControlEvent_Action_INTERACTION_END;
  static constexpr Action TTS_PLAYBACK_START =
    ControlEvent_Action_TTS_PLAYBACK_START;
  static constexpr Action TTS_PLAYBACK_END =
    ControlEvent_Action_TTS_PLAYBACK_END;
  static constexpr Action TTS_PLAYBACK_MUTE =
    ControlEvent_Action_TTS_PLAYBACK_MUTE;
  static constexpr Action TTS_PLAYBACK_UNMUTE =
    ControlEvent_Action_TTS_PLAYBACK_UNMUTE;
  static constexpr Action WARNING =
    ControlEvent_Action_WARNING;
  static constexpr Action SESSION_END =
    ControlEvent_Action_SESSION_END;
  static inline bool Action_IsValid(int value) {
    return ControlEvent_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ControlEvent_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ControlEvent_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ControlEvent_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return ControlEvent_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ControlEvent_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ControlEvent_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Struct payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::PROTOBUF_NAMESPACE_ID::Struct& payload() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_payload();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_payload();
  void set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Struct* payload);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_payload() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::PROTOBUF_NAMESPACE_ID::Struct* payload);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_payload();

  // .ai.inworld.packets.ControlEvent.Action action = 1;
  void clear_action();
  ::ai::inworld::packets::ControlEvent_Action action() const;
  void set_action(::ai::inworld::packets::ControlEvent_Action value);
  private:
  ::ai::inworld::packets::ControlEvent_Action _internal_action() const;
  void _internal_set_action(::ai::inworld::packets::ControlEvent_Action value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ControlEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Struct* payload_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent_Parameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent.Parameter) */ {
 public:
  inline CustomEvent_Parameter() : CustomEvent_Parameter(nullptr) {}
  ~CustomEvent_Parameter() override;
  explicit PROTOBUF_CONSTEXPR CustomEvent_Parameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomEvent_Parameter(const CustomEvent_Parameter& from);
  CustomEvent_Parameter(CustomEvent_Parameter&& from) noexcept
    : CustomEvent_Parameter() {
    *this = ::std::move(from);
  }

  inline CustomEvent_Parameter& operator=(const CustomEvent_Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent_Parameter& operator=(CustomEvent_Parameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent_Parameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent_Parameter* internal_default_instance() {
    return reinterpret_cast<const CustomEvent_Parameter*>(
               &_CustomEvent_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CustomEvent_Parameter& a, CustomEvent_Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent_Parameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent_Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent_Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomEvent_Parameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomEvent_Parameter& from) {
    CustomEvent_Parameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent_Parameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent.Parameter";
  }
  protected:
  explicit CustomEvent_Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  ~CustomEvent() override;
  explicit PROTOBUF_CONSTEXPR CustomEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomEvent(const CustomEvent& from);
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomEvent& from) {
    CustomEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent";
  }
  protected:
  explicit CustomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomEvent_Parameter Parameter;

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kNameFieldNumber = 1,
    kPlaybackFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::ai::inworld::packets::CustomEvent_Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
      mutable_parameters();
  private:
  const ::ai::inworld::packets::CustomEvent_Parameter& _internal_parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* _internal_add_parameters();
  public:
  const ::ai::inworld::packets::CustomEvent_Parameter& parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int playback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponsesEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponsesEvent) */ {
 public:
  inline CancelResponsesEvent() : CancelResponsesEvent(nullptr) {}
  ~CancelResponsesEvent() override;
  explicit PROTOBUF_CONSTEXPR CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelResponsesEvent(const CancelResponsesEvent& from);
  CancelResponsesEvent(CancelResponsesEvent&& from) noexcept
    : CancelResponsesEvent() {
    *this = ::std::move(from);
  }

  inline CancelResponsesEvent& operator=(const CancelResponsesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponsesEvent& operator=(CancelResponsesEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponsesEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponsesEvent* internal_default_instance() {
    return reinterpret_cast<const CancelResponsesEvent*>(
               &_CancelResponsesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CancelResponsesEvent& a, CancelResponsesEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponsesEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponsesEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponsesEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponsesEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelResponsesEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelResponsesEvent& from) {
    CancelResponsesEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponsesEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponsesEvent";
  }
  protected:
  explicit CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponsesEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class EmotionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.EmotionEvent) */ {
 public:
  inline EmotionEvent() : EmotionEvent(nullptr) {}
  ~EmotionEvent() override;
  explicit PROTOBUF_CONSTEXPR EmotionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmotionEvent(const EmotionEvent& from);
  EmotionEvent(EmotionEvent&& from) noexcept
    : EmotionEvent() {
    *this = ::std::move(from);
  }

  inline EmotionEvent& operator=(const EmotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionEvent& operator=(EmotionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionEvent* internal_default_instance() {
    return reinterpret_cast<const EmotionEvent*>(
               &_EmotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EmotionEvent& a, EmotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmotionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmotionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmotionEvent& from) {
    EmotionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.EmotionEvent";
  }
  protected:
  explicit EmotionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EmotionEvent_SpaffCode SpaffCode;
  static constexpr SpaffCode NEUTRAL =
    EmotionEvent_SpaffCode_NEUTRAL;
  static constexpr SpaffCode DISGUST =
    EmotionEvent_SpaffCode_DISGUST;
  static constexpr SpaffCode CONTEMPT =
    EmotionEvent_SpaffCode_CONTEMPT;
  static constexpr SpaffCode BELLIGERENCE =
    EmotionEvent_SpaffCode_BELLIGERENCE;
  static constexpr SpaffCode DOMINEERING =
    EmotionEvent_SpaffCode_DOMINEERING;
  static constexpr SpaffCode CRITICISM =
    EmotionEvent_SpaffCode_CRITICISM;
  static constexpr SpaffCode ANGER =
    EmotionEvent_SpaffCode_ANGER;
  static constexpr SpaffCode TENSION =
    EmotionEvent_SpaffCode_TENSION;
  static constexpr SpaffCode TENSE_HUMOR =
    EmotionEvent_SpaffCode_TENSE_HUMOR;
  static constexpr SpaffCode DEFENSIVENESS =
    EmotionEvent_SpaffCode_DEFENSIVENESS;
  static constexpr SpaffCode WHINING =
    EmotionEvent_SpaffCode_WHINING;
  static constexpr SpaffCode SADNESS =
    EmotionEvent_SpaffCode_SADNESS;
  static constexpr SpaffCode STONEWALLING =
    EmotionEvent_SpaffCode_STONEWALLING;
  static constexpr SpaffCode INTEREST =
    EmotionEvent_SpaffCode_INTEREST;
  static constexpr SpaffCode VALIDATION =
    EmotionEvent_SpaffCode_VALIDATION;
  static constexpr SpaffCode AFFECTION =
    EmotionEvent_SpaffCode_AFFECTION;
  static constexpr SpaffCode HUMOR =
    EmotionEvent_SpaffCode_HUMOR;
  static constexpr SpaffCode SURPRISE =
    EmotionEvent_SpaffCode_SURPRISE;
  static constexpr SpaffCode JOY =
    EmotionEvent_SpaffCode_JOY;
  static inline bool SpaffCode_IsValid(int value) {
    return EmotionEvent_SpaffCode_IsValid(value);
  }
  static constexpr SpaffCode SpaffCode_MIN =
    EmotionEvent_SpaffCode_SpaffCode_MIN;
  static constexpr SpaffCode SpaffCode_MAX =
    EmotionEvent_SpaffCode_SpaffCode_MAX;
  static constexpr int SpaffCode_ARRAYSIZE =
    EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaffCode_descriptor() {
    return EmotionEvent_SpaffCode_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaffCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaffCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaffCode_Name.");
    return EmotionEvent_SpaffCode_Name(enum_t_value);
  }
  static inline bool SpaffCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SpaffCode* value) {
    return EmotionEvent_SpaffCode_Parse(name, value);
  }

  typedef EmotionEvent_Strength Strength;
  static constexpr Strength UNSPECIFIED =
    EmotionEvent_Strength_UNSPECIFIED;
  static constexpr Strength WEAK =
    EmotionEvent_Strength_WEAK;
  static constexpr Strength STRONG =
    EmotionEvent_Strength_STRONG;
  static constexpr Strength NORMAL =
    EmotionEvent_Strength_NORMAL;
  static inline bool Strength_IsValid(int value) {
    return EmotionEvent_Strength_IsValid(value);
  }
  static constexpr Strength Strength_MIN =
    EmotionEvent_Strength_Strength_MIN;
  static constexpr Strength Strength_MAX =
    EmotionEvent_Strength_Strength_MAX;
  static constexpr int Strength_ARRAYSIZE =
    EmotionEvent_Strength_Strength_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Strength_descriptor() {
    return EmotionEvent_Strength_descriptor();
  }
  template<typename T>
  static inline const std::string& Strength_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Strength>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Strength_Name.");
    return EmotionEvent_Strength_Name(enum_t_value);
  }
  static inline bool Strength_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Strength* value) {
    return EmotionEvent_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJoyFieldNumber = 1,
    kFearFieldNumber = 2,
    kTrustFieldNumber = 3,
    kSurpriseFieldNumber = 4,
    kBehaviorFieldNumber = 5,
    kStrengthFieldNumber = 6,
  };
  // float joy = 1;
  void clear_joy();
  float joy() const;
  void set_joy(float value);
  private:
  float _internal_joy() const;
  void _internal_set_joy(float value);
  public:

  // float fear = 2;
  void clear_fear();
  float fear() const;
  void set_fear(float value);
  private:
  float _internal_fear() const;
  void _internal_set_fear(float value);
  public:

  // float trust = 3;
  void clear_trust();
  float trust() const;
  void set_trust(float value);
  private:
  float _internal_trust() const;
  void _internal_set_trust(float value);
  public:

  // float surprise = 4;
  void clear_surprise();
  float surprise() const;
  void set_surprise(float value);
  private:
  float _internal_surprise() const;
  void _internal_set_surprise(float value);
  public:

  // .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
  void clear_behavior();
  ::ai::inworld::packets::EmotionEvent_SpaffCode behavior() const;
  void set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  private:
  ::ai::inworld::packets::EmotionEvent_SpaffCode _internal_behavior() const;
  void _internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  public:

  // .ai.inworld.packets.EmotionEvent.Strength strength = 6;
  void clear_strength();
  ::ai::inworld::packets::EmotionEvent_Strength strength() const;
  void set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  private:
  ::ai::inworld::packets::EmotionEvent_Strength _internal_strength() const;
  void _internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.EmotionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float joy_;
    float fear_;
    float trust_;
    float surprise_;
    int behavior_;
    int strength_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class DataChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  ~DataChunk() override;
  explicit PROTOBUF_CONSTEXPR DataChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChunk& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kChunk = 1,
    kDurationMs = 3,
    DATA_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataChunk& from) {
    DataChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataChunk_DataType DataType;
  static constexpr DataType UNSPECIFIED =
    DataChunk_DataType_UNSPECIFIED;
  static constexpr DataType AUDIO =
    DataChunk_DataType_AUDIO;
  static constexpr DataType ANIMATION =
    DataChunk_DataType_ANIMATION;
  static constexpr DataType SILENCE =
    DataChunk_DataType_SILENCE;
  static constexpr DataType STATE =
    DataChunk_DataType_STATE;
  static inline bool DataType_IsValid(int value) {
    return DataChunk_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    DataChunk_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    DataChunk_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    DataChunk_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return DataChunk_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return DataChunk_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return DataChunk_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPhonemeInfoFieldNumber = 4,
    kTypeFieldNumber = 2,
    kChunkFieldNumber = 1,
    kDurationMsFieldNumber = 3,
  };
  // repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
  int additional_phoneme_info_size() const;
  private:
  int _internal_additional_phoneme_info_size() const;
  public:
  void clear_additional_phoneme_info();
  ::ai::inworld::packets::AdditionalPhonemeInfo* mutable_additional_phoneme_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
      mutable_additional_phoneme_info();
  private:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& _internal_additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* _internal_add_additional_phoneme_info();
  public:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* add_additional_phoneme_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
      additional_phoneme_info() const;

  // .ai.inworld.packets.DataChunk.DataType type = 2;
  void clear_type();
  ::ai::inworld::packets::DataChunk_DataType type() const;
  void set_type(::ai::inworld::packets::DataChunk_DataType value);
  private:
  ::ai::inworld::packets::DataChunk_DataType _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::DataChunk_DataType value);
  public:

  // bytes chunk = 1;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // int64 duration_ms = 3;
  bool has_duration_ms() const;
  private:
  bool _internal_has_duration_ms() const;
  public:
  void clear_duration_ms();
  int64_t duration_ms() const;
  void set_duration_ms(int64_t value);
  private:
  int64_t _internal_duration_ms() const;
  void _internal_set_duration_ms(int64_t value);
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DataChunk)
 private:
  class _Internal;
  void set_has_chunk();
  void set_has_duration_ms();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo > additional_phoneme_info_;
    int type_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
      int64_t duration_ms_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class AdditionalPhonemeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AdditionalPhonemeInfo) */ {
 public:
  inline AdditionalPhonemeInfo() : AdditionalPhonemeInfo(nullptr) {}
  ~AdditionalPhonemeInfo() override;
  explicit PROTOBUF_CONSTEXPR AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdditionalPhonemeInfo(const AdditionalPhonemeInfo& from);
  AdditionalPhonemeInfo(AdditionalPhonemeInfo&& from) noexcept
    : AdditionalPhonemeInfo() {
    *this = ::std::move(from);
  }

  inline AdditionalPhonemeInfo& operator=(const AdditionalPhonemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPhonemeInfo& operator=(AdditionalPhonemeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdditionalPhonemeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdditionalPhonemeInfo* internal_default_instance() {
    return reinterpret_cast<const AdditionalPhonemeInfo*>(
               &_AdditionalPhonemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AdditionalPhonemeInfo& a, AdditionalPhonemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalPhonemeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdditionalPhonemeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdditionalPhonemeInfo& from) {
    AdditionalPhonemeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalPhonemeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AdditionalPhonemeInfo";
  }
  protected:
  explicit AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonemeFieldNumber = 1,
    kStartOffsetFieldNumber = 2,
  };
  // string phoneme = 1;
  void clear_phoneme();
  const std::string& phoneme() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phoneme(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phoneme();
  PROTOBUF_NODISCARD std::string* release_phoneme();
  void set_allocated_phoneme(std::string* phoneme);
  private:
  const std::string& _internal_phoneme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phoneme(const std::string& value);
  std::string* _internal_mutable_phoneme();
  public:

  // .google.protobuf.Duration start_offset = 2;
  bool has_start_offset() const;
  private:
  bool _internal_has_start_offset() const;
  public:
  void clear_start_offset();
  const ::PROTOBUF_NAMESPACE_ID::Duration& start_offset() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_start_offset();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_start_offset();
  void set_allocated_start_offset(::PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_start_offset() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_start_offset();
  public:
  void unsafe_arena_set_allocated_start_offset(
      ::PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_start_offset();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AdditionalPhonemeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phoneme_;
    ::PROTOBUF_NAMESPACE_ID::Duration* start_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ActionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ActionEvent) */ {
 public:
  inline ActionEvent() : ActionEvent(nullptr) {}
  ~ActionEvent() override;
  explicit PROTOBUF_CONSTEXPR ActionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionEvent(const ActionEvent& from);
  ActionEvent(ActionEvent&& from) noexcept
    : ActionEvent() {
    *this = ::std::move(from);
  }

  inline ActionEvent& operator=(const ActionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEvent& operator=(ActionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionEvent& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kNarratedAction = 1,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionEvent* internal_default_instance() {
    return reinterpret_cast<const ActionEvent*>(
               &_ActionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActionEvent& a, ActionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionEvent& from) {
    ActionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ActionEvent";
  }
  protected:
  explicit ActionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaybackFieldNumber = 2,
    kNarratedActionFieldNumber = 1,
  };
  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // .ai.inworld.packets.NarratedAction narrated_action = 1;
  bool has_narrated_action() const;
  private:
  bool _internal_has_narrated_action() const;
  public:
  void clear_narrated_action();
  const ::ai::inworld::packets::NarratedAction& narrated_action() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::NarratedAction* release_narrated_action();
  ::ai::inworld::packets::NarratedAction* mutable_narrated_action();
  void set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action);
  private:
  const ::ai::inworld::packets::NarratedAction& _internal_narrated_action() const;
  ::ai::inworld::packets::NarratedAction* _internal_mutable_narrated_action();
  public:
  void unsafe_arena_set_allocated_narrated_action(
      ::ai::inworld::packets::NarratedAction* narrated_action);
  ::ai::inworld::packets::NarratedAction* unsafe_arena_release_narrated_action();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ActionEvent)
 private:
  class _Internal;
  void set_has_narrated_action();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int playback_;
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::NarratedAction* narrated_action_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class NarratedAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.NarratedAction) */ {
 public:
  inline NarratedAction() : NarratedAction(nullptr) {}
  ~NarratedAction() override;
  explicit PROTOBUF_CONSTEXPR NarratedAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NarratedAction(const NarratedAction& from);
  NarratedAction(NarratedAction&& from) noexcept
    : NarratedAction() {
    *this = ::std::move(from);
  }

  inline NarratedAction& operator=(const NarratedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NarratedAction& operator=(NarratedAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NarratedAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const NarratedAction* internal_default_instance() {
    return reinterpret_cast<const NarratedAction*>(
               &_NarratedAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NarratedAction& a, NarratedAction& b) {
    a.Swap(&b);
  }
  inline void Swap(NarratedAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NarratedAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NarratedAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NarratedAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NarratedAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NarratedAction& from) {
    NarratedAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NarratedAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.NarratedAction";
  }
  protected:
  explicit NarratedAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.NarratedAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo_RelationAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo.RelationAttributes) */ {
 public:
  inline RelationInfo_RelationAttributes() : RelationInfo_RelationAttributes(nullptr) {}
  ~RelationInfo_RelationAttributes() override;
  explicit PROTOBUF_CONSTEXPR RelationInfo_RelationAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationInfo_RelationAttributes(const RelationInfo_RelationAttributes& from);
  RelationInfo_RelationAttributes(RelationInfo_RelationAttributes&& from) noexcept
    : RelationInfo_RelationAttributes() {
    *this = ::std::move(from);
  }

  inline RelationInfo_RelationAttributes& operator=(const RelationInfo_RelationAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo_RelationAttributes& operator=(RelationInfo_RelationAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationInfo_RelationAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationInfo_RelationAttributes* internal_default_instance() {
    return reinterpret_cast<const RelationInfo_RelationAttributes*>(
               &_RelationInfo_RelationAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RelationInfo_RelationAttributes& a, RelationInfo_RelationAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationInfo_RelationAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationInfo_RelationAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationInfo_RelationAttributes& from) {
    RelationInfo_RelationAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo_RelationAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo.RelationAttributes";
  }
  protected:
  explicit RelationInfo_RelationAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustFieldNumber = 1,
    kRespectFieldNumber = 2,
    kFamiliarFieldNumber = 3,
    kFlirtatiousFieldNumber = 4,
    kAttractionFieldNumber = 5,
  };
  // int32 trust = 1;
  void clear_trust();
  int32_t trust() const;
  void set_trust(int32_t value);
  private:
  int32_t _internal_trust() const;
  void _internal_set_trust(int32_t value);
  public:

  // int32 respect = 2;
  void clear_respect();
  int32_t respect() const;
  void set_respect(int32_t value);
  private:
  int32_t _internal_respect() const;
  void _internal_set_respect(int32_t value);
  public:

  // int32 familiar = 3;
  void clear_familiar();
  int32_t familiar() const;
  void set_familiar(int32_t value);
  private:
  int32_t _internal_familiar() const;
  void _internal_set_familiar(int32_t value);
  public:

  // int32 flirtatious = 4;
  void clear_flirtatious();
  int32_t flirtatious() const;
  void set_flirtatious(int32_t value);
  private:
  int32_t _internal_flirtatious() const;
  void _internal_set_flirtatious(int32_t value);
  public:

  // int32 attraction = 5;
  void clear_attraction();
  int32_t attraction() const;
  void set_attraction(int32_t value);
  private:
  int32_t _internal_attraction() const;
  void _internal_set_attraction(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo.RelationAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t trust_;
    int32_t respect_;
    int32_t familiar_;
    int32_t flirtatious_;
    int32_t attraction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo) */ {
 public:
  inline RelationInfo() : RelationInfo(nullptr) {}
  ~RelationInfo() override;
  explicit PROTOBUF_CONSTEXPR RelationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationInfo(const RelationInfo& from);
  RelationInfo(RelationInfo&& from) noexcept
    : RelationInfo() {
    *this = ::std::move(from);
  }

  inline RelationInfo& operator=(const RelationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo& operator=(RelationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationInfo* internal_default_instance() {
    return reinterpret_cast<const RelationInfo*>(
               &_RelationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RelationInfo& a, RelationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationInfo& from) {
    RelationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo";
  }
  protected:
  explicit RelationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelationInfo_RelationAttributes RelationAttributes;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationStateFieldNumber = 1,
    kRelationUpdateFieldNumber = 2,
  };
  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
  bool has_relation_state() const;
  private:
  bool _internal_has_relation_state() const;
  public:
  void clear_relation_state();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_state() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_state();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_state();
  void set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_state();
  public:
  void unsafe_arena_set_allocated_relation_state(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_state();

  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
  bool has_relation_update() const;
  private:
  bool _internal_has_relation_update() const;
  public:
  void clear_relation_update();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_update() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_update();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_update();
  void set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_update();
  public:
  void unsafe_arena_set_allocated_relation_update(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_update();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state_;
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class MutationEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.MutationEvent) */ {
 public:
  inline MutationEvent() : MutationEvent(nullptr) {}
  ~MutationEvent() override;
  explicit PROTOBUF_CONSTEXPR MutationEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutationEvent(const MutationEvent& from);
  MutationEvent(MutationEvent&& from) noexcept
    : MutationEvent() {
    *this = ::std::move(from);
  }

  inline MutationEvent& operator=(const MutationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationEvent& operator=(MutationEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutationEvent& default_instance() {
    return *internal_default_instance();
  }
  enum MutationCase {
    kCancelResponses = 1,
    kRegenerateResponse = 2,
    kApplyResponse = 3,
    kLoadScene = 4,
    kModifyExactResponse = 5,
    MUTATION_NOT_SET = 0,
  };

  static inline const MutationEvent* internal_default_instance() {
    return reinterpret_cast<const MutationEvent*>(
               &_MutationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MutationEvent& a, MutationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutationEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutationEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutationEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutationEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutationEvent& from) {
    MutationEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.MutationEvent";
  }
  protected:
  explicit MutationEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancelResponsesFieldNumber = 1,
    kRegenerateResponseFieldNumber = 2,
    kApplyResponseFieldNumber = 3,
    kLoadSceneFieldNumber = 4,
    kModifyExactResponseFieldNumber = 5,
  };
  // .ai.inworld.packets.CancelResponses cancel_responses = 1;
  bool has_cancel_responses() const;
  private:
  bool _internal_has_cancel_responses() const;
  public:
  void clear_cancel_responses();
  const ::ai::inworld::packets::CancelResponses& cancel_responses() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::CancelResponses* release_cancel_responses();
  ::ai::inworld::packets::CancelResponses* mutable_cancel_responses();
  void set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses);
  private:
  const ::ai::inworld::packets::CancelResponses& _internal_cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* _internal_mutable_cancel_responses();
  public:
  void unsafe_arena_set_allocated_cancel_responses(
      ::ai::inworld::packets::CancelResponses* cancel_responses);
  ::ai::inworld::packets::CancelResponses* unsafe_arena_release_cancel_responses();

  // .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
  bool has_regenerate_response() const;
  private:
  bool _internal_has_regenerate_response() const;
  public:
  void clear_regenerate_response();
  const ::ai::inworld::packets::RegenerateResponse& regenerate_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RegenerateResponse* release_regenerate_response();
  ::ai::inworld::packets::RegenerateResponse* mutable_regenerate_response();
  void set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response);
  private:
  const ::ai::inworld::packets::RegenerateResponse& _internal_regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* _internal_mutable_regenerate_response();
  public:
  void unsafe_arena_set_allocated_regenerate_response(
      ::ai::inworld::packets::RegenerateResponse* regenerate_response);
  ::ai::inworld::packets::RegenerateResponse* unsafe_arena_release_regenerate_response();

  // .ai.inworld.packets.ApplyResponse apply_response = 3;
  bool has_apply_response() const;
  private:
  bool _internal_has_apply_response() const;
  public:
  void clear_apply_response();
  const ::ai::inworld::packets::ApplyResponse& apply_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ApplyResponse* release_apply_response();
  ::ai::inworld::packets::ApplyResponse* mutable_apply_response();
  void set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response);
  private:
  const ::ai::inworld::packets::ApplyResponse& _internal_apply_response() const;
  ::ai::inworld::packets::ApplyResponse* _internal_mutable_apply_response();
  public:
  void unsafe_arena_set_allocated_apply_response(
      ::ai::inworld::packets::ApplyResponse* apply_response);
  ::ai::inworld::packets::ApplyResponse* unsafe_arena_release_apply_response();

  // .ai.inworld.packets.LoadScene load_scene = 4;
  bool has_load_scene() const;
  private:
  bool _internal_has_load_scene() const;
  public:
  void clear_load_scene();
  const ::ai::inworld::packets::LoadScene& load_scene() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::LoadScene* release_load_scene();
  ::ai::inworld::packets::LoadScene* mutable_load_scene();
  void set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene);
  private:
  const ::ai::inworld::packets::LoadScene& _internal_load_scene() const;
  ::ai::inworld::packets::LoadScene* _internal_mutable_load_scene();
  public:
  void unsafe_arena_set_allocated_load_scene(
      ::ai::inworld::packets::LoadScene* load_scene);
  ::ai::inworld::packets::LoadScene* unsafe_arena_release_load_scene();

  // .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
  bool has_modify_exact_response() const;
  private:
  bool _internal_has_modify_exact_response() const;
  public:
  void clear_modify_exact_response();
  const ::ai::inworld::packets::ModifyExactResponse& modify_exact_response() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::ModifyExactResponse* release_modify_exact_response();
  ::ai::inworld::packets::ModifyExactResponse* mutable_modify_exact_response();
  void set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  private:
  const ::ai::inworld::packets::ModifyExactResponse& _internal_modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* _internal_mutable_modify_exact_response();
  public:
  void unsafe_arena_set_allocated_modify_exact_response(
      ::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  ::ai::inworld::packets::ModifyExactResponse* unsafe_arena_release_modify_exact_response();

  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.MutationEvent)
 private:
  class _Internal;
  void set_has_cancel_responses();
  void set_has_regenerate_response();
  void set_has_apply_response();
  void set_has_load_scene();
  void set_has_modify_exact_response();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MutationUnion {
      constexpr MutationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::CancelResponses* cancel_responses_;
      ::ai::inworld::packets::RegenerateResponse* regenerate_response_;
      ::ai::inworld::packets::ApplyResponse* apply_response_;
      ::ai::inworld::packets::LoadScene* load_scene_;
      ::ai::inworld::packets::ModifyExactResponse* modify_exact_response_;
    } mutation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponses) */ {
 public:
  inline CancelResponses() : CancelResponses(nullptr) {}
  ~CancelResponses() override;
  explicit PROTOBUF_CONSTEXPR CancelResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelResponses(const CancelResponses& from);
  CancelResponses(CancelResponses&& from) noexcept
    : CancelResponses() {
    *this = ::std::move(from);
  }

  inline CancelResponses& operator=(const CancelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponses& operator=(CancelResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponses& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponses* internal_default_instance() {
    return reinterpret_cast<const CancelResponses*>(
               &_CancelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CancelResponses& a, CancelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelResponses& from) {
    CancelResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponses";
  }
  protected:
  explicit CancelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RegenerateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RegenerateResponse) */ {
 public:
  inline RegenerateResponse() : RegenerateResponse(nullptr) {}
  ~RegenerateResponse() override;
  explicit PROTOBUF_CONSTEXPR RegenerateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegenerateResponse(const RegenerateResponse& from);
  RegenerateResponse(RegenerateResponse&& from) noexcept
    : RegenerateResponse() {
    *this = ::std::move(from);
  }

  inline RegenerateResponse& operator=(const RegenerateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegenerateResponse& operator=(RegenerateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegenerateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegenerateResponse* internal_default_instance() {
    return reinterpret_cast<const RegenerateResponse*>(
               &_RegenerateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RegenerateResponse& a, RegenerateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegenerateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegenerateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegenerateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegenerateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegenerateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegenerateResponse& from) {
    RegenerateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegenerateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RegenerateResponse";
  }
  protected:
  explicit RegenerateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RegenerateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ApplyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ApplyResponse) */ {
 public:
  inline ApplyResponse() : ApplyResponse(nullptr) {}
  ~ApplyResponse() override;
  explicit PROTOBUF_CONSTEXPR ApplyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyResponse(const ApplyResponse& from);
  ApplyResponse(ApplyResponse&& from) noexcept
    : ApplyResponse() {
    *this = ::std::move(from);
  }

  inline ApplyResponse& operator=(const ApplyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyResponse& operator=(ApplyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyResponse*>(
               &_ApplyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ApplyResponse& a, ApplyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyResponse& from) {
    ApplyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ApplyResponse";
  }
  protected:
  explicit ApplyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
  };
  // .ai.inworld.packets.PacketId packet_id = 1;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ApplyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ai::inworld::packets::PacketId* packet_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadScene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadScene) */ {
 public:
  inline LoadScene() : LoadScene(nullptr) {}
  ~LoadScene() override;
  explicit PROTOBUF_CONSTEXPR LoadScene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadScene(const LoadScene& from);
  LoadScene(LoadScene&& from) noexcept
    : LoadScene() {
    *this = ::std::move(from);
  }

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScene& operator=(LoadScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadScene* internal_default_instance() {
    return reinterpret_cast<const LoadScene*>(
               &_LoadScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LoadScene& a, LoadScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadScene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadScene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadScene& from) {
    LoadScene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadScene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadScene";
  }
  protected:
  explicit LoadScene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ModifyExactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ModifyExactResponse) */ {
 public:
  inline ModifyExactResponse() : ModifyExactResponse(nullptr) {}
  ~ModifyExactResponse() override;
  explicit PROTOBUF_CONSTEXPR ModifyExactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyExactResponse(const ModifyExactResponse& from);
  ModifyExactResponse(ModifyExactResponse&& from) noexcept
    : ModifyExactResponse() {
    *this = ::std::move(from);
  }

  inline ModifyExactResponse& operator=(const ModifyExactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyExactResponse& operator=(ModifyExactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyExactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyExactResponse* internal_default_instance() {
    return reinterpret_cast<const ModifyExactResponse*>(
               &_ModifyExactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModifyExactResponse& a, ModifyExactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyExactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyExactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyExactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyExactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyExactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyExactResponse& from) {
    ModifyExactResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyExactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ModifyExactResponse";
  }
  protected:
  explicit ModifyExactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kExactTextFieldNumber = 2,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string exact_text = 2;
  void clear_exact_text();
  const std::string& exact_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exact_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exact_text();
  PROTOBUF_NODISCARD std::string* release_exact_text();
  void set_allocated_exact_text(std::string* exact_text);
  private:
  const std::string& _internal_exact_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exact_text(const std::string& value);
  std::string* _internal_mutable_exact_text();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ModifyExactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exact_text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent_Agent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent.Agent) */ {
 public:
  inline LoadSceneOutputEvent_Agent() : LoadSceneOutputEvent_Agent(nullptr) {}
  ~LoadSceneOutputEvent_Agent() override;
  explicit PROTOBUF_CONSTEXPR LoadSceneOutputEvent_Agent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadSceneOutputEvent_Agent(const LoadSceneOutputEvent_Agent& from);
  LoadSceneOutputEvent_Agent(LoadSceneOutputEvent_Agent&& from) noexcept
    : LoadSceneOutputEvent_Agent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent_Agent& operator=(const LoadSceneOutputEvent_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent_Agent& operator=(LoadSceneOutputEvent_Agent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadSceneOutputEvent_Agent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadSceneOutputEvent_Agent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent_Agent*>(
               &_LoadSceneOutputEvent_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoadSceneOutputEvent_Agent& a, LoadSceneOutputEvent_Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadSceneOutputEvent_Agent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadSceneOutputEvent_Agent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadSceneOutputEvent_Agent& from) {
    LoadSceneOutputEvent_Agent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent_Agent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent.Agent";
  }
  protected:
  explicit LoadSceneOutputEvent_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string brain_name = 2;
  void clear_brain_name();
  const std::string& brain_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brain_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brain_name();
  PROTOBUF_NODISCARD std::string* release_brain_name();
  void set_allocated_brain_name(std::string* brain_name);
  private:
  const std::string& _internal_brain_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brain_name(const std::string& value);
  std::string* _internal_mutable_brain_name();
  public:

  // string given_name = 3;
  void clear_given_name();
  const std::string& given_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_given_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_given_name();
  PROTOBUF_NODISCARD std::string* release_given_name();
  void set_allocated_given_name(std::string* given_name);
  private:
  const std::string& _internal_given_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_given_name(const std::string& value);
  std::string* _internal_mutable_given_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent.Agent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brain_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr given_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent) */ {
 public:
  inline LoadSceneOutputEvent() : LoadSceneOutputEvent(nullptr) {}
  ~LoadSceneOutputEvent() override;
  explicit PROTOBUF_CONSTEXPR LoadSceneOutputEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadSceneOutputEvent(const LoadSceneOutputEvent& from);
  LoadSceneOutputEvent(LoadSceneOutputEvent&& from) noexcept
    : LoadSceneOutputEvent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent& operator=(const LoadSceneOutputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent& operator=(LoadSceneOutputEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadSceneOutputEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadSceneOutputEvent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent*>(
               &_LoadSceneOutputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoadSceneOutputEvent& a, LoadSceneOutputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadSceneOutputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadSceneOutputEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadSceneOutputEvent& from) {
    LoadSceneOutputEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent";
  }
  protected:
  explicit LoadSceneOutputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoadSceneOutputEvent_Agent Agent;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
      agents() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent > agents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class DebugInfoEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DebugInfoEvent) */ {
 public:
  inline DebugInfoEvent() : DebugInfoEvent(nullptr) {}
  ~DebugInfoEvent() override;
  explicit PROTOBUF_CONSTEXPR DebugInfoEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugInfoEvent(const DebugInfoEvent& from);
  DebugInfoEvent(DebugInfoEvent&& from) noexcept
    : DebugInfoEvent() {
    *this = ::std::move(from);
  }

  inline DebugInfoEvent& operator=(const DebugInfoEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInfoEvent& operator=(DebugInfoEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugInfoEvent& default_instance() {
    return *internal_default_instance();
  }
  enum InfoCase {
    kRelation = 1,
    INFO_NOT_SET = 0,
  };

  static inline const DebugInfoEvent* internal_default_instance() {
    return reinterpret_cast<const DebugInfoEvent*>(
               &_DebugInfoEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DebugInfoEvent& a, DebugInfoEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugInfoEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInfoEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugInfoEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugInfoEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugInfoEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugInfoEvent& from) {
    DebugInfoEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugInfoEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DebugInfoEvent";
  }
  protected:
  explicit DebugInfoEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // .ai.inworld.packets.RelationInfo relation = 1;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  const ::ai::inworld::packets::RelationInfo& relation() const;
  PROTOBUF_NODISCARD ::ai::inworld::packets::RelationInfo* release_relation();
  ::ai::inworld::packets::RelationInfo* mutable_relation();
  void set_allocated_relation(::ai::inworld::packets::RelationInfo* relation);
  private:
  const ::ai::inworld::packets::RelationInfo& _internal_relation() const;
  ::ai::inworld::packets::RelationInfo* _internal_mutable_relation();
  public:
  void unsafe_arena_set_allocated_relation(
      ::ai::inworld::packets::RelationInfo* relation);
  ::ai::inworld::packets::RelationInfo* unsafe_arena_release_relation();

  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DebugInfoEvent)
 private:
  class _Internal;
  void set_has_relation();

  inline bool has_info() const;
  inline void clear_has_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union InfoUnion {
      constexpr InfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ai::inworld::packets::RelationInfo* relation_;
    } info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Actor

// .ai.inworld.packets.Actor.Type type = 1;
inline void Actor::clear_type() {
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::Actor_Type Actor::_internal_type() const {
  return static_cast< ::ai::inworld::packets::Actor_Type >(_impl_.type_);
}
inline ::ai::inworld::packets::Actor_Type Actor::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.type)
  return _internal_type();
}
inline void Actor::_internal_set_type(::ai::inworld::packets::Actor_Type value) {
  
  _impl_.type_ = value;
}
inline void Actor::set_type(::ai::inworld::packets::Actor_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.type)
}

// string name = 2;
inline void Actor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Actor::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Actor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Actor.name)
  return _s;
}
inline const std::string& Actor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Actor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Actor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Actor::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Actor.name)
  return _impl_.name_.Release();
}
inline void Actor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Actor.name)
}

// -------------------------------------------------------------------

// Routing

// .ai.inworld.packets.Actor source = 1;
inline bool Routing::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool Routing::has_source() const {
  return _internal_has_source();
}
inline void Routing::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_source() const {
  const ::ai::inworld::packets::Actor* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::source() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.source)
  return _internal_source();
}
inline void Routing::unsafe_arena_set_allocated_source(
    ::ai::inworld::packets::Actor* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.source)
}
inline ::ai::inworld::packets::Actor* Routing::release_source() {
  
  ::ai::inworld::packets::Actor* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.source)
  
  ::ai::inworld::packets::Actor* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_source() {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.source)
  return _msg;
}
inline void Routing::set_allocated_source(::ai::inworld::packets::Actor* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.source)
}

// .ai.inworld.packets.Actor target = 2;
inline bool Routing::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool Routing::has_target() const {
  return _internal_has_target();
}
inline void Routing::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_target() const {
  const ::ai::inworld::packets::Actor* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::target() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.target)
  return _internal_target();
}
inline void Routing::unsafe_arena_set_allocated_target(
    ::ai::inworld::packets::Actor* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.target)
}
inline ::ai::inworld::packets::Actor* Routing::release_target() {
  
  ::ai::inworld::packets::Actor* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.target)
  
  ::ai::inworld::packets::Actor* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_target() {
  ::ai::inworld::packets::Actor* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.target)
  return _msg;
}
inline void Routing::set_allocated_target(::ai::inworld::packets::Actor* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.target)
}

// -------------------------------------------------------------------

// PacketId

// string packet_id = 1;
inline void PacketId::clear_packet_id() {
  _impl_.packet_id_.ClearToEmpty();
}
inline const std::string& PacketId::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.packet_id)
  return _internal_packet_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_packet_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.packet_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::mutable_packet_id() {
  std::string* _s = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.packet_id)
  return _s;
}
inline const std::string& PacketId::_internal_packet_id() const {
  return _impl_.packet_id_.Get();
}
inline void PacketId::_internal_set_packet_id(const std::string& value) {
  
  _impl_.packet_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_packet_id() {
  
  return _impl_.packet_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.packet_id)
  return _impl_.packet_id_.Release();
}
inline void PacketId::set_allocated_packet_id(std::string* packet_id) {
  if (packet_id != nullptr) {
    
  } else {
    
  }
  _impl_.packet_id_.SetAllocated(packet_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packet_id_.IsDefault()) {
    _impl_.packet_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.packet_id)
}

// string utterance_id = 2;
inline void PacketId::clear_utterance_id() {
  _impl_.utterance_id_.ClearToEmpty();
}
inline const std::string& PacketId::utterance_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.utterance_id)
  return _internal_utterance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_utterance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utterance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::mutable_utterance_id() {
  std::string* _s = _internal_mutable_utterance_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.utterance_id)
  return _s;
}
inline const std::string& PacketId::_internal_utterance_id() const {
  return _impl_.utterance_id_.Get();
}
inline void PacketId::_internal_set_utterance_id(const std::string& value) {
  
  _impl_.utterance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_utterance_id() {
  
  return _impl_.utterance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_utterance_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.utterance_id)
  return _impl_.utterance_id_.Release();
}
inline void PacketId::set_allocated_utterance_id(std::string* utterance_id) {
  if (utterance_id != nullptr) {
    
  } else {
    
  }
  _impl_.utterance_id_.SetAllocated(utterance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utterance_id_.IsDefault()) {
    _impl_.utterance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.utterance_id)
}

// string interaction_id = 3;
inline void PacketId::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& PacketId::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.interaction_id)
  return _s;
}
inline const std::string& PacketId::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void PacketId::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void PacketId::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.interaction_id)
}

// string correlation_id = 4;
inline void PacketId::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& PacketId::correlation_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PacketId::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.correlation_id)
  return _s;
}
inline const std::string& PacketId::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void PacketId::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PacketId::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PacketId::release_correlation_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void PacketId::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.correlation_id)
}

// -------------------------------------------------------------------

// InworldPacket

// .google.protobuf.Timestamp timestamp = 1;
inline bool InworldPacket::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool InworldPacket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_timestamp();
}
inline void InworldPacket::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.timestamp)
  return _msg;
}
inline void InworldPacket::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}

// .ai.inworld.packets.Routing routing = 6;
inline bool InworldPacket::_internal_has_routing() const {
  return this != internal_default_instance() && _impl_.routing_ != nullptr;
}
inline bool InworldPacket::has_routing() const {
  return _internal_has_routing();
}
inline void InworldPacket::clear_routing() {
  if (GetArenaForAllocation() == nullptr && _impl_.routing_ != nullptr) {
    delete _impl_.routing_;
  }
  _impl_.routing_ = nullptr;
}
inline const ::ai::inworld::packets::Routing& InworldPacket::_internal_routing() const {
  const ::ai::inworld::packets::Routing* p = _impl_.routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Routing&>(
      ::ai::inworld::packets::_Routing_default_instance_);
}
inline const ::ai::inworld::packets::Routing& InworldPacket::routing() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.routing)
  return _internal_routing();
}
inline void InworldPacket::unsafe_arena_set_allocated_routing(
    ::ai::inworld::packets::Routing* routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.routing_);
  }
  _impl_.routing_ = routing;
  if (routing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.routing)
}
inline ::ai::inworld::packets::Routing* InworldPacket::release_routing() {
  
  ::ai::inworld::packets::Routing* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.routing)
  
  ::ai::inworld::packets::Routing* temp = _impl_.routing_;
  _impl_.routing_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::_internal_mutable_routing() {
  
  if (_impl_.routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Routing>(GetArenaForAllocation());
    _impl_.routing_ = p;
  }
  return _impl_.routing_;
}
inline ::ai::inworld::packets::Routing* InworldPacket::mutable_routing() {
  ::ai::inworld::packets::Routing* _msg = _internal_mutable_routing();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.routing)
  return _msg;
}
inline void InworldPacket::set_allocated_routing(::ai::inworld::packets::Routing* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.routing_;
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routing);
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.routing)
}

// .ai.inworld.packets.PacketId packet_id = 9;
inline bool InworldPacket::_internal_has_packet_id() const {
  return this != internal_default_instance() && _impl_.packet_id_ != nullptr;
}
inline bool InworldPacket::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void InworldPacket::clear_packet_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_id_ != nullptr) {
    delete _impl_.packet_id_;
  }
  _impl_.packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_packet_id();
}
inline void InworldPacket::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}
inline ::ai::inworld::packets::PacketId* InworldPacket::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::_internal_mutable_packet_id() {
  
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArenaForAllocation());
    _impl_.packet_id_ = p;
  }
  return _impl_.packet_id_;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::mutable_packet_id() {
  ::ai::inworld::packets::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.packet_id)
  return _msg;
}
inline void InworldPacket::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}

// .ai.inworld.packets.TextEvent text = 2;
inline bool InworldPacket::_internal_has_text() const {
  return packet_case() == kText;
}
inline bool InworldPacket::has_text() const {
  return _internal_has_text();
}
inline void InworldPacket::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void InworldPacket::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.text_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = _impl_.packet_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::_internal_text() const {
  return _internal_has_text()
      ? *_impl_.packet_.text_
      : reinterpret_cast< ::ai::inworld::packets::TextEvent&>(::ai::inworld::packets::_TextEvent_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.text)
  return _internal_text();
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = _impl_.packet_.text_;
    _impl_.packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* text) {
  clear_packet();
  if (text) {
    set_has_text();
    _impl_.packet_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.text)
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_packet();
    set_has_text();
    _impl_.packet_.text_ = CreateMaybeMessage< ::ai::inworld::packets::TextEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.text_;
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::mutable_text() {
  ::ai::inworld::packets::TextEvent* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.text)
  return _msg;
}

// .ai.inworld.packets.ControlEvent control = 3;
inline bool InworldPacket::_internal_has_control() const {
  return packet_case() == kControl;
}
inline bool InworldPacket::has_control() const {
  return _internal_has_control();
}
inline void InworldPacket::set_has_control() {
  _impl_._oneof_case_[0] = kControl;
}
inline void InworldPacket::clear_control() {
  if (_internal_has_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::release_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = _impl_.packet_.control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::_internal_control() const {
  return _internal_has_control()
      ? *_impl_.packet_.control_
      : reinterpret_cast< ::ai::inworld::packets::ControlEvent&>(::ai::inworld::packets::_ControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::control() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.control)
  return _internal_control();
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = _impl_.packet_.control_;
    _impl_.packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* control) {
  clear_packet();
  if (control) {
    set_has_control();
    _impl_.packet_.control_ = control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.control)
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::_internal_mutable_control() {
  if (!_internal_has_control()) {
    clear_packet();
    set_has_control();
    _impl_.packet_.control_ = CreateMaybeMessage< ::ai::inworld::packets::ControlEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.control_;
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::mutable_control() {
  ::ai::inworld::packets::ControlEvent* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.control)
  return _msg;
}

// .ai.inworld.packets.CustomEvent custom = 8;
inline bool InworldPacket::_internal_has_custom() const {
  return packet_case() == kCustom;
}
inline bool InworldPacket::has_custom() const {
  return _internal_has_custom();
}
inline void InworldPacket::set_has_custom() {
  _impl_._oneof_case_[0] = kCustom;
}
inline void InworldPacket::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.custom_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::release_custom() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = _impl_.packet_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::_internal_custom() const {
  return _internal_has_custom()
      ? *_impl_.packet_.custom_
      : reinterpret_cast< ::ai::inworld::packets::CustomEvent&>(::ai::inworld::packets::_CustomEvent_default_instance_);
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::custom() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.custom)
  return _internal_custom();
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = _impl_.packet_.custom_;
    _impl_.packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* custom) {
  clear_packet();
  if (custom) {
    set_has_custom();
    _impl_.packet_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.custom)
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_packet();
    set_has_custom();
    _impl_.packet_.custom_ = CreateMaybeMessage< ::ai::inworld::packets::CustomEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.custom_;
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::mutable_custom() {
  ::ai::inworld::packets::CustomEvent* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.custom)
  return _msg;
}

// .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
inline bool InworldPacket::_internal_has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline bool InworldPacket::has_cancelresponses() const {
  return _internal_has_cancelresponses();
}
inline void InworldPacket::set_has_cancelresponses() {
  _impl_._oneof_case_[0] = kCancelResponses;
}
inline void InworldPacket::clear_cancelresponses() {
  if (_internal_has_cancelresponses()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.cancelresponses_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::release_cancelresponses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = _impl_.packet_.cancelresponses_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::_internal_cancelresponses() const {
  return _internal_has_cancelresponses()
      ? *_impl_.packet_.cancelresponses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponsesEvent&>(::ai::inworld::packets::_CancelResponsesEvent_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::cancelresponses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_cancelresponses();
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::unsafe_arena_release_cancelresponses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = _impl_.packet_.cancelresponses_;
    _impl_.packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses) {
  clear_packet();
  if (cancelresponses) {
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = cancelresponses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.cancelResponses)
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::_internal_mutable_cancelresponses() {
  if (!_internal_has_cancelresponses()) {
    clear_packet();
    set_has_cancelresponses();
    _impl_.packet_.cancelresponses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponsesEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.cancelresponses_;
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::mutable_cancelresponses() {
  ::ai::inworld::packets::CancelResponsesEvent* _msg = _internal_mutable_cancelresponses();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.cancelResponses)
  return _msg;
}

// .ai.inworld.packets.EmotionEvent emotion = 11;
inline bool InworldPacket::_internal_has_emotion() const {
  return packet_case() == kEmotion;
}
inline bool InworldPacket::has_emotion() const {
  return _internal_has_emotion();
}
inline void InworldPacket::set_has_emotion() {
  _impl_._oneof_case_[0] = kEmotion;
}
inline void InworldPacket::clear_emotion() {
  if (_internal_has_emotion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.emotion_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::release_emotion() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = _impl_.packet_.emotion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::_internal_emotion() const {
  return _internal_has_emotion()
      ? *_impl_.packet_.emotion_
      : reinterpret_cast< ::ai::inworld::packets::EmotionEvent&>(::ai::inworld::packets::_EmotionEvent_default_instance_);
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::emotion() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.emotion)
  return _internal_emotion();
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::unsafe_arena_release_emotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = _impl_.packet_.emotion_;
    _impl_.packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion) {
  clear_packet();
  if (emotion) {
    set_has_emotion();
    _impl_.packet_.emotion_ = emotion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.emotion)
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::_internal_mutable_emotion() {
  if (!_internal_has_emotion()) {
    clear_packet();
    set_has_emotion();
    _impl_.packet_.emotion_ = CreateMaybeMessage< ::ai::inworld::packets::EmotionEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.emotion_;
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::mutable_emotion() {
  ::ai::inworld::packets::EmotionEvent* _msg = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.emotion)
  return _msg;
}

// .ai.inworld.packets.DataChunk data_chunk = 12;
inline bool InworldPacket::_internal_has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline bool InworldPacket::has_data_chunk() const {
  return _internal_has_data_chunk();
}
inline void InworldPacket::set_has_data_chunk() {
  _impl_._oneof_case_[0] = kDataChunk;
}
inline void InworldPacket::clear_data_chunk() {
  if (_internal_has_data_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.data_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::release_data_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = _impl_.packet_.data_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::_internal_data_chunk() const {
  return _internal_has_data_chunk()
      ? *_impl_.packet_.data_chunk_
      : reinterpret_cast< ::ai::inworld::packets::DataChunk&>(::ai::inworld::packets::_DataChunk_default_instance_);
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::data_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_data_chunk();
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::unsafe_arena_release_data_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = _impl_.packet_.data_chunk_;
    _impl_.packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk) {
  clear_packet();
  if (data_chunk) {
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = data_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.data_chunk)
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::_internal_mutable_data_chunk() {
  if (!_internal_has_data_chunk()) {
    clear_packet();
    set_has_data_chunk();
    _impl_.packet_.data_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::DataChunk >(GetArenaForAllocation());
  }
  return _impl_.packet_.data_chunk_;
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::mutable_data_chunk() {
  ::ai::inworld::packets::DataChunk* _msg = _internal_mutable_data_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.data_chunk)
  return _msg;
}

// .ai.inworld.packets.ActionEvent action = 13;
inline bool InworldPacket::_internal_has_action() const {
  return packet_case() == kAction;
}
inline bool InworldPacket::has_action() const {
  return _internal_has_action();
}
inline void InworldPacket::set_has_action() {
  _impl_._oneof_case_[0] = kAction;
}
inline void InworldPacket::clear_action() {
  if (_internal_has_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.action_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::release_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
    ::ai::inworld::packets::ActionEvent* temp = _impl_.packet_.action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::_internal_action() const {
  return _internal_has_action()
      ? *_impl_.packet_.action_
      : reinterpret_cast< ::ai::inworld::packets::ActionEvent&>(::ai::inworld::packets::_ActionEvent_default_instance_);
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.action)
  return _internal_action();
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
    ::ai::inworld::packets::ActionEvent* temp = _impl_.packet_.action_;
    _impl_.packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_action(::ai::inworld::packets::ActionEvent* action) {
  clear_packet();
  if (action) {
    set_has_action();
    _impl_.packet_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.action)
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_packet();
    set_has_action();
    _impl_.packet_.action_ = CreateMaybeMessage< ::ai::inworld::packets::ActionEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.action_;
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::mutable_action() {
  ::ai::inworld::packets::ActionEvent* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.action)
  return _msg;
}

// .ai.inworld.packets.MutationEvent mutation = 15;
inline bool InworldPacket::_internal_has_mutation() const {
  return packet_case() == kMutation;
}
inline bool InworldPacket::has_mutation() const {
  return _internal_has_mutation();
}
inline void InworldPacket::set_has_mutation() {
  _impl_._oneof_case_[0] = kMutation;
}
inline void InworldPacket::clear_mutation() {
  if (_internal_has_mutation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.mutation_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::release_mutation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
    ::ai::inworld::packets::MutationEvent* temp = _impl_.packet_.mutation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::_internal_mutation() const {
  return _internal_has_mutation()
      ? *_impl_.packet_.mutation_
      : reinterpret_cast< ::ai::inworld::packets::MutationEvent&>(::ai::inworld::packets::_MutationEvent_default_instance_);
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::mutation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutation();
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::unsafe_arena_release_mutation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
    ::ai::inworld::packets::MutationEvent* temp = _impl_.packet_.mutation_;
    _impl_.packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation) {
  clear_packet();
  if (mutation) {
    set_has_mutation();
    _impl_.packet_.mutation_ = mutation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.mutation)
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::_internal_mutable_mutation() {
  if (!_internal_has_mutation()) {
    clear_packet();
    set_has_mutation();
    _impl_.packet_.mutation_ = CreateMaybeMessage< ::ai::inworld::packets::MutationEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.mutation_;
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::mutable_mutation() {
  ::ai::inworld::packets::MutationEvent* _msg = _internal_mutable_mutation();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.mutation)
  return _msg;
}

// .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16;
inline bool InworldPacket::_internal_has_load_scene_output() const {
  return packet_case() == kLoadSceneOutput;
}
inline bool InworldPacket::has_load_scene_output() const {
  return _internal_has_load_scene_output();
}
inline void InworldPacket::set_has_load_scene_output() {
  _impl_._oneof_case_[0] = kLoadSceneOutput;
}
inline void InworldPacket::clear_load_scene_output() {
  if (_internal_has_load_scene_output()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.load_scene_output_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::release_load_scene_output() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
    ::ai::inworld::packets::LoadSceneOutputEvent* temp = _impl_.packet_.load_scene_output_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::_internal_load_scene_output() const {
  return _internal_has_load_scene_output()
      ? *_impl_.packet_.load_scene_output_
      : reinterpret_cast< ::ai::inworld::packets::LoadSceneOutputEvent&>(::ai::inworld::packets::_LoadSceneOutputEvent_default_instance_);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::load_scene_output() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_load_scene_output();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::unsafe_arena_release_load_scene_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
    ::ai::inworld::packets::LoadSceneOutputEvent* temp = _impl_.packet_.load_scene_output_;
    _impl_.packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output) {
  clear_packet();
  if (load_scene_output) {
    set_has_load_scene_output();
    _impl_.packet_.load_scene_output_ = load_scene_output;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.load_scene_output)
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::_internal_mutable_load_scene_output() {
  if (!_internal_has_load_scene_output()) {
    clear_packet();
    set_has_load_scene_output();
    _impl_.packet_.load_scene_output_ = CreateMaybeMessage< ::ai::inworld::packets::LoadSceneOutputEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.load_scene_output_;
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::mutable_load_scene_output() {
  ::ai::inworld::packets::LoadSceneOutputEvent* _msg = _internal_mutable_load_scene_output();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.load_scene_output)
  return _msg;
}

// .ai.inworld.packets.DebugInfoEvent debug_info = 18;
inline bool InworldPacket::_internal_has_debug_info() const {
  return packet_case() == kDebugInfo;
}
inline bool InworldPacket::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void InworldPacket::set_has_debug_info() {
  _impl_._oneof_case_[0] = kDebugInfo;
}
inline void InworldPacket::clear_debug_info() {
  if (_internal_has_debug_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.packet_.debug_info_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::release_debug_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
    ::ai::inworld::packets::DebugInfoEvent* temp = _impl_.packet_.debug_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::_internal_debug_info() const {
  return _internal_has_debug_info()
      ? *_impl_.packet_.debug_info_
      : reinterpret_cast< ::ai::inworld::packets::DebugInfoEvent&>(::ai::inworld::packets::_DebugInfoEvent_default_instance_);
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::debug_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_debug_info();
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
    ::ai::inworld::packets::DebugInfoEvent* temp = _impl_.packet_.debug_info_;
    _impl_.packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info) {
  clear_packet();
  if (debug_info) {
    set_has_debug_info();
    _impl_.packet_.debug_info_ = debug_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.debug_info)
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::_internal_mutable_debug_info() {
  if (!_internal_has_debug_info()) {
    clear_packet();
    set_has_debug_info();
    _impl_.packet_.debug_info_ = CreateMaybeMessage< ::ai::inworld::packets::DebugInfoEvent >(GetArenaForAllocation());
  }
  return _impl_.packet_.debug_info_;
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::mutable_debug_info() {
  ::ai::inworld::packets::DebugInfoEvent* _msg = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.debug_info)
  return _msg;
}

inline bool InworldPacket::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void InworldPacket::clear_has_packet() {
  _impl_._oneof_case_[0] = PACKET_NOT_SET;
}
inline InworldPacket::PacketCase InworldPacket::packet_case() const {
  return InworldPacket::PacketCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextEvent::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.text)
  return _s;
}
inline const std::string& TextEvent::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextEvent::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextEvent::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.text)
  return _impl_.text_.Release();
}
inline void TextEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.text)
}

// .ai.inworld.packets.TextEvent.SourceType source_type = 2;
inline void TextEvent::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::_internal_source_type() const {
  return static_cast< ::ai::inworld::packets::TextEvent_SourceType >(_impl_.source_type_);
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::source_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.source_type)
  return _internal_source_type();
}
inline void TextEvent::_internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  
  _impl_.source_type_ = value;
}
inline void TextEvent::set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.source_type)
}

// bool final = 3;
inline void TextEvent::clear_final() {
  _impl_.final_ = false;
}
inline bool TextEvent::_internal_final() const {
  return _impl_.final_;
}
inline bool TextEvent::final() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.final)
  return _internal_final();
}
inline void TextEvent::_internal_set_final(bool value) {
  
  _impl_.final_ = value;
}
inline void TextEvent::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.final)
}

// -------------------------------------------------------------------

// ControlEvent

// .ai.inworld.packets.ControlEvent.Action action = 1;
inline void ControlEvent::clear_action() {
  _impl_.action_ = 0;
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::_internal_action() const {
  return static_cast< ::ai::inworld::packets::ControlEvent_Action >(_impl_.action_);
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.action)
  return _internal_action();
}
inline void ControlEvent::_internal_set_action(::ai::inworld::packets::ControlEvent_Action value) {
  
  _impl_.action_ = value;
}
inline void ControlEvent::set_action(::ai::inworld::packets::ControlEvent_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.action)
}

// string description = 2;
inline void ControlEvent::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ControlEvent::description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlEvent::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.description)
  return _s;
}
inline const std::string& ControlEvent::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ControlEvent::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlEvent::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlEvent::release_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.description)
  return _impl_.description_.Release();
}
inline void ControlEvent::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.description)
}

// .google.protobuf.Struct payload = 3;
inline bool ControlEvent::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool ControlEvent::has_payload() const {
  return _internal_has_payload();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::_internal_payload() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::payload() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.payload)
  return _internal_payload();
}
inline void ControlEvent::unsafe_arena_set_allocated_payload(
    ::PROTOBUF_NAMESPACE_ID::Struct* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.payload)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::release_payload() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.payload)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::mutable_payload() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.payload)
  return _msg;
}
inline void ControlEvent::set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Struct* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload));
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.payload)
}

// -------------------------------------------------------------------

// CustomEvent_Parameter

// string name = 1;
inline void CustomEvent_Parameter::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent_Parameter::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.name)
  return _s;
}
inline const std::string& CustomEvent_Parameter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomEvent_Parameter::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent_Parameter::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent_Parameter::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.name)
  return _impl_.name_.Release();
}
inline void CustomEvent_Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.name)
}

// string value = 2;
inline void CustomEvent_Parameter::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::value() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent_Parameter::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.value)
  return _s;
}
inline const std::string& CustomEvent_Parameter::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CustomEvent_Parameter::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent_Parameter::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent_Parameter::release_value() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.value)
  return _impl_.value_.Release();
}
inline void CustomEvent_Parameter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.value)
}

// -------------------------------------------------------------------

// CustomEvent

// string name = 1;
inline void CustomEvent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.name)
  return _s;
}
inline const std::string& CustomEvent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.name)
  return _impl_.name_.Release();
}
inline void CustomEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.name)
}

// .ai.inworld.packets.Playback playback = 2;
inline void CustomEvent::clear_playback() {
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback CustomEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(_impl_.playback_);
}
inline ::ai::inworld::packets::Playback CustomEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.playback)
  return _internal_playback();
}
inline void CustomEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  _impl_.playback_ = value;
}
inline void CustomEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.playback)
}

// repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
inline int CustomEvent::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int CustomEvent::parameters_size() const {
  return _internal_parameters_size();
}
inline void CustomEvent::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.parameters)
  return _impl_.parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
CustomEvent::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CustomEvent.parameters)
  return &_impl_.parameters_;
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::parameters(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.parameters)
  return _internal_parameters(index);
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::_internal_add_parameters() {
  return _impl_.parameters_.Add();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::add_parameters() {
  ::ai::inworld::packets::CustomEvent_Parameter* _add = _internal_add_parameters();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CustomEvent.parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
CustomEvent::parameters() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CustomEvent.parameters)
  return _impl_.parameters_;
}

// -------------------------------------------------------------------

// CancelResponsesEvent

// string interaction_id = 1;
inline void CancelResponsesEvent::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponsesEvent::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelResponsesEvent::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void CancelResponsesEvent::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelResponsesEvent::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelResponsesEvent::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void CancelResponsesEvent::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponsesEvent::_internal_utterance_id_size() const {
  return _impl_.utterance_id_.size();
}
inline int CancelResponsesEvent::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponsesEvent::clear_utterance_id() {
  _impl_.utterance_id_.Clear();
}
inline std::string* CancelResponsesEvent::add_utterance_id() {
  std::string* _s = _internal_add_utterance_id();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _s;
}
inline const std::string& CancelResponsesEvent::_internal_utterance_id(int index) const {
  return _impl_.utterance_id_.Get(index);
}
inline const std::string& CancelResponsesEvent::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponsesEvent::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _impl_.utterance_id_.Mutable(index);
}
inline void CancelResponsesEvent::set_utterance_id(int index, const std::string& value) {
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, std::string&& value) {
  _impl_.utterance_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value, size_t size) {
  _impl_.utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline std::string* CancelResponsesEvent::_internal_add_utterance_id() {
  return _impl_.utterance_id_.Add();
}
inline void CancelResponsesEvent::add_utterance_id(const std::string& value) {
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(std::string&& value) {
  _impl_.utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value, size_t size) {
  _impl_.utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponsesEvent::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _impl_.utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponsesEvent::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return &_impl_.utterance_id_;
}

// -------------------------------------------------------------------

// EmotionEvent

// float joy = 1;
inline void EmotionEvent::clear_joy() {
  _impl_.joy_ = 0;
}
inline float EmotionEvent::_internal_joy() const {
  return _impl_.joy_;
}
inline float EmotionEvent::joy() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.joy)
  return _internal_joy();
}
inline void EmotionEvent::_internal_set_joy(float value) {
  
  _impl_.joy_ = value;
}
inline void EmotionEvent::set_joy(float value) {
  _internal_set_joy(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.joy)
}

// float fear = 2;
inline void EmotionEvent::clear_fear() {
  _impl_.fear_ = 0;
}
inline float EmotionEvent::_internal_fear() const {
  return _impl_.fear_;
}
inline float EmotionEvent::fear() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.fear)
  return _internal_fear();
}
inline void EmotionEvent::_internal_set_fear(float value) {
  
  _impl_.fear_ = value;
}
inline void EmotionEvent::set_fear(float value) {
  _internal_set_fear(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.fear)
}

// float trust = 3;
inline void EmotionEvent::clear_trust() {
  _impl_.trust_ = 0;
}
inline float EmotionEvent::_internal_trust() const {
  return _impl_.trust_;
}
inline float EmotionEvent::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.trust)
  return _internal_trust();
}
inline void EmotionEvent::_internal_set_trust(float value) {
  
  _impl_.trust_ = value;
}
inline void EmotionEvent::set_trust(float value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.trust)
}

// float surprise = 4;
inline void EmotionEvent::clear_surprise() {
  _impl_.surprise_ = 0;
}
inline float EmotionEvent::_internal_surprise() const {
  return _impl_.surprise_;
}
inline float EmotionEvent::surprise() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.surprise)
  return _internal_surprise();
}
inline void EmotionEvent::_internal_set_surprise(float value) {
  
  _impl_.surprise_ = value;
}
inline void EmotionEvent::set_surprise(float value) {
  _internal_set_surprise(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.surprise)
}

// .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
inline void EmotionEvent::clear_behavior() {
  _impl_.behavior_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::_internal_behavior() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_SpaffCode >(_impl_.behavior_);
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::behavior() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.behavior)
  return _internal_behavior();
}
inline void EmotionEvent::_internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  
  _impl_.behavior_ = value;
}
inline void EmotionEvent::set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.behavior)
}

// .ai.inworld.packets.EmotionEvent.Strength strength = 6;
inline void EmotionEvent::clear_strength() {
  _impl_.strength_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::_internal_strength() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_Strength >(_impl_.strength_);
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::strength() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.strength)
  return _internal_strength();
}
inline void EmotionEvent::_internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  
  _impl_.strength_ = value;
}
inline void EmotionEvent::set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.strength)
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk = 1;
inline bool DataChunk::_internal_has_chunk() const {
  return data_case() == kChunk;
}
inline bool DataChunk::has_chunk() const {
  return _internal_has_chunk();
}
inline void DataChunk::set_has_chunk() {
  _impl_._oneof_case_[0] = kChunk;
}
inline void DataChunk::clear_chunk() {
  if (_internal_has_chunk()) {
    _impl_.data_.chunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& DataChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline void DataChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.chunk)
  return _s;
}
inline const std::string& DataChunk::_internal_chunk() const {
  if (_internal_has_chunk()) {
    return _impl_.data_.chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataChunk::_internal_set_chunk(const std::string& value) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* DataChunk::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  return _impl_.data_.chunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DataChunk.chunk)
  if (_internal_has_chunk()) {
    clear_has_data();
    return _impl_.data_.chunk_.Release();
  } else {
    return nullptr;
  }
}
inline void DataChunk::set_allocated_chunk(std::string* chunk) {
  if (has_data()) {
    clear_data();
  }
  if (chunk != nullptr) {
    set_has_chunk();
    _impl_.data_.chunk_.InitAllocated(chunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DataChunk.chunk)
}

// int64 duration_ms = 3;
inline bool DataChunk::_internal_has_duration_ms() const {
  return data_case() == kDurationMs;
}
inline bool DataChunk::has_duration_ms() const {
  return _internal_has_duration_ms();
}
inline void DataChunk::set_has_duration_ms() {
  _impl_._oneof_case_[0] = kDurationMs;
}
inline void DataChunk::clear_duration_ms() {
  if (_internal_has_duration_ms()) {
    _impl_.data_.duration_ms_ = int64_t{0};
    clear_has_data();
  }
}
inline int64_t DataChunk::_internal_duration_ms() const {
  if (_internal_has_duration_ms()) {
    return _impl_.data_.duration_ms_;
  }
  return int64_t{0};
}
inline void DataChunk::_internal_set_duration_ms(int64_t value) {
  if (!_internal_has_duration_ms()) {
    clear_data();
    set_has_duration_ms();
  }
  _impl_.data_.duration_ms_ = value;
}
inline int64_t DataChunk::duration_ms() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.duration_ms)
  return _internal_duration_ms();
}
inline void DataChunk::set_duration_ms(int64_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.duration_ms)
}

// .ai.inworld.packets.DataChunk.DataType type = 2;
inline void DataChunk::clear_type() {
  _impl_.type_ = 0;
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::_internal_type() const {
  return static_cast< ::ai::inworld::packets::DataChunk_DataType >(_impl_.type_);
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.type)
  return _internal_type();
}
inline void DataChunk::_internal_set_type(::ai::inworld::packets::DataChunk_DataType value) {
  
  _impl_.type_ = value;
}
inline void DataChunk::set_type(::ai::inworld::packets::DataChunk_DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.type)
}

// repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
inline int DataChunk::_internal_additional_phoneme_info_size() const {
  return _impl_.additional_phoneme_info_.size();
}
inline int DataChunk::additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info_size();
}
inline void DataChunk::clear_additional_phoneme_info() {
  _impl_.additional_phoneme_info_.Clear();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::mutable_additional_phoneme_info(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _impl_.additional_phoneme_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
DataChunk::mutable_additional_phoneme_info() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return &_impl_.additional_phoneme_info_;
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::_internal_additional_phoneme_info(int index) const {
  return _impl_.additional_phoneme_info_.Get(index);
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::additional_phoneme_info(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info(index);
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::_internal_add_additional_phoneme_info() {
  return _impl_.additional_phoneme_info_.Add();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::add_additional_phoneme_info() {
  ::ai::inworld::packets::AdditionalPhonemeInfo* _add = _internal_add_additional_phoneme_info();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
DataChunk::additional_phoneme_info() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _impl_.additional_phoneme_info_;
}

inline bool DataChunk::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void DataChunk::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline DataChunk::DataCase DataChunk::data_case() const {
  return DataChunk::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdditionalPhonemeInfo

// string phoneme = 1;
inline void AdditionalPhonemeInfo::clear_phoneme() {
  _impl_.phoneme_.ClearToEmpty();
}
inline const std::string& AdditionalPhonemeInfo::phoneme() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_phoneme();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdditionalPhonemeInfo::set_phoneme(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phoneme_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::mutable_phoneme() {
  std::string* _s = _internal_mutable_phoneme();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _s;
}
inline const std::string& AdditionalPhonemeInfo::_internal_phoneme() const {
  return _impl_.phoneme_.Get();
}
inline void AdditionalPhonemeInfo::_internal_set_phoneme(const std::string& value) {
  
  _impl_.phoneme_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalPhonemeInfo::_internal_mutable_phoneme() {
  
  return _impl_.phoneme_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalPhonemeInfo::release_phoneme() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _impl_.phoneme_.Release();
}
inline void AdditionalPhonemeInfo::set_allocated_phoneme(std::string* phoneme) {
  if (phoneme != nullptr) {
    
  } else {
    
  }
  _impl_.phoneme_.SetAllocated(phoneme, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phoneme_.IsDefault()) {
    _impl_.phoneme_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}

// .google.protobuf.Duration start_offset = 2;
inline bool AdditionalPhonemeInfo::_internal_has_start_offset() const {
  return this != internal_default_instance() && _impl_.start_offset_ != nullptr;
}
inline bool AdditionalPhonemeInfo::has_start_offset() const {
  return _internal_has_start_offset();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::_internal_start_offset() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.start_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::start_offset() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_start_offset();
}
inline void AdditionalPhonemeInfo::unsafe_arena_set_allocated_start_offset(
    ::PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_offset_);
  }
  _impl_.start_offset_ = start_offset;
  if (start_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::release_start_offset() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::unsafe_arena_release_start_offset() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.start_offset_;
  _impl_.start_offset_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::_internal_mutable_start_offset() {
  
  if (_impl_.start_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.start_offset_ = p;
  }
  return _impl_.start_offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::mutable_start_offset() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_start_offset();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _msg;
}
inline void AdditionalPhonemeInfo::set_allocated_start_offset(::PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_offset_);
  }
  if (start_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset));
    if (message_arena != submessage_arena) {
      start_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_offset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_offset_ = start_offset;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}

// -------------------------------------------------------------------

// ActionEvent

// .ai.inworld.packets.NarratedAction narrated_action = 1;
inline bool ActionEvent::_internal_has_narrated_action() const {
  return action_case() == kNarratedAction;
}
inline bool ActionEvent::has_narrated_action() const {
  return _internal_has_narrated_action();
}
inline void ActionEvent::set_has_narrated_action() {
  _impl_._oneof_case_[0] = kNarratedAction;
}
inline void ActionEvent::clear_narrated_action() {
  if (_internal_has_narrated_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.narrated_action_;
    }
    clear_has_action();
  }
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::release_narrated_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
    ::ai::inworld::packets::NarratedAction* temp = _impl_.action_.narrated_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::_internal_narrated_action() const {
  return _internal_has_narrated_action()
      ? *_impl_.action_.narrated_action_
      : reinterpret_cast< ::ai::inworld::packets::NarratedAction&>(::ai::inworld::packets::_NarratedAction_default_instance_);
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::narrated_action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_narrated_action();
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::unsafe_arena_release_narrated_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
    ::ai::inworld::packets::NarratedAction* temp = _impl_.action_.narrated_action_;
    _impl_.action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionEvent::unsafe_arena_set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action) {
  clear_action();
  if (narrated_action) {
    set_has_narrated_action();
    _impl_.action_.narrated_action_ = narrated_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ActionEvent.narrated_action)
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::_internal_mutable_narrated_action() {
  if (!_internal_has_narrated_action()) {
    clear_action();
    set_has_narrated_action();
    _impl_.action_.narrated_action_ = CreateMaybeMessage< ::ai::inworld::packets::NarratedAction >(GetArenaForAllocation());
  }
  return _impl_.action_.narrated_action_;
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::mutable_narrated_action() {
  ::ai::inworld::packets::NarratedAction* _msg = _internal_mutable_narrated_action();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ActionEvent.narrated_action)
  return _msg;
}

// .ai.inworld.packets.Playback playback = 2;
inline void ActionEvent::clear_playback() {
  _impl_.playback_ = 0;
}
inline ::ai::inworld::packets::Playback ActionEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(_impl_.playback_);
}
inline ::ai::inworld::packets::Playback ActionEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.playback)
  return _internal_playback();
}
inline void ActionEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  _impl_.playback_ = value;
}
inline void ActionEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ActionEvent.playback)
}

inline bool ActionEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionEvent::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionEvent::ActionCase ActionEvent::action_case() const {
  return ActionEvent::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NarratedAction

// string content = 1;
inline void NarratedAction::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& NarratedAction::content() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.NarratedAction.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NarratedAction::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.NarratedAction.content)
  return _s;
}
inline const std::string& NarratedAction::_internal_content() const {
  return _impl_.content_.Get();
}
inline void NarratedAction::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* NarratedAction::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* NarratedAction::release_content() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.NarratedAction.content)
  return _impl_.content_.Release();
}
inline void NarratedAction::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.NarratedAction.content)
}

// -------------------------------------------------------------------

// RelationInfo_RelationAttributes

// int32 trust = 1;
inline void RelationInfo_RelationAttributes::clear_trust() {
  _impl_.trust_ = 0;
}
inline int32_t RelationInfo_RelationAttributes::_internal_trust() const {
  return _impl_.trust_;
}
inline int32_t RelationInfo_RelationAttributes::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
  return _internal_trust();
}
inline void RelationInfo_RelationAttributes::_internal_set_trust(int32_t value) {
  
  _impl_.trust_ = value;
}
inline void RelationInfo_RelationAttributes::set_trust(int32_t value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
}

// int32 respect = 2;
inline void RelationInfo_RelationAttributes::clear_respect() {
  _impl_.respect_ = 0;
}
inline int32_t RelationInfo_RelationAttributes::_internal_respect() const {
  return _impl_.respect_;
}
inline int32_t RelationInfo_RelationAttributes::respect() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
  return _internal_respect();
}
inline void RelationInfo_RelationAttributes::_internal_set_respect(int32_t value) {
  
  _impl_.respect_ = value;
}
inline void RelationInfo_RelationAttributes::set_respect(int32_t value) {
  _internal_set_respect(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
}

// int32 familiar = 3;
inline void RelationInfo_RelationAttributes::clear_familiar() {
  _impl_.familiar_ = 0;
}
inline int32_t RelationInfo_RelationAttributes::_internal_familiar() const {
  return _impl_.familiar_;
}
inline int32_t RelationInfo_RelationAttributes::familiar() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
  return _internal_familiar();
}
inline void RelationInfo_RelationAttributes::_internal_set_familiar(int32_t value) {
  
  _impl_.familiar_ = value;
}
inline void RelationInfo_RelationAttributes::set_familiar(int32_t value) {
  _internal_set_familiar(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
}

// int32 flirtatious = 4;
inline void RelationInfo_RelationAttributes::clear_flirtatious() {
  _impl_.flirtatious_ = 0;
}
inline int32_t RelationInfo_RelationAttributes::_internal_flirtatious() const {
  return _impl_.flirtatious_;
}
inline int32_t RelationInfo_RelationAttributes::flirtatious() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
  return _internal_flirtatious();
}
inline void RelationInfo_RelationAttributes::_internal_set_flirtatious(int32_t value) {
  
  _impl_.flirtatious_ = value;
}
inline void RelationInfo_RelationAttributes::set_flirtatious(int32_t value) {
  _internal_set_flirtatious(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
}

// int32 attraction = 5;
inline void RelationInfo_RelationAttributes::clear_attraction() {
  _impl_.attraction_ = 0;
}
inline int32_t RelationInfo_RelationAttributes::_internal_attraction() const {
  return _impl_.attraction_;
}
inline int32_t RelationInfo_RelationAttributes::attraction() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
  return _internal_attraction();
}
inline void RelationInfo_RelationAttributes::_internal_set_attraction(int32_t value) {
  
  _impl_.attraction_ = value;
}
inline void RelationInfo_RelationAttributes::set_attraction(int32_t value) {
  _internal_set_attraction(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
}

// -------------------------------------------------------------------

// RelationInfo

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
inline bool RelationInfo::_internal_has_relation_state() const {
  return this != internal_default_instance() && _impl_.relation_state_ != nullptr;
}
inline bool RelationInfo::has_relation_state() const {
  return _internal_has_relation_state();
}
inline void RelationInfo::clear_relation_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.relation_state_ != nullptr) {
    delete _impl_.relation_state_;
  }
  _impl_.relation_state_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_state() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = _impl_.relation_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_state() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_relation_state();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_state(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relation_state_);
  }
  _impl_.relation_state_ = relation_state;
  if (relation_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_state() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_state_;
  _impl_.relation_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_state() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_state)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_state_;
  _impl_.relation_state_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_state() {
  
  if (_impl_.relation_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArenaForAllocation());
    _impl_.relation_state_ = p;
  }
  return _impl_.relation_state_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_state() {
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _msg = _internal_mutable_relation_state();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_state)
  return _msg;
}
inline void RelationInfo::set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relation_state_;
  }
  if (relation_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relation_state);
    if (message_arena != submessage_arena) {
      relation_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relation_state_ = relation_state;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
inline bool RelationInfo::_internal_has_relation_update() const {
  return this != internal_default_instance() && _impl_.relation_update_ != nullptr;
}
inline bool RelationInfo::has_relation_update() const {
  return _internal_has_relation_update();
}
inline void RelationInfo::clear_relation_update() {
  if (GetArenaForAllocation() == nullptr && _impl_.relation_update_ != nullptr) {
    delete _impl_.relation_update_;
  }
  _impl_.relation_update_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_update() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = _impl_.relation_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_update() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_relation_update();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_update(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relation_update_);
  }
  _impl_.relation_update_ = relation_update;
  if (relation_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_update() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_update_;
  _impl_.relation_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_update() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_update)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = _impl_.relation_update_;
  _impl_.relation_update_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_update() {
  
  if (_impl_.relation_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArenaForAllocation());
    _impl_.relation_update_ = p;
  }
  return _impl_.relation_update_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_update() {
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _msg = _internal_mutable_relation_update();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_update)
  return _msg;
}
inline void RelationInfo::set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relation_update_;
  }
  if (relation_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relation_update);
    if (message_arena != submessage_arena) {
      relation_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_update, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relation_update_ = relation_update;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}

// -------------------------------------------------------------------

// MutationEvent

// .ai.inworld.packets.CancelResponses cancel_responses = 1;
inline bool MutationEvent::_internal_has_cancel_responses() const {
  return mutation_case() == kCancelResponses;
}
inline bool MutationEvent::has_cancel_responses() const {
  return _internal_has_cancel_responses();
}
inline void MutationEvent::set_has_cancel_responses() {
  _impl_._oneof_case_[0] = kCancelResponses;
}
inline void MutationEvent::clear_cancel_responses() {
  if (_internal_has_cancel_responses()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mutation_.cancel_responses_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::release_cancel_responses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
    ::ai::inworld::packets::CancelResponses* temp = _impl_.mutation_.cancel_responses_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::_internal_cancel_responses() const {
  return _internal_has_cancel_responses()
      ? *_impl_.mutation_.cancel_responses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponses&>(::ai::inworld::packets::_CancelResponses_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::cancel_responses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_cancel_responses();
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::unsafe_arena_release_cancel_responses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
    ::ai::inworld::packets::CancelResponses* temp = _impl_.mutation_.cancel_responses_;
    _impl_.mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses) {
  clear_mutation();
  if (cancel_responses) {
    set_has_cancel_responses();
    _impl_.mutation_.cancel_responses_ = cancel_responses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.cancel_responses)
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::_internal_mutable_cancel_responses() {
  if (!_internal_has_cancel_responses()) {
    clear_mutation();
    set_has_cancel_responses();
    _impl_.mutation_.cancel_responses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponses >(GetArenaForAllocation());
  }
  return _impl_.mutation_.cancel_responses_;
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::mutable_cancel_responses() {
  ::ai::inworld::packets::CancelResponses* _msg = _internal_mutable_cancel_responses();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.cancel_responses)
  return _msg;
}

// .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
inline bool MutationEvent::_internal_has_regenerate_response() const {
  return mutation_case() == kRegenerateResponse;
}
inline bool MutationEvent::has_regenerate_response() const {
  return _internal_has_regenerate_response();
}
inline void MutationEvent::set_has_regenerate_response() {
  _impl_._oneof_case_[0] = kRegenerateResponse;
}
inline void MutationEvent::clear_regenerate_response() {
  if (_internal_has_regenerate_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mutation_.regenerate_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::release_regenerate_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::RegenerateResponse* temp = _impl_.mutation_.regenerate_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::_internal_regenerate_response() const {
  return _internal_has_regenerate_response()
      ? *_impl_.mutation_.regenerate_response_
      : reinterpret_cast< ::ai::inworld::packets::RegenerateResponse&>(::ai::inworld::packets::_RegenerateResponse_default_instance_);
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::regenerate_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_regenerate_response();
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::unsafe_arena_release_regenerate_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::RegenerateResponse* temp = _impl_.mutation_.regenerate_response_;
    _impl_.mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response) {
  clear_mutation();
  if (regenerate_response) {
    set_has_regenerate_response();
    _impl_.mutation_.regenerate_response_ = regenerate_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.regenerate_response)
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::_internal_mutable_regenerate_response() {
  if (!_internal_has_regenerate_response()) {
    clear_mutation();
    set_has_regenerate_response();
    _impl_.mutation_.regenerate_response_ = CreateMaybeMessage< ::ai::inworld::packets::RegenerateResponse >(GetArenaForAllocation());
  }
  return _impl_.mutation_.regenerate_response_;
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::mutable_regenerate_response() {
  ::ai::inworld::packets::RegenerateResponse* _msg = _internal_mutable_regenerate_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.regenerate_response)
  return _msg;
}

// .ai.inworld.packets.ApplyResponse apply_response = 3;
inline bool MutationEvent::_internal_has_apply_response() const {
  return mutation_case() == kApplyResponse;
}
inline bool MutationEvent::has_apply_response() const {
  return _internal_has_apply_response();
}
inline void MutationEvent::set_has_apply_response() {
  _impl_._oneof_case_[0] = kApplyResponse;
}
inline void MutationEvent::clear_apply_response() {
  if (_internal_has_apply_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mutation_.apply_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::release_apply_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ApplyResponse* temp = _impl_.mutation_.apply_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::_internal_apply_response() const {
  return _internal_has_apply_response()
      ? *_impl_.mutation_.apply_response_
      : reinterpret_cast< ::ai::inworld::packets::ApplyResponse&>(::ai::inworld::packets::_ApplyResponse_default_instance_);
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::apply_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_apply_response();
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::unsafe_arena_release_apply_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ApplyResponse* temp = _impl_.mutation_.apply_response_;
    _impl_.mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response) {
  clear_mutation();
  if (apply_response) {
    set_has_apply_response();
    _impl_.mutation_.apply_response_ = apply_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.apply_response)
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::_internal_mutable_apply_response() {
  if (!_internal_has_apply_response()) {
    clear_mutation();
    set_has_apply_response();
    _impl_.mutation_.apply_response_ = CreateMaybeMessage< ::ai::inworld::packets::ApplyResponse >(GetArenaForAllocation());
  }
  return _impl_.mutation_.apply_response_;
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::mutable_apply_response() {
  ::ai::inworld::packets::ApplyResponse* _msg = _internal_mutable_apply_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.apply_response)
  return _msg;
}

// .ai.inworld.packets.LoadScene load_scene = 4;
inline bool MutationEvent::_internal_has_load_scene() const {
  return mutation_case() == kLoadScene;
}
inline bool MutationEvent::has_load_scene() const {
  return _internal_has_load_scene();
}
inline void MutationEvent::set_has_load_scene() {
  _impl_._oneof_case_[0] = kLoadScene;
}
inline void MutationEvent::clear_load_scene() {
  if (_internal_has_load_scene()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mutation_.load_scene_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::release_load_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
    ::ai::inworld::packets::LoadScene* temp = _impl_.mutation_.load_scene_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::_internal_load_scene() const {
  return _internal_has_load_scene()
      ? *_impl_.mutation_.load_scene_
      : reinterpret_cast< ::ai::inworld::packets::LoadScene&>(::ai::inworld::packets::_LoadScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::load_scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_load_scene();
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::unsafe_arena_release_load_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
    ::ai::inworld::packets::LoadScene* temp = _impl_.mutation_.load_scene_;
    _impl_.mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene) {
  clear_mutation();
  if (load_scene) {
    set_has_load_scene();
    _impl_.mutation_.load_scene_ = load_scene;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_scene)
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::_internal_mutable_load_scene() {
  if (!_internal_has_load_scene()) {
    clear_mutation();
    set_has_load_scene();
    _impl_.mutation_.load_scene_ = CreateMaybeMessage< ::ai::inworld::packets::LoadScene >(GetArenaForAllocation());
  }
  return _impl_.mutation_.load_scene_;
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::mutable_load_scene() {
  ::ai::inworld::packets::LoadScene* _msg = _internal_mutable_load_scene();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_scene)
  return _msg;
}

// .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
inline bool MutationEvent::_internal_has_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse;
}
inline bool MutationEvent::has_modify_exact_response() const {
  return _internal_has_modify_exact_response();
}
inline void MutationEvent::set_has_modify_exact_response() {
  _impl_._oneof_case_[0] = kModifyExactResponse;
}
inline void MutationEvent::clear_modify_exact_response() {
  if (_internal_has_modify_exact_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mutation_.modify_exact_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::release_modify_exact_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ModifyExactResponse* temp = _impl_.mutation_.modify_exact_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::_internal_modify_exact_response() const {
  return _internal_has_modify_exact_response()
      ? *_impl_.mutation_.modify_exact_response_
      : reinterpret_cast< ::ai::inworld::packets::ModifyExactResponse&>(::ai::inworld::packets::_ModifyExactResponse_default_instance_);
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::modify_exact_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_modify_exact_response();
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::unsafe_arena_release_modify_exact_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ModifyExactResponse* temp = _impl_.mutation_.modify_exact_response_;
    _impl_.mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response) {
  clear_mutation();
  if (modify_exact_response) {
    set_has_modify_exact_response();
    _impl_.mutation_.modify_exact_response_ = modify_exact_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.modify_exact_response)
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::_internal_mutable_modify_exact_response() {
  if (!_internal_has_modify_exact_response()) {
    clear_mutation();
    set_has_modify_exact_response();
    _impl_.mutation_.modify_exact_response_ = CreateMaybeMessage< ::ai::inworld::packets::ModifyExactResponse >(GetArenaForAllocation());
  }
  return _impl_.mutation_.modify_exact_response_;
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::mutable_modify_exact_response() {
  ::ai::inworld::packets::ModifyExactResponse* _msg = _internal_mutable_modify_exact_response();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _msg;
}

inline bool MutationEvent::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void MutationEvent::clear_has_mutation() {
  _impl_._oneof_case_[0] = MUTATION_NOT_SET;
}
inline MutationEvent::MutationCase MutationEvent::mutation_case() const {
  return MutationEvent::MutationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CancelResponses

// string interaction_id = 1;
inline void CancelResponses::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponses::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelResponses::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.interaction_id)
  return _s;
}
inline const std::string& CancelResponses::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void CancelResponses::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelResponses::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelResponses::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponses.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void CancelResponses::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponses.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponses::_internal_utterance_id_size() const {
  return _impl_.utterance_id_.size();
}
inline int CancelResponses::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponses::clear_utterance_id() {
  _impl_.utterance_id_.Clear();
}
inline std::string* CancelResponses::add_utterance_id() {
  std::string* _s = _internal_add_utterance_id();
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _s;
}
inline const std::string& CancelResponses::_internal_utterance_id(int index) const {
  return _impl_.utterance_id_.Get(index);
}
inline const std::string& CancelResponses::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponses::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _impl_.utterance_id_.Mutable(index);
}
inline void CancelResponses::set_utterance_id(int index, const std::string& value) {
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, std::string&& value) {
  _impl_.utterance_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value, size_t size) {
  _impl_.utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline std::string* CancelResponses::_internal_add_utterance_id() {
  return _impl_.utterance_id_.Add();
}
inline void CancelResponses::add_utterance_id(const std::string& value) {
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(std::string&& value) {
  _impl_.utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value, size_t size) {
  _impl_.utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponses::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponses.utterance_id)
  return _impl_.utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponses::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponses.utterance_id)
  return &_impl_.utterance_id_;
}

// -------------------------------------------------------------------

// RegenerateResponse

// string interaction_id = 1;
inline void RegenerateResponse::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& RegenerateResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegenerateResponse::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _s;
}
inline const std::string& RegenerateResponse::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void RegenerateResponse::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegenerateResponse::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegenerateResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void RegenerateResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RegenerateResponse.interaction_id)
}

// -------------------------------------------------------------------

// ApplyResponse

// .ai.inworld.packets.PacketId packet_id = 1;
inline bool ApplyResponse::_internal_has_packet_id() const {
  return this != internal_default_instance() && _impl_.packet_id_ != nullptr;
}
inline bool ApplyResponse::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void ApplyResponse::clear_packet_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_id_ != nullptr) {
    delete _impl_.packet_id_;
  }
  _impl_.packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_packet_id();
}
inline void ApplyResponse::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ApplyResponse.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::_internal_mutable_packet_id() {
  
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArenaForAllocation());
    _impl_.packet_id_ = p;
  }
  return _impl_.packet_id_;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::mutable_packet_id() {
  ::ai::inworld::packets::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ApplyResponse.packet_id)
  return _msg;
}
inline void ApplyResponse::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}

// -------------------------------------------------------------------

// LoadScene

// string name = 1;
inline void LoadScene::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoadScene::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadScene.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadScene::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadScene.name)
  return _s;
}
inline const std::string& LoadScene::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoadScene::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadScene::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadScene::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadScene.name)
  return _impl_.name_.Release();
}
inline void LoadScene::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadScene.name)
}

// -------------------------------------------------------------------

// ModifyExactResponse

// string interaction_id = 1;
inline void ModifyExactResponse::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyExactResponse::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _s;
}
inline const std::string& ModifyExactResponse::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void ModifyExactResponse::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyExactResponse::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyExactResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void ModifyExactResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.interaction_id)
}

// string exact_text = 2;
inline void ModifyExactResponse::clear_exact_text() {
  _impl_.exact_text_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::exact_text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_exact_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyExactResponse::set_exact_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exact_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::mutable_exact_text() {
  std::string* _s = _internal_mutable_exact_text();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _s;
}
inline const std::string& ModifyExactResponse::_internal_exact_text() const {
  return _impl_.exact_text_.Get();
}
inline void ModifyExactResponse::_internal_set_exact_text(const std::string& value) {
  
  _impl_.exact_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyExactResponse::_internal_mutable_exact_text() {
  
  return _impl_.exact_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyExactResponse::release_exact_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _impl_.exact_text_.Release();
}
inline void ModifyExactResponse::set_allocated_exact_text(std::string* exact_text) {
  if (exact_text != nullptr) {
    
  } else {
    
  }
  _impl_.exact_text_.SetAllocated(exact_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exact_text_.IsDefault()) {
    _impl_.exact_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.exact_text)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent_Agent

// string agent_id = 1;
inline void LoadSceneOutputEvent_Agent::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::agent_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadSceneOutputEvent_Agent::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::release_agent_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _impl_.agent_id_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}

// string brain_name = 2;
inline void LoadSceneOutputEvent_Agent::clear_brain_name() {
  _impl_.brain_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::brain_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_brain_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadSceneOutputEvent_Agent::set_brain_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.brain_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_brain_name() {
  std::string* _s = _internal_mutable_brain_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_brain_name() const {
  return _impl_.brain_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_brain_name(const std::string& value) {
  
  _impl_.brain_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_brain_name() {
  
  return _impl_.brain_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::release_brain_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _impl_.brain_name_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_brain_name(std::string* brain_name) {
  if (brain_name != nullptr) {
    
  } else {
    
  }
  _impl_.brain_name_.SetAllocated(brain_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.brain_name_.IsDefault()) {
    _impl_.brain_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}

// string given_name = 3;
inline void LoadSceneOutputEvent_Agent::clear_given_name() {
  _impl_.given_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::given_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_given_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadSceneOutputEvent_Agent::set_given_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.given_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_given_name() {
  std::string* _s = _internal_mutable_given_name();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _s;
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_given_name() const {
  return _impl_.given_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_given_name(const std::string& value) {
  
  _impl_.given_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_given_name() {
  
  return _impl_.given_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadSceneOutputEvent_Agent::release_given_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _impl_.given_name_.Release();
}
inline void LoadSceneOutputEvent_Agent::set_allocated_given_name(std::string* given_name) {
  if (given_name != nullptr) {
    
  } else {
    
  }
  _impl_.given_name_.SetAllocated(given_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.given_name_.IsDefault()) {
    _impl_.given_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent

// repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
inline int LoadSceneOutputEvent::_internal_agents_size() const {
  return _impl_.agents_.size();
}
inline int LoadSceneOutputEvent::agents_size() const {
  return _internal_agents_size();
}
inline void LoadSceneOutputEvent::clear_agents() {
  _impl_.agents_.Clear();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _impl_.agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
LoadSceneOutputEvent::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return &_impl_.agents_;
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::_internal_agents(int index) const {
  return _impl_.agents_.Get(index);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::_internal_add_agents() {
  return _impl_.agents_.Add();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::add_agents() {
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* _add = _internal_add_agents();
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
LoadSceneOutputEvent::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _impl_.agents_;
}

// -------------------------------------------------------------------

// DebugInfoEvent

// .ai.inworld.packets.RelationInfo relation = 1;
inline bool DebugInfoEvent::_internal_has_relation() const {
  return info_case() == kRelation;
}
inline bool DebugInfoEvent::has_relation() const {
  return _internal_has_relation();
}
inline void DebugInfoEvent::set_has_relation() {
  _impl_._oneof_case_[0] = kRelation;
}
inline void DebugInfoEvent::clear_relation() {
  if (_internal_has_relation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.info_.relation_;
    }
    clear_has_info();
  }
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::release_relation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
    ::ai::inworld::packets::RelationInfo* temp = _impl_.info_.relation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::_internal_relation() const {
  return _internal_has_relation()
      ? *_impl_.info_.relation_
      : reinterpret_cast< ::ai::inworld::packets::RelationInfo&>(::ai::inworld::packets::_RelationInfo_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::relation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_relation();
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::unsafe_arena_release_relation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
    ::ai::inworld::packets::RelationInfo* temp = _impl_.info_.relation_;
    _impl_.info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugInfoEvent::unsafe_arena_set_allocated_relation(::ai::inworld::packets::RelationInfo* relation) {
  clear_info();
  if (relation) {
    set_has_relation();
    _impl_.info_.relation_ = relation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DebugInfoEvent.relation)
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::_internal_mutable_relation() {
  if (!_internal_has_relation()) {
    clear_info();
    set_has_relation();
    _impl_.info_.relation_ = CreateMaybeMessage< ::ai::inworld::packets::RelationInfo >(GetArenaForAllocation());
  }
  return _impl_.info_.relation_;
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::mutable_relation() {
  ::ai::inworld::packets::RelationInfo* _msg = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DebugInfoEvent.relation)
  return _msg;
}

inline bool DebugInfoEvent::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void DebugInfoEvent::clear_has_info() {
  _impl_._oneof_case_[0] = INFO_NOT_SET;
}
inline DebugInfoEvent::InfoCase DebugInfoEvent::info_case() const {
  return DebugInfoEvent::InfoCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace inworld
}  // namespace ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ai::inworld::packets::Actor_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Actor_Type>() {
  return ::ai::inworld::packets::Actor_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::TextEvent_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::TextEvent_SourceType>() {
  return ::ai::inworld::packets::TextEvent_SourceType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ControlEvent_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ControlEvent_Action>() {
  return ::ai::inworld::packets::ControlEvent_Action_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_SpaffCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_SpaffCode>() {
  return ::ai::inworld::packets::EmotionEvent_SpaffCode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_Strength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_Strength>() {
  return ::ai::inworld::packets::EmotionEvent_Strength_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_DataType>() {
  return ::ai::inworld::packets::DataChunk_DataType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::Playback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Playback>() {
  return ::ai::inworld::packets::Playback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
