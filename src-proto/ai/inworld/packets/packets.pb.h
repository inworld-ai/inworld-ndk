// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ai/inworld/packets/packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
#include "ai/inworld/options/options.pb.h"
#include "ai/inworld/engine/configuration/configuration.pb.h"
#include "ai/inworld/language_codes/language_codes.pb.h"
#include "ai/inworld/packets/entities/entities_packets.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ai_2finworld_2fpackets_2fpackets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[57]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto;
namespace ai {
namespace inworld {
namespace packets {
class ActionEvent;
class ActionEventDefaultTypeInternal;
extern ActionEventDefaultTypeInternal _ActionEvent_default_instance_;
class Actor;
class ActorDefaultTypeInternal;
extern ActorDefaultTypeInternal _Actor_default_instance_;
class AdditionalPhonemeInfo;
class AdditionalPhonemeInfoDefaultTypeInternal;
extern AdditionalPhonemeInfoDefaultTypeInternal _AdditionalPhonemeInfo_default_instance_;
class Agent;
class AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class Agent_CharacterAssets;
class Agent_CharacterAssetsDefaultTypeInternal;
extern Agent_CharacterAssetsDefaultTypeInternal _Agent_CharacterAssets_default_instance_;
class ApplyResponse;
class ApplyResponseDefaultTypeInternal;
extern ApplyResponseDefaultTypeInternal _ApplyResponse_default_instance_;
class AudioChunk;
class AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class AudioSessionStartPayload;
class AudioSessionStartPayloadDefaultTypeInternal;
extern AudioSessionStartPayloadDefaultTypeInternal _AudioSessionStartPayload_default_instance_;
class CancelResponses;
class CancelResponsesDefaultTypeInternal;
extern CancelResponsesDefaultTypeInternal _CancelResponses_default_instance_;
class CancelResponsesEvent;
class CancelResponsesEventDefaultTypeInternal;
extern CancelResponsesEventDefaultTypeInternal _CancelResponsesEvent_default_instance_;
class Continuation;
class ContinuationDefaultTypeInternal;
extern ContinuationDefaultTypeInternal _Continuation_default_instance_;
class Continuation_ContinuationInfo;
class Continuation_ContinuationInfoDefaultTypeInternal;
extern Continuation_ContinuationInfoDefaultTypeInternal _Continuation_ContinuationInfo_default_instance_;
class ControlEvent;
class ControlEventDefaultTypeInternal;
extern ControlEventDefaultTypeInternal _ControlEvent_default_instance_;
class ConversationEventPayload;
class ConversationEventPayloadDefaultTypeInternal;
extern ConversationEventPayloadDefaultTypeInternal _ConversationEventPayload_default_instance_;
class ConversationUpdatePayload;
class ConversationUpdatePayloadDefaultTypeInternal;
extern ConversationUpdatePayloadDefaultTypeInternal _ConversationUpdatePayload_default_instance_;
class CurrentSceneStatus;
class CurrentSceneStatusDefaultTypeInternal;
extern CurrentSceneStatusDefaultTypeInternal _CurrentSceneStatus_default_instance_;
class CustomEvent;
class CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class CustomEvent_Parameter;
class CustomEvent_ParameterDefaultTypeInternal;
extern CustomEvent_ParameterDefaultTypeInternal _CustomEvent_Parameter_default_instance_;
class DataChunk;
class DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class DebugInfoEvent;
class DebugInfoEventDefaultTypeInternal;
extern DebugInfoEventDefaultTypeInternal _DebugInfoEvent_default_instance_;
class DialogHistory;
class DialogHistoryDefaultTypeInternal;
extern DialogHistoryDefaultTypeInternal _DialogHistory_default_instance_;
class DialogHistory_HistoryItem;
class DialogHistory_HistoryItemDefaultTypeInternal;
extern DialogHistory_HistoryItemDefaultTypeInternal _DialogHistory_HistoryItem_default_instance_;
class EmotionEvent;
class EmotionEventDefaultTypeInternal;
extern EmotionEventDefaultTypeInternal _EmotionEvent_default_instance_;
class InworldPacket;
class InworldPacketDefaultTypeInternal;
extern InworldPacketDefaultTypeInternal _InworldPacket_default_instance_;
class LatencyReportEvent;
class LatencyReportEventDefaultTypeInternal;
extern LatencyReportEventDefaultTypeInternal _LatencyReportEvent_default_instance_;
class LoadCharacters;
class LoadCharactersDefaultTypeInternal;
extern LoadCharactersDefaultTypeInternal _LoadCharacters_default_instance_;
class LoadCharacters_CharacterName;
class LoadCharacters_CharacterNameDefaultTypeInternal;
extern LoadCharacters_CharacterNameDefaultTypeInternal _LoadCharacters_CharacterName_default_instance_;
class LoadScene;
class LoadSceneDefaultTypeInternal;
extern LoadSceneDefaultTypeInternal _LoadScene_default_instance_;
class LoadSceneOutputEvent;
class LoadSceneOutputEventDefaultTypeInternal;
extern LoadSceneOutputEventDefaultTypeInternal _LoadSceneOutputEvent_default_instance_;
class LoadSceneOutputEvent_Agent;
class LoadSceneOutputEvent_AgentDefaultTypeInternal;
extern LoadSceneOutputEvent_AgentDefaultTypeInternal _LoadSceneOutputEvent_Agent_default_instance_;
class LoadedCharacters;
class LoadedCharactersDefaultTypeInternal;
extern LoadedCharactersDefaultTypeInternal _LoadedCharacters_default_instance_;
class LoadedScene;
class LoadedSceneDefaultTypeInternal;
extern LoadedSceneDefaultTypeInternal _LoadedScene_default_instance_;
class LogsEvent;
class LogsEventDefaultTypeInternal;
extern LogsEventDefaultTypeInternal _LogsEvent_default_instance_;
class LogsEvent_LogDetail;
class LogsEvent_LogDetailDefaultTypeInternal;
extern LogsEvent_LogDetailDefaultTypeInternal _LogsEvent_LogDetail_default_instance_;
class LogsEvent_MetadataEntry_DoNotUse;
class LogsEvent_MetadataEntry_DoNotUseDefaultTypeInternal;
extern LogsEvent_MetadataEntry_DoNotUseDefaultTypeInternal _LogsEvent_MetadataEntry_DoNotUse_default_instance_;
class ModifyExactResponse;
class ModifyExactResponseDefaultTypeInternal;
extern ModifyExactResponseDefaultTypeInternal _ModifyExactResponse_default_instance_;
class MutationEvent;
class MutationEventDefaultTypeInternal;
extern MutationEventDefaultTypeInternal _MutationEvent_default_instance_;
class NarratedAction;
class NarratedActionDefaultTypeInternal;
extern NarratedActionDefaultTypeInternal _NarratedAction_default_instance_;
class OperationStatusEvent;
class OperationStatusEventDefaultTypeInternal;
extern OperationStatusEventDefaultTypeInternal _OperationStatusEvent_default_instance_;
class PacketId;
class PacketIdDefaultTypeInternal;
extern PacketIdDefaultTypeInternal _PacketId_default_instance_;
class PerceivedLatencyReport;
class PerceivedLatencyReportDefaultTypeInternal;
extern PerceivedLatencyReportDefaultTypeInternal _PerceivedLatencyReport_default_instance_;
class PingPongReport;
class PingPongReportDefaultTypeInternal;
extern PingPongReportDefaultTypeInternal _PingPongReport_default_instance_;
class RegenerateResponse;
class RegenerateResponseDefaultTypeInternal;
extern RegenerateResponseDefaultTypeInternal _RegenerateResponse_default_instance_;
class RelationInfo;
class RelationInfoDefaultTypeInternal;
extern RelationInfoDefaultTypeInternal _RelationInfo_default_instance_;
class RelationInfo_RelationAttributes;
class RelationInfo_RelationAttributesDefaultTypeInternal;
extern RelationInfo_RelationAttributesDefaultTypeInternal _RelationInfo_RelationAttributes_default_instance_;
class Relations;
class RelationsDefaultTypeInternal;
extern RelationsDefaultTypeInternal _Relations_default_instance_;
class Relations_Relation;
class Relations_RelationDefaultTypeInternal;
extern Relations_RelationDefaultTypeInternal _Relations_Relation_default_instance_;
class Routing;
class RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class SessionConfigurationPayload;
class SessionConfigurationPayloadDefaultTypeInternal;
extern SessionConfigurationPayloadDefaultTypeInternal _SessionConfigurationPayload_default_instance_;
class SessionControlEvent;
class SessionControlEventDefaultTypeInternal;
extern SessionControlEventDefaultTypeInternal _SessionControlEvent_default_instance_;
class SessionControlResponseEvent;
class SessionControlResponseEventDefaultTypeInternal;
extern SessionControlResponseEventDefaultTypeInternal _SessionControlResponseEvent_default_instance_;
class SessionHistoryRequest;
class SessionHistoryRequestDefaultTypeInternal;
extern SessionHistoryRequestDefaultTypeInternal _SessionHistoryRequest_default_instance_;
class SessionHistoryResponse;
class SessionHistoryResponseDefaultTypeInternal;
extern SessionHistoryResponseDefaultTypeInternal _SessionHistoryResponse_default_instance_;
class SessionHistoryResponse_SessionHistoryItem;
class SessionHistoryResponse_SessionHistoryItemDefaultTypeInternal;
extern SessionHistoryResponse_SessionHistoryItemDefaultTypeInternal _SessionHistoryResponse_SessionHistoryItem_default_instance_;
class TextEvent;
class TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
class TextEvent_ModelInfo;
class TextEvent_ModelInfoDefaultTypeInternal;
extern TextEvent_ModelInfoDefaultTypeInternal _TextEvent_ModelInfo_default_instance_;
class UnloadCharacters;
class UnloadCharactersDefaultTypeInternal;
extern UnloadCharactersDefaultTypeInternal _UnloadCharacters_default_instance_;
}  // namespace packets
}  // namespace inworld
}  // namespace ai
PROTOBUF_NAMESPACE_OPEN
template<> ::ai::inworld::packets::ActionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ActionEvent>(Arena*);
template<> ::ai::inworld::packets::Actor* Arena::CreateMaybeMessage<::ai::inworld::packets::Actor>(Arena*);
template<> ::ai::inworld::packets::AdditionalPhonemeInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::AdditionalPhonemeInfo>(Arena*);
template<> ::ai::inworld::packets::Agent* Arena::CreateMaybeMessage<::ai::inworld::packets::Agent>(Arena*);
template<> ::ai::inworld::packets::Agent_CharacterAssets* Arena::CreateMaybeMessage<::ai::inworld::packets::Agent_CharacterAssets>(Arena*);
template<> ::ai::inworld::packets::ApplyResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ApplyResponse>(Arena*);
template<> ::ai::inworld::packets::AudioChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::AudioChunk>(Arena*);
template<> ::ai::inworld::packets::AudioSessionStartPayload* Arena::CreateMaybeMessage<::ai::inworld::packets::AudioSessionStartPayload>(Arena*);
template<> ::ai::inworld::packets::CancelResponses* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponses>(Arena*);
template<> ::ai::inworld::packets::CancelResponsesEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponsesEvent>(Arena*);
template<> ::ai::inworld::packets::Continuation* Arena::CreateMaybeMessage<::ai::inworld::packets::Continuation>(Arena*);
template<> ::ai::inworld::packets::Continuation_ContinuationInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::Continuation_ContinuationInfo>(Arena*);
template<> ::ai::inworld::packets::ControlEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ControlEvent>(Arena*);
template<> ::ai::inworld::packets::ConversationEventPayload* Arena::CreateMaybeMessage<::ai::inworld::packets::ConversationEventPayload>(Arena*);
template<> ::ai::inworld::packets::ConversationUpdatePayload* Arena::CreateMaybeMessage<::ai::inworld::packets::ConversationUpdatePayload>(Arena*);
template<> ::ai::inworld::packets::CurrentSceneStatus* Arena::CreateMaybeMessage<::ai::inworld::packets::CurrentSceneStatus>(Arena*);
template<> ::ai::inworld::packets::CustomEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent_Parameter* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent_Parameter>(Arena*);
template<> ::ai::inworld::packets::DataChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::DataChunk>(Arena*);
template<> ::ai::inworld::packets::DebugInfoEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::DebugInfoEvent>(Arena*);
template<> ::ai::inworld::packets::DialogHistory* Arena::CreateMaybeMessage<::ai::inworld::packets::DialogHistory>(Arena*);
template<> ::ai::inworld::packets::DialogHistory_HistoryItem* Arena::CreateMaybeMessage<::ai::inworld::packets::DialogHistory_HistoryItem>(Arena*);
template<> ::ai::inworld::packets::EmotionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::EmotionEvent>(Arena*);
template<> ::ai::inworld::packets::InworldPacket* Arena::CreateMaybeMessage<::ai::inworld::packets::InworldPacket>(Arena*);
template<> ::ai::inworld::packets::LatencyReportEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::LatencyReportEvent>(Arena*);
template<> ::ai::inworld::packets::LoadCharacters* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadCharacters>(Arena*);
template<> ::ai::inworld::packets::LoadCharacters_CharacterName* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadCharacters_CharacterName>(Arena*);
template<> ::ai::inworld::packets::LoadScene* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadScene>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent_Agent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent_Agent>(Arena*);
template<> ::ai::inworld::packets::LoadedCharacters* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadedCharacters>(Arena*);
template<> ::ai::inworld::packets::LoadedScene* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadedScene>(Arena*);
template<> ::ai::inworld::packets::LogsEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::LogsEvent>(Arena*);
template<> ::ai::inworld::packets::LogsEvent_LogDetail* Arena::CreateMaybeMessage<::ai::inworld::packets::LogsEvent_LogDetail>(Arena*);
template<> ::ai::inworld::packets::LogsEvent_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::ai::inworld::packets::LogsEvent_MetadataEntry_DoNotUse>(Arena*);
template<> ::ai::inworld::packets::ModifyExactResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ModifyExactResponse>(Arena*);
template<> ::ai::inworld::packets::MutationEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::MutationEvent>(Arena*);
template<> ::ai::inworld::packets::NarratedAction* Arena::CreateMaybeMessage<::ai::inworld::packets::NarratedAction>(Arena*);
template<> ::ai::inworld::packets::OperationStatusEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::OperationStatusEvent>(Arena*);
template<> ::ai::inworld::packets::PacketId* Arena::CreateMaybeMessage<::ai::inworld::packets::PacketId>(Arena*);
template<> ::ai::inworld::packets::PerceivedLatencyReport* Arena::CreateMaybeMessage<::ai::inworld::packets::PerceivedLatencyReport>(Arena*);
template<> ::ai::inworld::packets::PingPongReport* Arena::CreateMaybeMessage<::ai::inworld::packets::PingPongReport>(Arena*);
template<> ::ai::inworld::packets::RegenerateResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::RegenerateResponse>(Arena*);
template<> ::ai::inworld::packets::RelationInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo>(Arena*);
template<> ::ai::inworld::packets::RelationInfo_RelationAttributes* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(Arena*);
template<> ::ai::inworld::packets::Relations* Arena::CreateMaybeMessage<::ai::inworld::packets::Relations>(Arena*);
template<> ::ai::inworld::packets::Relations_Relation* Arena::CreateMaybeMessage<::ai::inworld::packets::Relations_Relation>(Arena*);
template<> ::ai::inworld::packets::Routing* Arena::CreateMaybeMessage<::ai::inworld::packets::Routing>(Arena*);
template<> ::ai::inworld::packets::SessionConfigurationPayload* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionConfigurationPayload>(Arena*);
template<> ::ai::inworld::packets::SessionControlEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionControlEvent>(Arena*);
template<> ::ai::inworld::packets::SessionControlResponseEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionControlResponseEvent>(Arena*);
template<> ::ai::inworld::packets::SessionHistoryRequest* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionHistoryRequest>(Arena*);
template<> ::ai::inworld::packets::SessionHistoryResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionHistoryResponse>(Arena*);
template<> ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* Arena::CreateMaybeMessage<::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem>(Arena*);
template<> ::ai::inworld::packets::TextEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent>(Arena*);
template<> ::ai::inworld::packets::TextEvent_ModelInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent_ModelInfo>(Arena*);
template<> ::ai::inworld::packets::UnloadCharacters* Arena::CreateMaybeMessage<::ai::inworld::packets::UnloadCharacters>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ai {
namespace inworld {
namespace packets {

enum Actor_Type : int {
  Actor_Type_UNKNOWN = 0,
  Actor_Type_PLAYER = 1,
  Actor_Type_AGENT = 2,
  Actor_Type_WORLD = 3,
  Actor_Type_Actor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Actor_Type_Actor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Actor_Type_IsValid(int value);
constexpr Actor_Type Actor_Type_Type_MIN = Actor_Type_UNKNOWN;
constexpr Actor_Type Actor_Type_Type_MAX = Actor_Type_WORLD;
constexpr int Actor_Type_Type_ARRAYSIZE = Actor_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Actor_Type_descriptor();
template<typename T>
inline const std::string& Actor_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Actor_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Actor_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Actor_Type_descriptor(), enum_t_value);
}
inline bool Actor_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Actor_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Actor_Type>(
    Actor_Type_descriptor(), name, value);
}
enum TextEvent_SourceType : int {
  TextEvent_SourceType_UNKNOWN = 0,
  TextEvent_SourceType_SPEECH_TO_TEXT = 1,
  TextEvent_SourceType_TYPED_IN = 2,
  TextEvent_SourceType_GENERATED = 3,
  TextEvent_SourceType_FILLER = 4,
  TextEvent_SourceType_TextEvent_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TextEvent_SourceType_TextEvent_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TextEvent_SourceType_IsValid(int value);
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MIN = TextEvent_SourceType_UNKNOWN;
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MAX = TextEvent_SourceType_FILLER;
constexpr int TextEvent_SourceType_SourceType_ARRAYSIZE = TextEvent_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextEvent_SourceType_descriptor();
template<typename T>
inline const std::string& TextEvent_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextEvent_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextEvent_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextEvent_SourceType_descriptor(), enum_t_value);
}
inline bool TextEvent_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextEvent_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextEvent_SourceType>(
    TextEvent_SourceType_descriptor(), name, value);
}
enum ControlEvent_Action : int {
  ControlEvent_Action_UNKNOWN = 0,
  ControlEvent_Action_AUDIO_SESSION_START = 1,
  ControlEvent_Action_AUDIO_SESSION_END = 2,
  ControlEvent_Action_INTERACTION_END = 3,
  ControlEvent_Action_TTS_PLAYBACK_START = 4,
  ControlEvent_Action_TTS_PLAYBACK_END = 5,
  ControlEvent_Action_TTS_PLAYBACK_MUTE = 6,
  ControlEvent_Action_TTS_PLAYBACK_UNMUTE = 7,
  ControlEvent_Action_WARNING PROTOBUF_DEPRECATED_ENUM = 8,
  ControlEvent_Action_SESSION_END = 9,
  ControlEvent_Action_CONVERSATION_START PROTOBUF_DEPRECATED_ENUM = 10,
  ControlEvent_Action_CONVERSATION_UPDATE = 12,
  ControlEvent_Action_CONVERSATION_STARTED PROTOBUF_DEPRECATED_ENUM = 13,
  ControlEvent_Action_CONVERSATION_EVENT = 14,
  ControlEvent_Action_CURRENT_SCENE_STATUS = 15,
  ControlEvent_Action_SESSION_CONFIGURATION = 16,
  ControlEvent_Action_ControlEvent_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlEvent_Action_ControlEvent_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlEvent_Action_IsValid(int value);
constexpr ControlEvent_Action ControlEvent_Action_Action_MIN = ControlEvent_Action_UNKNOWN;
constexpr ControlEvent_Action ControlEvent_Action_Action_MAX = ControlEvent_Action_SESSION_CONFIGURATION;
constexpr int ControlEvent_Action_Action_ARRAYSIZE = ControlEvent_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlEvent_Action_descriptor();
template<typename T>
inline const std::string& ControlEvent_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlEvent_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlEvent_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlEvent_Action_descriptor(), enum_t_value);
}
inline bool ControlEvent_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlEvent_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlEvent_Action>(
    ControlEvent_Action_descriptor(), name, value);
}
enum AudioSessionStartPayload_MicrophoneMode : int {
  AudioSessionStartPayload_MicrophoneMode_UNSPECIFIED = 0,
  AudioSessionStartPayload_MicrophoneMode_OPEN_MIC = 1,
  AudioSessionStartPayload_MicrophoneMode_EXPECT_AUDIO_END = 2,
  AudioSessionStartPayload_MicrophoneMode_AudioSessionStartPayload_MicrophoneMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioSessionStartPayload_MicrophoneMode_AudioSessionStartPayload_MicrophoneMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioSessionStartPayload_MicrophoneMode_IsValid(int value);
constexpr AudioSessionStartPayload_MicrophoneMode AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_MIN = AudioSessionStartPayload_MicrophoneMode_UNSPECIFIED;
constexpr AudioSessionStartPayload_MicrophoneMode AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_MAX = AudioSessionStartPayload_MicrophoneMode_EXPECT_AUDIO_END;
constexpr int AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_ARRAYSIZE = AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioSessionStartPayload_MicrophoneMode_descriptor();
template<typename T>
inline const std::string& AudioSessionStartPayload_MicrophoneMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioSessionStartPayload_MicrophoneMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioSessionStartPayload_MicrophoneMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioSessionStartPayload_MicrophoneMode_descriptor(), enum_t_value);
}
inline bool AudioSessionStartPayload_MicrophoneMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioSessionStartPayload_MicrophoneMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioSessionStartPayload_MicrophoneMode>(
    AudioSessionStartPayload_MicrophoneMode_descriptor(), name, value);
}
enum AudioSessionStartPayload_UnderstandingMode : int {
  AudioSessionStartPayload_UnderstandingMode_UNSPECIFIED_UNDERSTANDING_MODE = 0,
  AudioSessionStartPayload_UnderstandingMode_FULL = 1,
  AudioSessionStartPayload_UnderstandingMode_SPEECH_RECOGNITION_ONLY = 2,
  AudioSessionStartPayload_UnderstandingMode_AudioSessionStartPayload_UnderstandingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioSessionStartPayload_UnderstandingMode_AudioSessionStartPayload_UnderstandingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioSessionStartPayload_UnderstandingMode_IsValid(int value);
constexpr AudioSessionStartPayload_UnderstandingMode AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_MIN = AudioSessionStartPayload_UnderstandingMode_UNSPECIFIED_UNDERSTANDING_MODE;
constexpr AudioSessionStartPayload_UnderstandingMode AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_MAX = AudioSessionStartPayload_UnderstandingMode_SPEECH_RECOGNITION_ONLY;
constexpr int AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_ARRAYSIZE = AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioSessionStartPayload_UnderstandingMode_descriptor();
template<typename T>
inline const std::string& AudioSessionStartPayload_UnderstandingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioSessionStartPayload_UnderstandingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioSessionStartPayload_UnderstandingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioSessionStartPayload_UnderstandingMode_descriptor(), enum_t_value);
}
inline bool AudioSessionStartPayload_UnderstandingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioSessionStartPayload_UnderstandingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioSessionStartPayload_UnderstandingMode>(
    AudioSessionStartPayload_UnderstandingMode_descriptor(), name, value);
}
enum CustomEvent_Type : int {
  CustomEvent_Type_UNSPECIFIED = 0,
  CustomEvent_Type_TRIGGER = 1,
  CustomEvent_Type_TASK = 2,
  CustomEvent_Type_CustomEvent_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CustomEvent_Type_CustomEvent_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CustomEvent_Type_IsValid(int value);
constexpr CustomEvent_Type CustomEvent_Type_Type_MIN = CustomEvent_Type_UNSPECIFIED;
constexpr CustomEvent_Type CustomEvent_Type_Type_MAX = CustomEvent_Type_TASK;
constexpr int CustomEvent_Type_Type_ARRAYSIZE = CustomEvent_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CustomEvent_Type_descriptor();
template<typename T>
inline const std::string& CustomEvent_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomEvent_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomEvent_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CustomEvent_Type_descriptor(), enum_t_value);
}
inline bool CustomEvent_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomEvent_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustomEvent_Type>(
    CustomEvent_Type_descriptor(), name, value);
}
enum EmotionEvent_SpaffCode : int {
  EmotionEvent_SpaffCode_NEUTRAL = 0,
  EmotionEvent_SpaffCode_DISGUST = 1,
  EmotionEvent_SpaffCode_CONTEMPT = 2,
  EmotionEvent_SpaffCode_BELLIGERENCE = 3,
  EmotionEvent_SpaffCode_DOMINEERING = 4,
  EmotionEvent_SpaffCode_CRITICISM = 5,
  EmotionEvent_SpaffCode_ANGER = 6,
  EmotionEvent_SpaffCode_TENSION = 7,
  EmotionEvent_SpaffCode_TENSE_HUMOR = 8,
  EmotionEvent_SpaffCode_DEFENSIVENESS = 9,
  EmotionEvent_SpaffCode_WHINING = 10,
  EmotionEvent_SpaffCode_SADNESS = 11,
  EmotionEvent_SpaffCode_STONEWALLING = 12,
  EmotionEvent_SpaffCode_INTEREST = 13,
  EmotionEvent_SpaffCode_VALIDATION = 14,
  EmotionEvent_SpaffCode_AFFECTION = 15,
  EmotionEvent_SpaffCode_HUMOR = 16,
  EmotionEvent_SpaffCode_SURPRISE = 17,
  EmotionEvent_SpaffCode_JOY = 18,
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EmotionEvent_SpaffCode_IsValid(int value);
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MIN = EmotionEvent_SpaffCode_NEUTRAL;
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MAX = EmotionEvent_SpaffCode_JOY;
constexpr int EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE = EmotionEvent_SpaffCode_SpaffCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_SpaffCode_descriptor();
template<typename T>
inline const std::string& EmotionEvent_SpaffCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_SpaffCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_SpaffCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_SpaffCode_descriptor(), enum_t_value);
}
inline bool EmotionEvent_SpaffCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_SpaffCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_SpaffCode>(
    EmotionEvent_SpaffCode_descriptor(), name, value);
}
enum EmotionEvent_Strength : int {
  EmotionEvent_Strength_UNSPECIFIED = 0,
  EmotionEvent_Strength_WEAK = 1,
  EmotionEvent_Strength_STRONG = 2,
  EmotionEvent_Strength_NORMAL = 3,
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EmotionEvent_Strength_IsValid(int value);
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MIN = EmotionEvent_Strength_UNSPECIFIED;
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MAX = EmotionEvent_Strength_NORMAL;
constexpr int EmotionEvent_Strength_Strength_ARRAYSIZE = EmotionEvent_Strength_Strength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_Strength_descriptor();
template<typename T>
inline const std::string& EmotionEvent_Strength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_Strength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_Strength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_Strength_descriptor(), enum_t_value);
}
inline bool EmotionEvent_Strength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_Strength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_Strength>(
    EmotionEvent_Strength_descriptor(), name, value);
}
enum DataChunk_DataType : int {
  DataChunk_DataType_UNSPECIFIED = 0,
  DataChunk_DataType_AUDIO = 1,
  DataChunk_DataType_SILENCE PROTOBUF_DEPRECATED_ENUM = 3,
  DataChunk_DataType_STATE = 4,
  DataChunk_DataType_NVIDIA_A2F_ANIMATION = 5,
  DataChunk_DataType_NVIDIA_A2F_ANIMATION_HEADER = 6,
  DataChunk_DataType_INSPECT = 7,
  DataChunk_DataType_DataChunk_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataChunk_DataType_DataChunk_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataChunk_DataType_IsValid(int value);
constexpr DataChunk_DataType DataChunk_DataType_DataType_MIN = DataChunk_DataType_UNSPECIFIED;
constexpr DataChunk_DataType DataChunk_DataType_DataType_MAX = DataChunk_DataType_INSPECT;
constexpr int DataChunk_DataType_DataType_ARRAYSIZE = DataChunk_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_DataType_descriptor();
template<typename T>
inline const std::string& DataChunk_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_DataType_descriptor(), enum_t_value);
}
inline bool DataChunk_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_DataType>(
    DataChunk_DataType_descriptor(), name, value);
}
enum DataChunk_AudioFormat : int {
  DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT = 0,
  DataChunk_AudioFormat_AUDIO_MP3 = 1,
  DataChunk_AudioFormat_AUDIO_PCM_16000 = 2,
  DataChunk_AudioFormat_AUDIO_PCM_22050 = 3,
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataChunk_AudioFormat_IsValid(int value);
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MIN = DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT;
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MAX = DataChunk_AudioFormat_AUDIO_PCM_22050;
constexpr int DataChunk_AudioFormat_AudioFormat_ARRAYSIZE = DataChunk_AudioFormat_AudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_AudioFormat_descriptor();
template<typename T>
inline const std::string& DataChunk_AudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_AudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_AudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_AudioFormat_descriptor(), enum_t_value);
}
inline bool DataChunk_AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_AudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_AudioFormat>(
    DataChunk_AudioFormat_descriptor(), name, value);
}
enum PingPongReport_Type : int {
  PingPongReport_Type_UNSPECIFIED = 0,
  PingPongReport_Type_PING = 1,
  PingPongReport_Type_PONG = 2,
  PingPongReport_Type_PingPongReport_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PingPongReport_Type_PingPongReport_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PingPongReport_Type_IsValid(int value);
constexpr PingPongReport_Type PingPongReport_Type_Type_MIN = PingPongReport_Type_UNSPECIFIED;
constexpr PingPongReport_Type PingPongReport_Type_Type_MAX = PingPongReport_Type_PONG;
constexpr int PingPongReport_Type_Type_ARRAYSIZE = PingPongReport_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PingPongReport_Type_descriptor();
template<typename T>
inline const std::string& PingPongReport_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PingPongReport_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PingPongReport_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PingPongReport_Type_descriptor(), enum_t_value);
}
inline bool PingPongReport_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PingPongReport_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PingPongReport_Type>(
    PingPongReport_Type_descriptor(), name, value);
}
enum PerceivedLatencyReport_Precision : int {
  PerceivedLatencyReport_Precision_UNSPECIFIED = 0,
  PerceivedLatencyReport_Precision_FINE = 1,
  PerceivedLatencyReport_Precision_ESTIMATED = 2,
  PerceivedLatencyReport_Precision_PUSH_TO_TALK = 3,
  PerceivedLatencyReport_Precision_NON_SPEECH = 4,
  PerceivedLatencyReport_Precision_PerceivedLatencyReport_Precision_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PerceivedLatencyReport_Precision_PerceivedLatencyReport_Precision_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PerceivedLatencyReport_Precision_IsValid(int value);
constexpr PerceivedLatencyReport_Precision PerceivedLatencyReport_Precision_Precision_MIN = PerceivedLatencyReport_Precision_UNSPECIFIED;
constexpr PerceivedLatencyReport_Precision PerceivedLatencyReport_Precision_Precision_MAX = PerceivedLatencyReport_Precision_NON_SPEECH;
constexpr int PerceivedLatencyReport_Precision_Precision_ARRAYSIZE = PerceivedLatencyReport_Precision_Precision_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceivedLatencyReport_Precision_descriptor();
template<typename T>
inline const std::string& PerceivedLatencyReport_Precision_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerceivedLatencyReport_Precision>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerceivedLatencyReport_Precision_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerceivedLatencyReport_Precision_descriptor(), enum_t_value);
}
inline bool PerceivedLatencyReport_Precision_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerceivedLatencyReport_Precision* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerceivedLatencyReport_Precision>(
    PerceivedLatencyReport_Precision_descriptor(), name, value);
}
enum LogsEvent_LogLevel : int {
  LogsEvent_LogLevel_UNSPECIFIED = 0,
  LogsEvent_LogLevel_WARNING = 1,
  LogsEvent_LogLevel_INFO = 2,
  LogsEvent_LogLevel_DEBUG = 3,
  LogsEvent_LogLevel_INTERNAL = 4,
  LogsEvent_LogLevel_LogsEvent_LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogsEvent_LogLevel_LogsEvent_LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogsEvent_LogLevel_IsValid(int value);
constexpr LogsEvent_LogLevel LogsEvent_LogLevel_LogLevel_MIN = LogsEvent_LogLevel_UNSPECIFIED;
constexpr LogsEvent_LogLevel LogsEvent_LogLevel_LogLevel_MAX = LogsEvent_LogLevel_INTERNAL;
constexpr int LogsEvent_LogLevel_LogLevel_ARRAYSIZE = LogsEvent_LogLevel_LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogsEvent_LogLevel_descriptor();
template<typename T>
inline const std::string& LogsEvent_LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogsEvent_LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogsEvent_LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogsEvent_LogLevel_descriptor(), enum_t_value);
}
inline bool LogsEvent_LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogsEvent_LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogsEvent_LogLevel>(
    LogsEvent_LogLevel_descriptor(), name, value);
}
enum ApplyResponse_ApplyResponseType : int {
  ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_DEFAULT = 0,
  ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_COMMIT = 1,
  ApplyResponse_ApplyResponseType_ApplyResponse_ApplyResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ApplyResponse_ApplyResponseType_ApplyResponse_ApplyResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ApplyResponse_ApplyResponseType_IsValid(int value);
constexpr ApplyResponse_ApplyResponseType ApplyResponse_ApplyResponseType_ApplyResponseType_MIN = ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_DEFAULT;
constexpr ApplyResponse_ApplyResponseType ApplyResponse_ApplyResponseType_ApplyResponseType_MAX = ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_COMMIT;
constexpr int ApplyResponse_ApplyResponseType_ApplyResponseType_ARRAYSIZE = ApplyResponse_ApplyResponseType_ApplyResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApplyResponse_ApplyResponseType_descriptor();
template<typename T>
inline const std::string& ApplyResponse_ApplyResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApplyResponse_ApplyResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApplyResponse_ApplyResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApplyResponse_ApplyResponseType_descriptor(), enum_t_value);
}
inline bool ApplyResponse_ApplyResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplyResponse_ApplyResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApplyResponse_ApplyResponseType>(
    ApplyResponse_ApplyResponseType_descriptor(), name, value);
}
enum Continuation_ContinuationType : int {
  Continuation_ContinuationType_CONTINUATION_TYPE_UNKNOWN = 0,
  Continuation_ContinuationType_CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE = 1,
  Continuation_ContinuationType_CONTINUATION_TYPE_DIALOG_HISTORY = 2,
  Continuation_ContinuationType_Continuation_ContinuationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Continuation_ContinuationType_Continuation_ContinuationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Continuation_ContinuationType_IsValid(int value);
constexpr Continuation_ContinuationType Continuation_ContinuationType_ContinuationType_MIN = Continuation_ContinuationType_CONTINUATION_TYPE_UNKNOWN;
constexpr Continuation_ContinuationType Continuation_ContinuationType_ContinuationType_MAX = Continuation_ContinuationType_CONTINUATION_TYPE_DIALOG_HISTORY;
constexpr int Continuation_ContinuationType_ContinuationType_ARRAYSIZE = Continuation_ContinuationType_ContinuationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Continuation_ContinuationType_descriptor();
template<typename T>
inline const std::string& Continuation_ContinuationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Continuation_ContinuationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Continuation_ContinuationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Continuation_ContinuationType_descriptor(), enum_t_value);
}
inline bool Continuation_ContinuationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Continuation_ContinuationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Continuation_ContinuationType>(
    Continuation_ContinuationType_descriptor(), name, value);
}
enum ConversationEventPayload_ConversationEventType : int {
  ConversationEventPayload_ConversationEventType_UNKNOWN = 0,
  ConversationEventPayload_ConversationEventType_STARTED = 1,
  ConversationEventPayload_ConversationEventType_UPDATED = 2,
  ConversationEventPayload_ConversationEventType_EVICTED = 3,
  ConversationEventPayload_ConversationEventType_ConversationEventPayload_ConversationEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConversationEventPayload_ConversationEventType_ConversationEventPayload_ConversationEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConversationEventPayload_ConversationEventType_IsValid(int value);
constexpr ConversationEventPayload_ConversationEventType ConversationEventPayload_ConversationEventType_ConversationEventType_MIN = ConversationEventPayload_ConversationEventType_UNKNOWN;
constexpr ConversationEventPayload_ConversationEventType ConversationEventPayload_ConversationEventType_ConversationEventType_MAX = ConversationEventPayload_ConversationEventType_EVICTED;
constexpr int ConversationEventPayload_ConversationEventType_ConversationEventType_ARRAYSIZE = ConversationEventPayload_ConversationEventType_ConversationEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConversationEventPayload_ConversationEventType_descriptor();
template<typename T>
inline const std::string& ConversationEventPayload_ConversationEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConversationEventPayload_ConversationEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConversationEventPayload_ConversationEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConversationEventPayload_ConversationEventType_descriptor(), enum_t_value);
}
inline bool ConversationEventPayload_ConversationEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConversationEventPayload_ConversationEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConversationEventPayload_ConversationEventType>(
    ConversationEventPayload_ConversationEventType_descriptor(), name, value);
}
enum Playback : int {
  UNSPECIFIED = 0,
  INTERACTION = 1,
  INTERACTION_END = 2,
  UTTERANCE = 3,
  Playback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Playback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Playback_IsValid(int value);
constexpr Playback Playback_MIN = UNSPECIFIED;
constexpr Playback Playback_MAX = UTTERANCE;
constexpr int Playback_ARRAYSIZE = Playback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Playback_descriptor();
template<typename T>
inline const std::string& Playback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Playback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Playback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Playback_descriptor(), enum_t_value);
}
inline bool Playback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Playback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Playback>(
    Playback_descriptor(), name, value);
}
// ===================================================================

class Actor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Actor) */ {
 public:
  inline Actor() : Actor(nullptr) {}
  virtual ~Actor();

  Actor(const Actor& from);
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actor& operator=(Actor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Actor& default_instance();

  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }
  inline void Swap(Actor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Actor* New() const final {
    return CreateMaybeMessage<Actor>(nullptr);
  }

  Actor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Actor& from);
  void MergeFrom(const Actor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Actor";
  }
  protected:
  explicit Actor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Actor_Type Type;
  static constexpr Type UNKNOWN =
    Actor_Type_UNKNOWN;
  static constexpr Type PLAYER =
    Actor_Type_PLAYER;
  static constexpr Type AGENT =
    Actor_Type_AGENT;
  static constexpr Type WORLD =
    Actor_Type_WORLD;
  static inline bool Type_IsValid(int value) {
    return Actor_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Actor_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Actor_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Actor_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Actor_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Actor_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Actor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Actor.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::Actor_Type type() const;
  void set_type(::ai::inworld::packets::Actor_Type value);
  private:
  ::ai::inworld::packets::Actor_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::Actor_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Actor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Routing PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  virtual ~Routing();

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Routing& default_instance();

  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Routing* New() const final {
    return CreateMaybeMessage<Routing>(nullptr);
  }

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Routing& from);
  void MergeFrom(const Routing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 3,
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.Actor targets = 3;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::ai::inworld::packets::Actor* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
      mutable_targets();
  private:
  const ::ai::inworld::packets::Actor& _internal_targets(int index) const;
  ::ai::inworld::packets::Actor* _internal_add_targets();
  public:
  const ::ai::inworld::packets::Actor& targets(int index) const;
  ::ai::inworld::packets::Actor* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
      targets() const;

  // .ai.inworld.packets.Actor source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::ai::inworld::packets::Actor& source() const;
  ::ai::inworld::packets::Actor* release_source();
  ::ai::inworld::packets::Actor* mutable_source();
  void set_allocated_source(::ai::inworld::packets::Actor* source);
  private:
  const ::ai::inworld::packets::Actor& _internal_source() const;
  ::ai::inworld::packets::Actor* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::ai::inworld::packets::Actor* source);
  ::ai::inworld::packets::Actor* unsafe_arena_release_source();

  // .ai.inworld.packets.Actor target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::ai::inworld::packets::Actor& target() const;
  ::ai::inworld::packets::Actor* release_target();
  ::ai::inworld::packets::Actor* mutable_target();
  void set_allocated_target(::ai::inworld::packets::Actor* target);
  private:
  const ::ai::inworld::packets::Actor& _internal_target() const;
  ::ai::inworld::packets::Actor* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::ai::inworld::packets::Actor* target);
  ::ai::inworld::packets::Actor* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Routing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor > targets_;
  ::ai::inworld::packets::Actor* source_;
  ::ai::inworld::packets::Actor* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class PacketId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PacketId) */ {
 public:
  inline PacketId() : PacketId(nullptr) {}
  virtual ~PacketId();

  PacketId(const PacketId& from);
  PacketId(PacketId&& from) noexcept
    : PacketId() {
    *this = ::std::move(from);
  }

  inline PacketId& operator=(const PacketId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketId& operator=(PacketId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PacketId& default_instance();

  static inline const PacketId* internal_default_instance() {
    return reinterpret_cast<const PacketId*>(
               &_PacketId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketId& a, PacketId& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketId* New() const final {
    return CreateMaybeMessage<PacketId>(nullptr);
  }

  PacketId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PacketId& from);
  void MergeFrom(const PacketId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PacketId";
  }
  protected:
  explicit PacketId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 3,
    kCorrelationIdFieldNumber = 4,
    kConversationIdFieldNumber = 5,
  };
  // string packet_id = 1;
  void clear_packet_id();
  const std::string& packet_id() const;
  void set_packet_id(const std::string& value);
  void set_packet_id(std::string&& value);
  void set_packet_id(const char* value);
  void set_packet_id(const char* value, size_t size);
  std::string* mutable_packet_id();
  std::string* release_packet_id();
  void set_allocated_packet_id(std::string* packet_id);
  private:
  const std::string& _internal_packet_id() const;
  void _internal_set_packet_id(const std::string& value);
  std::string* _internal_mutable_packet_id();
  public:

  // string utterance_id = 2;
  void clear_utterance_id();
  const std::string& utterance_id() const;
  void set_utterance_id(const std::string& value);
  void set_utterance_id(std::string&& value);
  void set_utterance_id(const char* value);
  void set_utterance_id(const char* value, size_t size);
  std::string* mutable_utterance_id();
  std::string* release_utterance_id();
  void set_allocated_utterance_id(std::string* utterance_id);
  private:
  const std::string& _internal_utterance_id() const;
  void _internal_set_utterance_id(const std::string& value);
  std::string* _internal_mutable_utterance_id();
  public:

  // string interaction_id = 3;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string correlation_id = 4;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  void set_correlation_id(const std::string& value);
  void set_correlation_id(std::string&& value);
  void set_correlation_id(const char* value);
  void set_correlation_id(const char* value, size_t size);
  std::string* mutable_correlation_id();
  std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // string conversation_id = 5;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  void set_conversation_id(const std::string& value);
  void set_conversation_id(std::string&& value);
  void set_conversation_id(const char* value);
  void set_conversation_id(const char* value, size_t size);
  std::string* mutable_conversation_id();
  std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PacketId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class InworldPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.InworldPacket) */ {
 public:
  inline InworldPacket() : InworldPacket(nullptr) {}
  virtual ~InworldPacket();

  InworldPacket(const InworldPacket& from);
  InworldPacket(InworldPacket&& from) noexcept
    : InworldPacket() {
    *this = ::std::move(from);
  }

  inline InworldPacket& operator=(const InworldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InworldPacket& operator=(InworldPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InworldPacket& default_instance();

  enum PacketCase {
    kText = 2,
    kControl = 3,
    kAudioChunk = 4,
    kCustom = 8,
    kCancelResponses = 10,
    kEmotion = 11,
    kDataChunk = 12,
    kAction = 13,
    kMutation = 15,
    kLoadSceneOutput = 16,
    kDebugInfo = 18,
    kSessionControl = 19,
    kSessionControlResponse = 20,
    kLatencyReport = 22,
    kOperationStatus = 23,
    kEntitiesItemsOperation = 24,
    kLog = 25,
    PACKET_NOT_SET = 0,
  };

  static inline const InworldPacket* internal_default_instance() {
    return reinterpret_cast<const InworldPacket*>(
               &_InworldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InworldPacket& a, InworldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InworldPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InworldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InworldPacket* New() const final {
    return CreateMaybeMessage<InworldPacket>(nullptr);
  }

  InworldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InworldPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InworldPacket& from);
  void MergeFrom(const InworldPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InworldPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.InworldPacket";
  }
  protected:
  explicit InworldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kRoutingFieldNumber = 6,
    kPacketIdFieldNumber = 9,
    kTextFieldNumber = 2,
    kControlFieldNumber = 3,
    kAudioChunkFieldNumber = 4,
    kCustomFieldNumber = 8,
    kCancelResponsesFieldNumber = 10,
    kEmotionFieldNumber = 11,
    kDataChunkFieldNumber = 12,
    kActionFieldNumber = 13,
    kMutationFieldNumber = 15,
    kLoadSceneOutputFieldNumber = 16,
    kDebugInfoFieldNumber = 18,
    kSessionControlFieldNumber = 19,
    kSessionControlResponseFieldNumber = 20,
    kLatencyReportFieldNumber = 22,
    kOperationStatusFieldNumber = 23,
    kEntitiesItemsOperationFieldNumber = 24,
    kLogFieldNumber = 25,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .ai.inworld.packets.Routing routing = 6;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::ai::inworld::packets::Routing& routing() const;
  ::ai::inworld::packets::Routing* release_routing();
  ::ai::inworld::packets::Routing* mutable_routing();
  void set_allocated_routing(::ai::inworld::packets::Routing* routing);
  private:
  const ::ai::inworld::packets::Routing& _internal_routing() const;
  ::ai::inworld::packets::Routing* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::ai::inworld::packets::Routing* routing);
  ::ai::inworld::packets::Routing* unsafe_arena_release_routing();

  // .ai.inworld.packets.PacketId packet_id = 9;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // .ai.inworld.packets.TextEvent text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::ai::inworld::packets::TextEvent& text() const;
  ::ai::inworld::packets::TextEvent* release_text();
  ::ai::inworld::packets::TextEvent* mutable_text();
  void set_allocated_text(::ai::inworld::packets::TextEvent* text);
  private:
  const ::ai::inworld::packets::TextEvent& _internal_text() const;
  ::ai::inworld::packets::TextEvent* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::ai::inworld::packets::TextEvent* text);
  ::ai::inworld::packets::TextEvent* unsafe_arena_release_text();

  // .ai.inworld.packets.ControlEvent control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::ai::inworld::packets::ControlEvent& control() const;
  ::ai::inworld::packets::ControlEvent* release_control();
  ::ai::inworld::packets::ControlEvent* mutable_control();
  void set_allocated_control(::ai::inworld::packets::ControlEvent* control);
  private:
  const ::ai::inworld::packets::ControlEvent& _internal_control() const;
  ::ai::inworld::packets::ControlEvent* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::ai::inworld::packets::ControlEvent* control);
  ::ai::inworld::packets::ControlEvent* unsafe_arena_release_control();

  // .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  PROTOBUF_DEPRECATED void clear_audio_chunk();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::AudioChunk& audio_chunk() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* release_audio_chunk();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* mutable_audio_chunk();
  PROTOBUF_DEPRECATED void set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk);
  private:
  const ::ai::inworld::packets::AudioChunk& _internal_audio_chunk() const;
  ::ai::inworld::packets::AudioChunk* _internal_mutable_audio_chunk();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_audio_chunk(
      ::ai::inworld::packets::AudioChunk* audio_chunk);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* unsafe_arena_release_audio_chunk();

  // .ai.inworld.packets.CustomEvent custom = 8;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::ai::inworld::packets::CustomEvent& custom() const;
  ::ai::inworld::packets::CustomEvent* release_custom();
  ::ai::inworld::packets::CustomEvent* mutable_custom();
  void set_allocated_custom(::ai::inworld::packets::CustomEvent* custom);
  private:
  const ::ai::inworld::packets::CustomEvent& _internal_custom() const;
  ::ai::inworld::packets::CustomEvent* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::ai::inworld::packets::CustomEvent* custom);
  ::ai::inworld::packets::CustomEvent* unsafe_arena_release_custom();

  // .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_cancelresponses() const;
  private:
  bool _internal_has_cancelresponses() const;
  public:
  PROTOBUF_DEPRECATED void clear_cancelresponses();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::CancelResponsesEvent& cancelresponses() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* release_cancelresponses();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* mutable_cancelresponses();
  PROTOBUF_DEPRECATED void set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  private:
  const ::ai::inworld::packets::CancelResponsesEvent& _internal_cancelresponses() const;
  ::ai::inworld::packets::CancelResponsesEvent* _internal_mutable_cancelresponses();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_cancelresponses(
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* unsafe_arena_release_cancelresponses();

  // .ai.inworld.packets.EmotionEvent emotion = 11;
  bool has_emotion() const;
  private:
  bool _internal_has_emotion() const;
  public:
  void clear_emotion();
  const ::ai::inworld::packets::EmotionEvent& emotion() const;
  ::ai::inworld::packets::EmotionEvent* release_emotion();
  ::ai::inworld::packets::EmotionEvent* mutable_emotion();
  void set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion);
  private:
  const ::ai::inworld::packets::EmotionEvent& _internal_emotion() const;
  ::ai::inworld::packets::EmotionEvent* _internal_mutable_emotion();
  public:
  void unsafe_arena_set_allocated_emotion(
      ::ai::inworld::packets::EmotionEvent* emotion);
  ::ai::inworld::packets::EmotionEvent* unsafe_arena_release_emotion();

  // .ai.inworld.packets.DataChunk data_chunk = 12;
  bool has_data_chunk() const;
  private:
  bool _internal_has_data_chunk() const;
  public:
  void clear_data_chunk();
  const ::ai::inworld::packets::DataChunk& data_chunk() const;
  ::ai::inworld::packets::DataChunk* release_data_chunk();
  ::ai::inworld::packets::DataChunk* mutable_data_chunk();
  void set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk);
  private:
  const ::ai::inworld::packets::DataChunk& _internal_data_chunk() const;
  ::ai::inworld::packets::DataChunk* _internal_mutable_data_chunk();
  public:
  void unsafe_arena_set_allocated_data_chunk(
      ::ai::inworld::packets::DataChunk* data_chunk);
  ::ai::inworld::packets::DataChunk* unsafe_arena_release_data_chunk();

  // .ai.inworld.packets.ActionEvent action = 13;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::ai::inworld::packets::ActionEvent& action() const;
  ::ai::inworld::packets::ActionEvent* release_action();
  ::ai::inworld::packets::ActionEvent* mutable_action();
  void set_allocated_action(::ai::inworld::packets::ActionEvent* action);
  private:
  const ::ai::inworld::packets::ActionEvent& _internal_action() const;
  ::ai::inworld::packets::ActionEvent* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::ai::inworld::packets::ActionEvent* action);
  ::ai::inworld::packets::ActionEvent* unsafe_arena_release_action();

  // .ai.inworld.packets.MutationEvent mutation = 15;
  bool has_mutation() const;
  private:
  bool _internal_has_mutation() const;
  public:
  void clear_mutation();
  const ::ai::inworld::packets::MutationEvent& mutation() const;
  ::ai::inworld::packets::MutationEvent* release_mutation();
  ::ai::inworld::packets::MutationEvent* mutable_mutation();
  void set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation);
  private:
  const ::ai::inworld::packets::MutationEvent& _internal_mutation() const;
  ::ai::inworld::packets::MutationEvent* _internal_mutable_mutation();
  public:
  void unsafe_arena_set_allocated_mutation(
      ::ai::inworld::packets::MutationEvent* mutation);
  ::ai::inworld::packets::MutationEvent* unsafe_arena_release_mutation();

  // .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_load_scene_output() const;
  private:
  bool _internal_has_load_scene_output() const;
  public:
  PROTOBUF_DEPRECATED void clear_load_scene_output();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::LoadSceneOutputEvent& load_scene_output() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadSceneOutputEvent* release_load_scene_output();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadSceneOutputEvent* mutable_load_scene_output();
  PROTOBUF_DEPRECATED void set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent& _internal_load_scene_output() const;
  ::ai::inworld::packets::LoadSceneOutputEvent* _internal_mutable_load_scene_output();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_load_scene_output(
      ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadSceneOutputEvent* unsafe_arena_release_load_scene_output();

  // .ai.inworld.packets.DebugInfoEvent debug_info = 18;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::ai::inworld::packets::DebugInfoEvent& debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* release_debug_info();
  ::ai::inworld::packets::DebugInfoEvent* mutable_debug_info();
  void set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info);
  private:
  const ::ai::inworld::packets::DebugInfoEvent& _internal_debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::ai::inworld::packets::DebugInfoEvent* debug_info);
  ::ai::inworld::packets::DebugInfoEvent* unsafe_arena_release_debug_info();

  // .ai.inworld.packets.SessionControlEvent session_control = 19;
  bool has_session_control() const;
  private:
  bool _internal_has_session_control() const;
  public:
  void clear_session_control();
  const ::ai::inworld::packets::SessionControlEvent& session_control() const;
  ::ai::inworld::packets::SessionControlEvent* release_session_control();
  ::ai::inworld::packets::SessionControlEvent* mutable_session_control();
  void set_allocated_session_control(::ai::inworld::packets::SessionControlEvent* session_control);
  private:
  const ::ai::inworld::packets::SessionControlEvent& _internal_session_control() const;
  ::ai::inworld::packets::SessionControlEvent* _internal_mutable_session_control();
  public:
  void unsafe_arena_set_allocated_session_control(
      ::ai::inworld::packets::SessionControlEvent* session_control);
  ::ai::inworld::packets::SessionControlEvent* unsafe_arena_release_session_control();

  // .ai.inworld.packets.SessionControlResponseEvent session_control_response = 20;
  bool has_session_control_response() const;
  private:
  bool _internal_has_session_control_response() const;
  public:
  void clear_session_control_response();
  const ::ai::inworld::packets::SessionControlResponseEvent& session_control_response() const;
  ::ai::inworld::packets::SessionControlResponseEvent* release_session_control_response();
  ::ai::inworld::packets::SessionControlResponseEvent* mutable_session_control_response();
  void set_allocated_session_control_response(::ai::inworld::packets::SessionControlResponseEvent* session_control_response);
  private:
  const ::ai::inworld::packets::SessionControlResponseEvent& _internal_session_control_response() const;
  ::ai::inworld::packets::SessionControlResponseEvent* _internal_mutable_session_control_response();
  public:
  void unsafe_arena_set_allocated_session_control_response(
      ::ai::inworld::packets::SessionControlResponseEvent* session_control_response);
  ::ai::inworld::packets::SessionControlResponseEvent* unsafe_arena_release_session_control_response();

  // .ai.inworld.packets.LatencyReportEvent latency_report = 22;
  bool has_latency_report() const;
  private:
  bool _internal_has_latency_report() const;
  public:
  void clear_latency_report();
  const ::ai::inworld::packets::LatencyReportEvent& latency_report() const;
  ::ai::inworld::packets::LatencyReportEvent* release_latency_report();
  ::ai::inworld::packets::LatencyReportEvent* mutable_latency_report();
  void set_allocated_latency_report(::ai::inworld::packets::LatencyReportEvent* latency_report);
  private:
  const ::ai::inworld::packets::LatencyReportEvent& _internal_latency_report() const;
  ::ai::inworld::packets::LatencyReportEvent* _internal_mutable_latency_report();
  public:
  void unsafe_arena_set_allocated_latency_report(
      ::ai::inworld::packets::LatencyReportEvent* latency_report);
  ::ai::inworld::packets::LatencyReportEvent* unsafe_arena_release_latency_report();

  // .ai.inworld.packets.OperationStatusEvent operation_status = 23;
  bool has_operation_status() const;
  private:
  bool _internal_has_operation_status() const;
  public:
  void clear_operation_status();
  const ::ai::inworld::packets::OperationStatusEvent& operation_status() const;
  ::ai::inworld::packets::OperationStatusEvent* release_operation_status();
  ::ai::inworld::packets::OperationStatusEvent* mutable_operation_status();
  void set_allocated_operation_status(::ai::inworld::packets::OperationStatusEvent* operation_status);
  private:
  const ::ai::inworld::packets::OperationStatusEvent& _internal_operation_status() const;
  ::ai::inworld::packets::OperationStatusEvent* _internal_mutable_operation_status();
  public:
  void unsafe_arena_set_allocated_operation_status(
      ::ai::inworld::packets::OperationStatusEvent* operation_status);
  ::ai::inworld::packets::OperationStatusEvent* unsafe_arena_release_operation_status();

  // .ai.inworld.packets.entities.ItemsOperationEvent entities_items_operation = 24;
  bool has_entities_items_operation() const;
  private:
  bool _internal_has_entities_items_operation() const;
  public:
  void clear_entities_items_operation();
  const ::ai::inworld::packets::entities::ItemsOperationEvent& entities_items_operation() const;
  ::ai::inworld::packets::entities::ItemsOperationEvent* release_entities_items_operation();
  ::ai::inworld::packets::entities::ItemsOperationEvent* mutable_entities_items_operation();
  void set_allocated_entities_items_operation(::ai::inworld::packets::entities::ItemsOperationEvent* entities_items_operation);
  private:
  const ::ai::inworld::packets::entities::ItemsOperationEvent& _internal_entities_items_operation() const;
  ::ai::inworld::packets::entities::ItemsOperationEvent* _internal_mutable_entities_items_operation();
  public:
  void unsafe_arena_set_allocated_entities_items_operation(
      ::ai::inworld::packets::entities::ItemsOperationEvent* entities_items_operation);
  ::ai::inworld::packets::entities::ItemsOperationEvent* unsafe_arena_release_entities_items_operation();

  // .ai.inworld.packets.LogsEvent log = 25;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::ai::inworld::packets::LogsEvent& log() const;
  ::ai::inworld::packets::LogsEvent* release_log();
  ::ai::inworld::packets::LogsEvent* mutable_log();
  void set_allocated_log(::ai::inworld::packets::LogsEvent* log);
  private:
  const ::ai::inworld::packets::LogsEvent& _internal_log() const;
  ::ai::inworld::packets::LogsEvent* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::ai::inworld::packets::LogsEvent* log);
  ::ai::inworld::packets::LogsEvent* unsafe_arena_release_log();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.InworldPacket)
 private:
  class _Internal;
  void set_has_text();
  void set_has_control();
  void set_has_audio_chunk();
  void set_has_custom();
  void set_has_cancelresponses();
  void set_has_emotion();
  void set_has_data_chunk();
  void set_has_action();
  void set_has_mutation();
  void set_has_load_scene_output();
  void set_has_debug_info();
  void set_has_session_control();
  void set_has_session_control_response();
  void set_has_latency_report();
  void set_has_operation_status();
  void set_has_entities_items_operation();
  void set_has_log();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::ai::inworld::packets::Routing* routing_;
  ::ai::inworld::packets::PacketId* packet_id_;
  union PacketUnion {
    PacketUnion() {}
    ::ai::inworld::packets::TextEvent* text_;
    ::ai::inworld::packets::ControlEvent* control_;
    ::ai::inworld::packets::AudioChunk* audio_chunk_;
    ::ai::inworld::packets::CustomEvent* custom_;
    ::ai::inworld::packets::CancelResponsesEvent* cancelresponses_;
    ::ai::inworld::packets::EmotionEvent* emotion_;
    ::ai::inworld::packets::DataChunk* data_chunk_;
    ::ai::inworld::packets::ActionEvent* action_;
    ::ai::inworld::packets::MutationEvent* mutation_;
    ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output_;
    ::ai::inworld::packets::DebugInfoEvent* debug_info_;
    ::ai::inworld::packets::SessionControlEvent* session_control_;
    ::ai::inworld::packets::SessionControlResponseEvent* session_control_response_;
    ::ai::inworld::packets::LatencyReportEvent* latency_report_;
    ::ai::inworld::packets::OperationStatusEvent* operation_status_;
    ::ai::inworld::packets::entities::ItemsOperationEvent* entities_items_operation_;
    ::ai::inworld::packets::LogsEvent* log_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent_ModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent.ModelInfo) */ {
 public:
  inline TextEvent_ModelInfo() : TextEvent_ModelInfo(nullptr) {}
  virtual ~TextEvent_ModelInfo();

  TextEvent_ModelInfo(const TextEvent_ModelInfo& from);
  TextEvent_ModelInfo(TextEvent_ModelInfo&& from) noexcept
    : TextEvent_ModelInfo() {
    *this = ::std::move(from);
  }

  inline TextEvent_ModelInfo& operator=(const TextEvent_ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent_ModelInfo& operator=(TextEvent_ModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextEvent_ModelInfo& default_instance();

  static inline const TextEvent_ModelInfo* internal_default_instance() {
    return reinterpret_cast<const TextEvent_ModelInfo*>(
               &_TextEvent_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TextEvent_ModelInfo& a, TextEvent_ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent_ModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent_ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextEvent_ModelInfo* New() const final {
    return CreateMaybeMessage<TextEvent_ModelInfo>(nullptr);
  }

  TextEvent_ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextEvent_ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextEvent_ModelInfo& from);
  void MergeFrom(const TextEvent_ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent_ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent.ModelInfo";
  }
  protected:
  explicit TextEvent_ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  virtual ~TextEvent();

  TextEvent(const TextEvent& from);
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextEvent& default_instance();

  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextEvent* New() const final {
    return CreateMaybeMessage<TextEvent>(nullptr);
  }

  TextEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextEvent& from);
  void MergeFrom(const TextEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent";
  }
  protected:
  explicit TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TextEvent_ModelInfo ModelInfo;

  typedef TextEvent_SourceType SourceType;
  static constexpr SourceType UNKNOWN =
    TextEvent_SourceType_UNKNOWN;
  static constexpr SourceType SPEECH_TO_TEXT =
    TextEvent_SourceType_SPEECH_TO_TEXT;
  static constexpr SourceType TYPED_IN =
    TextEvent_SourceType_TYPED_IN;
  static constexpr SourceType GENERATED =
    TextEvent_SourceType_GENERATED;
  static constexpr SourceType FILLER =
    TextEvent_SourceType_FILLER;
  static inline bool SourceType_IsValid(int value) {
    return TextEvent_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    TextEvent_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    TextEvent_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    TextEvent_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return TextEvent_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return TextEvent_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return TextEvent_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelInfoFieldNumber = 4,
    kSourceTypeFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::ai::inworld::packets::TextEvent_ModelInfo& model_info() const;
  ::ai::inworld::packets::TextEvent_ModelInfo* release_model_info();
  ::ai::inworld::packets::TextEvent_ModelInfo* mutable_model_info();
  void set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* model_info);
  private:
  const ::ai::inworld::packets::TextEvent_ModelInfo& _internal_model_info() const;
  ::ai::inworld::packets::TextEvent_ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::ai::inworld::packets::TextEvent_ModelInfo* model_info);
  ::ai::inworld::packets::TextEvent_ModelInfo* unsafe_arena_release_model_info();

  // .ai.inworld.packets.TextEvent.SourceType source_type = 2;
  void clear_source_type();
  ::ai::inworld::packets::TextEvent_SourceType source_type() const;
  void set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  private:
  ::ai::inworld::packets::TextEvent_SourceType _internal_source_type() const;
  void _internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  public:

  // bool final = 3;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::ai::inworld::packets::TextEvent_ModelInfo* model_info_;
  int source_type_;
  bool final_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ControlEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ControlEvent) */ {
 public:
  inline ControlEvent() : ControlEvent(nullptr) {}
  virtual ~ControlEvent();

  ControlEvent(const ControlEvent& from);
  ControlEvent(ControlEvent&& from) noexcept
    : ControlEvent() {
    *this = ::std::move(from);
  }

  inline ControlEvent& operator=(const ControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlEvent& operator=(ControlEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlEvent& default_instance();

  enum PayloadStructuredCase {
    kConversationUpdate = 4,
    kConversationEvent = 5,
    kAudioSessionStart = 6,
    kCurrentSceneStatus = 7,
    kSessionConfiguration = 8,
    PAYLOAD_STRUCTURED_NOT_SET = 0,
  };

  static inline const ControlEvent* internal_default_instance() {
    return reinterpret_cast<const ControlEvent*>(
               &_ControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlEvent& a, ControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlEvent* New() const final {
    return CreateMaybeMessage<ControlEvent>(nullptr);
  }

  ControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlEvent& from);
  void MergeFrom(const ControlEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ControlEvent";
  }
  protected:
  explicit ControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControlEvent_Action Action;
  static constexpr Action UNKNOWN =
    ControlEvent_Action_UNKNOWN;
  static constexpr Action AUDIO_SESSION_START =
    ControlEvent_Action_AUDIO_SESSION_START;
  static constexpr Action AUDIO_SESSION_END =
    ControlEvent_Action_AUDIO_SESSION_END;
  static constexpr Action INTERACTION_END =
    ControlEvent_Action_INTERACTION_END;
  static constexpr Action TTS_PLAYBACK_START =
    ControlEvent_Action_TTS_PLAYBACK_START;
  static constexpr Action TTS_PLAYBACK_END =
    ControlEvent_Action_TTS_PLAYBACK_END;
  static constexpr Action TTS_PLAYBACK_MUTE =
    ControlEvent_Action_TTS_PLAYBACK_MUTE;
  static constexpr Action TTS_PLAYBACK_UNMUTE =
    ControlEvent_Action_TTS_PLAYBACK_UNMUTE;
  PROTOBUF_DEPRECATED_ENUM static constexpr Action WARNING =
    ControlEvent_Action_WARNING;
  static constexpr Action SESSION_END =
    ControlEvent_Action_SESSION_END;
  PROTOBUF_DEPRECATED_ENUM static constexpr Action CONVERSATION_START =
    ControlEvent_Action_CONVERSATION_START;
  static constexpr Action CONVERSATION_UPDATE =
    ControlEvent_Action_CONVERSATION_UPDATE;
  PROTOBUF_DEPRECATED_ENUM static constexpr Action CONVERSATION_STARTED =
    ControlEvent_Action_CONVERSATION_STARTED;
  static constexpr Action CONVERSATION_EVENT =
    ControlEvent_Action_CONVERSATION_EVENT;
  static constexpr Action CURRENT_SCENE_STATUS =
    ControlEvent_Action_CURRENT_SCENE_STATUS;
  static constexpr Action SESSION_CONFIGURATION =
    ControlEvent_Action_SESSION_CONFIGURATION;
  static inline bool Action_IsValid(int value) {
    return ControlEvent_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ControlEvent_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ControlEvent_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ControlEvent_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return ControlEvent_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ControlEvent_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ControlEvent_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kActionFieldNumber = 1,
    kConversationUpdateFieldNumber = 4,
    kConversationEventFieldNumber = 5,
    kAudioSessionStartFieldNumber = 6,
    kCurrentSceneStatusFieldNumber = 7,
    kSessionConfigurationFieldNumber = 8,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Struct payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const PROTOBUF_NAMESPACE_ID::Struct& payload() const;
  PROTOBUF_NAMESPACE_ID::Struct* release_payload();
  PROTOBUF_NAMESPACE_ID::Struct* mutable_payload();
  void set_allocated_payload(PROTOBUF_NAMESPACE_ID::Struct* payload);
  private:
  const PROTOBUF_NAMESPACE_ID::Struct& _internal_payload() const;
  PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      PROTOBUF_NAMESPACE_ID::Struct* payload);
  PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_payload();

  // .ai.inworld.packets.ControlEvent.Action action = 1;
  void clear_action();
  ::ai::inworld::packets::ControlEvent_Action action() const;
  void set_action(::ai::inworld::packets::ControlEvent_Action value);
  private:
  ::ai::inworld::packets::ControlEvent_Action _internal_action() const;
  void _internal_set_action(::ai::inworld::packets::ControlEvent_Action value);
  public:

  // .ai.inworld.packets.ConversationUpdatePayload conversation_update = 4;
  bool has_conversation_update() const;
  private:
  bool _internal_has_conversation_update() const;
  public:
  void clear_conversation_update();
  const ::ai::inworld::packets::ConversationUpdatePayload& conversation_update() const;
  ::ai::inworld::packets::ConversationUpdatePayload* release_conversation_update();
  ::ai::inworld::packets::ConversationUpdatePayload* mutable_conversation_update();
  void set_allocated_conversation_update(::ai::inworld::packets::ConversationUpdatePayload* conversation_update);
  private:
  const ::ai::inworld::packets::ConversationUpdatePayload& _internal_conversation_update() const;
  ::ai::inworld::packets::ConversationUpdatePayload* _internal_mutable_conversation_update();
  public:
  void unsafe_arena_set_allocated_conversation_update(
      ::ai::inworld::packets::ConversationUpdatePayload* conversation_update);
  ::ai::inworld::packets::ConversationUpdatePayload* unsafe_arena_release_conversation_update();

  // .ai.inworld.packets.ConversationEventPayload conversation_event = 5;
  bool has_conversation_event() const;
  private:
  bool _internal_has_conversation_event() const;
  public:
  void clear_conversation_event();
  const ::ai::inworld::packets::ConversationEventPayload& conversation_event() const;
  ::ai::inworld::packets::ConversationEventPayload* release_conversation_event();
  ::ai::inworld::packets::ConversationEventPayload* mutable_conversation_event();
  void set_allocated_conversation_event(::ai::inworld::packets::ConversationEventPayload* conversation_event);
  private:
  const ::ai::inworld::packets::ConversationEventPayload& _internal_conversation_event() const;
  ::ai::inworld::packets::ConversationEventPayload* _internal_mutable_conversation_event();
  public:
  void unsafe_arena_set_allocated_conversation_event(
      ::ai::inworld::packets::ConversationEventPayload* conversation_event);
  ::ai::inworld::packets::ConversationEventPayload* unsafe_arena_release_conversation_event();

  // .ai.inworld.packets.AudioSessionStartPayload audio_session_start = 6;
  bool has_audio_session_start() const;
  private:
  bool _internal_has_audio_session_start() const;
  public:
  void clear_audio_session_start();
  const ::ai::inworld::packets::AudioSessionStartPayload& audio_session_start() const;
  ::ai::inworld::packets::AudioSessionStartPayload* release_audio_session_start();
  ::ai::inworld::packets::AudioSessionStartPayload* mutable_audio_session_start();
  void set_allocated_audio_session_start(::ai::inworld::packets::AudioSessionStartPayload* audio_session_start);
  private:
  const ::ai::inworld::packets::AudioSessionStartPayload& _internal_audio_session_start() const;
  ::ai::inworld::packets::AudioSessionStartPayload* _internal_mutable_audio_session_start();
  public:
  void unsafe_arena_set_allocated_audio_session_start(
      ::ai::inworld::packets::AudioSessionStartPayload* audio_session_start);
  ::ai::inworld::packets::AudioSessionStartPayload* unsafe_arena_release_audio_session_start();

  // .ai.inworld.packets.CurrentSceneStatus current_scene_status = 7;
  bool has_current_scene_status() const;
  private:
  bool _internal_has_current_scene_status() const;
  public:
  void clear_current_scene_status();
  const ::ai::inworld::packets::CurrentSceneStatus& current_scene_status() const;
  ::ai::inworld::packets::CurrentSceneStatus* release_current_scene_status();
  ::ai::inworld::packets::CurrentSceneStatus* mutable_current_scene_status();
  void set_allocated_current_scene_status(::ai::inworld::packets::CurrentSceneStatus* current_scene_status);
  private:
  const ::ai::inworld::packets::CurrentSceneStatus& _internal_current_scene_status() const;
  ::ai::inworld::packets::CurrentSceneStatus* _internal_mutable_current_scene_status();
  public:
  void unsafe_arena_set_allocated_current_scene_status(
      ::ai::inworld::packets::CurrentSceneStatus* current_scene_status);
  ::ai::inworld::packets::CurrentSceneStatus* unsafe_arena_release_current_scene_status();

  // .ai.inworld.packets.SessionConfigurationPayload session_configuration = 8;
  bool has_session_configuration() const;
  private:
  bool _internal_has_session_configuration() const;
  public:
  void clear_session_configuration();
  const ::ai::inworld::packets::SessionConfigurationPayload& session_configuration() const;
  ::ai::inworld::packets::SessionConfigurationPayload* release_session_configuration();
  ::ai::inworld::packets::SessionConfigurationPayload* mutable_session_configuration();
  void set_allocated_session_configuration(::ai::inworld::packets::SessionConfigurationPayload* session_configuration);
  private:
  const ::ai::inworld::packets::SessionConfigurationPayload& _internal_session_configuration() const;
  ::ai::inworld::packets::SessionConfigurationPayload* _internal_mutable_session_configuration();
  public:
  void unsafe_arena_set_allocated_session_configuration(
      ::ai::inworld::packets::SessionConfigurationPayload* session_configuration);
  ::ai::inworld::packets::SessionConfigurationPayload* unsafe_arena_release_session_configuration();

  void clear_payload_structured();
  PayloadStructuredCase payload_structured_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ControlEvent)
 private:
  class _Internal;
  void set_has_conversation_update();
  void set_has_conversation_event();
  void set_has_audio_session_start();
  void set_has_current_scene_status();
  void set_has_session_configuration();

  inline bool has_payload_structured() const;
  inline void clear_has_payload_structured();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  PROTOBUF_NAMESPACE_ID::Struct* payload_;
  int action_;
  union PayloadStructuredUnion {
    PayloadStructuredUnion() {}
    ::ai::inworld::packets::ConversationUpdatePayload* conversation_update_;
    ::ai::inworld::packets::ConversationEventPayload* conversation_event_;
    ::ai::inworld::packets::AudioSessionStartPayload* audio_session_start_;
    ::ai::inworld::packets::CurrentSceneStatus* current_scene_status_;
    ::ai::inworld::packets::SessionConfigurationPayload* session_configuration_;
  } payload_structured_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class AudioSessionStartPayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AudioSessionStartPayload) */ {
 public:
  inline AudioSessionStartPayload() : AudioSessionStartPayload(nullptr) {}
  virtual ~AudioSessionStartPayload();

  AudioSessionStartPayload(const AudioSessionStartPayload& from);
  AudioSessionStartPayload(AudioSessionStartPayload&& from) noexcept
    : AudioSessionStartPayload() {
    *this = ::std::move(from);
  }

  inline AudioSessionStartPayload& operator=(const AudioSessionStartPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioSessionStartPayload& operator=(AudioSessionStartPayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioSessionStartPayload& default_instance();

  static inline const AudioSessionStartPayload* internal_default_instance() {
    return reinterpret_cast<const AudioSessionStartPayload*>(
               &_AudioSessionStartPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AudioSessionStartPayload& a, AudioSessionStartPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioSessionStartPayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioSessionStartPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioSessionStartPayload* New() const final {
    return CreateMaybeMessage<AudioSessionStartPayload>(nullptr);
  }

  AudioSessionStartPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioSessionStartPayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioSessionStartPayload& from);
  void MergeFrom(const AudioSessionStartPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioSessionStartPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AudioSessionStartPayload";
  }
  protected:
  explicit AudioSessionStartPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AudioSessionStartPayload_MicrophoneMode MicrophoneMode;
  static constexpr MicrophoneMode UNSPECIFIED =
    AudioSessionStartPayload_MicrophoneMode_UNSPECIFIED;
  static constexpr MicrophoneMode OPEN_MIC =
    AudioSessionStartPayload_MicrophoneMode_OPEN_MIC;
  static constexpr MicrophoneMode EXPECT_AUDIO_END =
    AudioSessionStartPayload_MicrophoneMode_EXPECT_AUDIO_END;
  static inline bool MicrophoneMode_IsValid(int value) {
    return AudioSessionStartPayload_MicrophoneMode_IsValid(value);
  }
  static constexpr MicrophoneMode MicrophoneMode_MIN =
    AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_MIN;
  static constexpr MicrophoneMode MicrophoneMode_MAX =
    AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_MAX;
  static constexpr int MicrophoneMode_ARRAYSIZE =
    AudioSessionStartPayload_MicrophoneMode_MicrophoneMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MicrophoneMode_descriptor() {
    return AudioSessionStartPayload_MicrophoneMode_descriptor();
  }
  template<typename T>
  static inline const std::string& MicrophoneMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MicrophoneMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MicrophoneMode_Name.");
    return AudioSessionStartPayload_MicrophoneMode_Name(enum_t_value);
  }
  static inline bool MicrophoneMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MicrophoneMode* value) {
    return AudioSessionStartPayload_MicrophoneMode_Parse(name, value);
  }

  typedef AudioSessionStartPayload_UnderstandingMode UnderstandingMode;
  static constexpr UnderstandingMode UNSPECIFIED_UNDERSTANDING_MODE =
    AudioSessionStartPayload_UnderstandingMode_UNSPECIFIED_UNDERSTANDING_MODE;
  static constexpr UnderstandingMode FULL =
    AudioSessionStartPayload_UnderstandingMode_FULL;
  static constexpr UnderstandingMode SPEECH_RECOGNITION_ONLY =
    AudioSessionStartPayload_UnderstandingMode_SPEECH_RECOGNITION_ONLY;
  static inline bool UnderstandingMode_IsValid(int value) {
    return AudioSessionStartPayload_UnderstandingMode_IsValid(value);
  }
  static constexpr UnderstandingMode UnderstandingMode_MIN =
    AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_MIN;
  static constexpr UnderstandingMode UnderstandingMode_MAX =
    AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_MAX;
  static constexpr int UnderstandingMode_ARRAYSIZE =
    AudioSessionStartPayload_UnderstandingMode_UnderstandingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnderstandingMode_descriptor() {
    return AudioSessionStartPayload_UnderstandingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& UnderstandingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnderstandingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnderstandingMode_Name.");
    return AudioSessionStartPayload_UnderstandingMode_Name(enum_t_value);
  }
  static inline bool UnderstandingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UnderstandingMode* value) {
    return AudioSessionStartPayload_UnderstandingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
    kUnderstandingModeFieldNumber = 2,
  };
  // .ai.inworld.packets.AudioSessionStartPayload.MicrophoneMode mode = 1;
  void clear_mode();
  ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode mode() const;
  void set_mode(::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode value);
  private:
  ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode _internal_mode() const;
  void _internal_set_mode(::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode value);
  public:

  // .ai.inworld.packets.AudioSessionStartPayload.UnderstandingMode understanding_mode = 2;
  void clear_understanding_mode();
  ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode understanding_mode() const;
  void set_understanding_mode(::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode value);
  private:
  ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode _internal_understanding_mode() const;
  void _internal_set_understanding_mode(::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AudioSessionStartPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int mode_;
  int understanding_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class AudioChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  virtual ~AudioChunk();

  AudioChunk(const AudioChunk& from);
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioChunk& default_instance();

  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioChunk* New() const final {
    return CreateMaybeMessage<AudioChunk>(nullptr);
  }

  AudioChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioChunk& from);
  void MergeFrom(const AudioChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AudioChunk";
  }
  protected:
  explicit AudioChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk();
  const std::string& chunk() const;
  void set_chunk(const std::string& value);
  void set_chunk(std::string&& value);
  void set_chunk(const char* value);
  void set_chunk(const void* value, size_t size);
  std::string* mutable_chunk();
  std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AudioChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent_Parameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent.Parameter) */ {
 public:
  inline CustomEvent_Parameter() : CustomEvent_Parameter(nullptr) {}
  virtual ~CustomEvent_Parameter();

  CustomEvent_Parameter(const CustomEvent_Parameter& from);
  CustomEvent_Parameter(CustomEvent_Parameter&& from) noexcept
    : CustomEvent_Parameter() {
    *this = ::std::move(from);
  }

  inline CustomEvent_Parameter& operator=(const CustomEvent_Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent_Parameter& operator=(CustomEvent_Parameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomEvent_Parameter& default_instance();

  static inline const CustomEvent_Parameter* internal_default_instance() {
    return reinterpret_cast<const CustomEvent_Parameter*>(
               &_CustomEvent_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CustomEvent_Parameter& a, CustomEvent_Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent_Parameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent_Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomEvent_Parameter* New() const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(nullptr);
  }

  CustomEvent_Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomEvent_Parameter& from);
  void MergeFrom(const CustomEvent_Parameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent_Parameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent.Parameter";
  }
  protected:
  explicit CustomEvent_Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  virtual ~CustomEvent();

  CustomEvent(const CustomEvent& from);
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomEvent& default_instance();

  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomEvent* New() const final {
    return CreateMaybeMessage<CustomEvent>(nullptr);
  }

  CustomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomEvent& from);
  void MergeFrom(const CustomEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent";
  }
  protected:
  explicit CustomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CustomEvent_Parameter Parameter;

  typedef CustomEvent_Type Type;
  static constexpr Type UNSPECIFIED =
    CustomEvent_Type_UNSPECIFIED;
  static constexpr Type TRIGGER =
    CustomEvent_Type_TRIGGER;
  static constexpr Type TASK =
    CustomEvent_Type_TASK;
  static inline bool Type_IsValid(int value) {
    return CustomEvent_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CustomEvent_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CustomEvent_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CustomEvent_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return CustomEvent_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CustomEvent_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CustomEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kNameFieldNumber = 1,
    kPlaybackFieldNumber = 2,
    kTypeFieldNumber = 4,
  };
  // repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::ai::inworld::packets::CustomEvent_Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
      mutable_parameters();
  private:
  const ::ai::inworld::packets::CustomEvent_Parameter& _internal_parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* _internal_add_parameters();
  public:
  const ::ai::inworld::packets::CustomEvent_Parameter& parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // .ai.inworld.packets.CustomEvent.Type type = 4;
  void clear_type();
  ::ai::inworld::packets::CustomEvent_Type type() const;
  void set_type(::ai::inworld::packets::CustomEvent_Type value);
  private:
  ::ai::inworld::packets::CustomEvent_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::CustomEvent_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int playback_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponsesEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponsesEvent) */ {
 public:
  inline CancelResponsesEvent() : CancelResponsesEvent(nullptr) {}
  virtual ~CancelResponsesEvent();

  CancelResponsesEvent(const CancelResponsesEvent& from);
  CancelResponsesEvent(CancelResponsesEvent&& from) noexcept
    : CancelResponsesEvent() {
    *this = ::std::move(from);
  }

  inline CancelResponsesEvent& operator=(const CancelResponsesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponsesEvent& operator=(CancelResponsesEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelResponsesEvent& default_instance();

  static inline const CancelResponsesEvent* internal_default_instance() {
    return reinterpret_cast<const CancelResponsesEvent*>(
               &_CancelResponsesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CancelResponsesEvent& a, CancelResponsesEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponsesEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponsesEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelResponsesEvent* New() const final {
    return CreateMaybeMessage<CancelResponsesEvent>(nullptr);
  }

  CancelResponsesEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelResponsesEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelResponsesEvent& from);
  void MergeFrom(const CancelResponsesEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponsesEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponsesEvent";
  }
  protected:
  explicit CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponsesEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class EmotionEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.EmotionEvent) */ {
 public:
  inline EmotionEvent() : EmotionEvent(nullptr) {}
  virtual ~EmotionEvent();

  EmotionEvent(const EmotionEvent& from);
  EmotionEvent(EmotionEvent&& from) noexcept
    : EmotionEvent() {
    *this = ::std::move(from);
  }

  inline EmotionEvent& operator=(const EmotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionEvent& operator=(EmotionEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmotionEvent& default_instance();

  static inline const EmotionEvent* internal_default_instance() {
    return reinterpret_cast<const EmotionEvent*>(
               &_EmotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EmotionEvent& a, EmotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmotionEvent* New() const final {
    return CreateMaybeMessage<EmotionEvent>(nullptr);
  }

  EmotionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmotionEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmotionEvent& from);
  void MergeFrom(const EmotionEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.EmotionEvent";
  }
  protected:
  explicit EmotionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EmotionEvent_SpaffCode SpaffCode;
  static constexpr SpaffCode NEUTRAL =
    EmotionEvent_SpaffCode_NEUTRAL;
  static constexpr SpaffCode DISGUST =
    EmotionEvent_SpaffCode_DISGUST;
  static constexpr SpaffCode CONTEMPT =
    EmotionEvent_SpaffCode_CONTEMPT;
  static constexpr SpaffCode BELLIGERENCE =
    EmotionEvent_SpaffCode_BELLIGERENCE;
  static constexpr SpaffCode DOMINEERING =
    EmotionEvent_SpaffCode_DOMINEERING;
  static constexpr SpaffCode CRITICISM =
    EmotionEvent_SpaffCode_CRITICISM;
  static constexpr SpaffCode ANGER =
    EmotionEvent_SpaffCode_ANGER;
  static constexpr SpaffCode TENSION =
    EmotionEvent_SpaffCode_TENSION;
  static constexpr SpaffCode TENSE_HUMOR =
    EmotionEvent_SpaffCode_TENSE_HUMOR;
  static constexpr SpaffCode DEFENSIVENESS =
    EmotionEvent_SpaffCode_DEFENSIVENESS;
  static constexpr SpaffCode WHINING =
    EmotionEvent_SpaffCode_WHINING;
  static constexpr SpaffCode SADNESS =
    EmotionEvent_SpaffCode_SADNESS;
  static constexpr SpaffCode STONEWALLING =
    EmotionEvent_SpaffCode_STONEWALLING;
  static constexpr SpaffCode INTEREST =
    EmotionEvent_SpaffCode_INTEREST;
  static constexpr SpaffCode VALIDATION =
    EmotionEvent_SpaffCode_VALIDATION;
  static constexpr SpaffCode AFFECTION =
    EmotionEvent_SpaffCode_AFFECTION;
  static constexpr SpaffCode HUMOR =
    EmotionEvent_SpaffCode_HUMOR;
  static constexpr SpaffCode SURPRISE =
    EmotionEvent_SpaffCode_SURPRISE;
  static constexpr SpaffCode JOY =
    EmotionEvent_SpaffCode_JOY;
  static inline bool SpaffCode_IsValid(int value) {
    return EmotionEvent_SpaffCode_IsValid(value);
  }
  static constexpr SpaffCode SpaffCode_MIN =
    EmotionEvent_SpaffCode_SpaffCode_MIN;
  static constexpr SpaffCode SpaffCode_MAX =
    EmotionEvent_SpaffCode_SpaffCode_MAX;
  static constexpr int SpaffCode_ARRAYSIZE =
    EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaffCode_descriptor() {
    return EmotionEvent_SpaffCode_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaffCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaffCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaffCode_Name.");
    return EmotionEvent_SpaffCode_Name(enum_t_value);
  }
  static inline bool SpaffCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SpaffCode* value) {
    return EmotionEvent_SpaffCode_Parse(name, value);
  }

  typedef EmotionEvent_Strength Strength;
  static constexpr Strength UNSPECIFIED =
    EmotionEvent_Strength_UNSPECIFIED;
  static constexpr Strength WEAK =
    EmotionEvent_Strength_WEAK;
  static constexpr Strength STRONG =
    EmotionEvent_Strength_STRONG;
  static constexpr Strength NORMAL =
    EmotionEvent_Strength_NORMAL;
  static inline bool Strength_IsValid(int value) {
    return EmotionEvent_Strength_IsValid(value);
  }
  static constexpr Strength Strength_MIN =
    EmotionEvent_Strength_Strength_MIN;
  static constexpr Strength Strength_MAX =
    EmotionEvent_Strength_Strength_MAX;
  static constexpr int Strength_ARRAYSIZE =
    EmotionEvent_Strength_Strength_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Strength_descriptor() {
    return EmotionEvent_Strength_descriptor();
  }
  template<typename T>
  static inline const std::string& Strength_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Strength>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Strength_Name.");
    return EmotionEvent_Strength_Name(enum_t_value);
  }
  static inline bool Strength_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Strength* value) {
    return EmotionEvent_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJoyFieldNumber = 1,
    kFearFieldNumber = 2,
    kTrustFieldNumber = 3,
    kSurpriseFieldNumber = 4,
    kBehaviorFieldNumber = 5,
    kStrengthFieldNumber = 6,
  };
  // float joy = 1;
  void clear_joy();
  float joy() const;
  void set_joy(float value);
  private:
  float _internal_joy() const;
  void _internal_set_joy(float value);
  public:

  // float fear = 2;
  void clear_fear();
  float fear() const;
  void set_fear(float value);
  private:
  float _internal_fear() const;
  void _internal_set_fear(float value);
  public:

  // float trust = 3;
  void clear_trust();
  float trust() const;
  void set_trust(float value);
  private:
  float _internal_trust() const;
  void _internal_set_trust(float value);
  public:

  // float surprise = 4;
  void clear_surprise();
  float surprise() const;
  void set_surprise(float value);
  private:
  float _internal_surprise() const;
  void _internal_set_surprise(float value);
  public:

  // .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
  void clear_behavior();
  ::ai::inworld::packets::EmotionEvent_SpaffCode behavior() const;
  void set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  private:
  ::ai::inworld::packets::EmotionEvent_SpaffCode _internal_behavior() const;
  void _internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  public:

  // .ai.inworld.packets.EmotionEvent.Strength strength = 6;
  void clear_strength();
  ::ai::inworld::packets::EmotionEvent_Strength strength() const;
  void set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  private:
  ::ai::inworld::packets::EmotionEvent_Strength _internal_strength() const;
  void _internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.EmotionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float joy_;
  float fear_;
  float trust_;
  float surprise_;
  int behavior_;
  int strength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class DataChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  virtual ~DataChunk();

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataChunk& default_instance();

  enum DataCase {
    kChunk = 1,
    kDurationMs = 3,
    DATA_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataChunk* New() const final {
    return CreateMaybeMessage<DataChunk>(nullptr);
  }

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataChunk& from);
  void MergeFrom(const DataChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DataChunk_DataType DataType;
  static constexpr DataType UNSPECIFIED =
    DataChunk_DataType_UNSPECIFIED;
  static constexpr DataType AUDIO =
    DataChunk_DataType_AUDIO;
  PROTOBUF_DEPRECATED_ENUM static constexpr DataType SILENCE =
    DataChunk_DataType_SILENCE;
  static constexpr DataType STATE =
    DataChunk_DataType_STATE;
  static constexpr DataType NVIDIA_A2F_ANIMATION =
    DataChunk_DataType_NVIDIA_A2F_ANIMATION;
  static constexpr DataType NVIDIA_A2F_ANIMATION_HEADER =
    DataChunk_DataType_NVIDIA_A2F_ANIMATION_HEADER;
  static constexpr DataType INSPECT =
    DataChunk_DataType_INSPECT;
  static inline bool DataType_IsValid(int value) {
    return DataChunk_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    DataChunk_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    DataChunk_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    DataChunk_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return DataChunk_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return DataChunk_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return DataChunk_DataType_Parse(name, value);
  }

  typedef DataChunk_AudioFormat AudioFormat;
  static constexpr AudioFormat UNSPECIFIED_AUDIO_FORMAT =
    DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT;
  static constexpr AudioFormat AUDIO_MP3 =
    DataChunk_AudioFormat_AUDIO_MP3;
  static constexpr AudioFormat AUDIO_PCM_16000 =
    DataChunk_AudioFormat_AUDIO_PCM_16000;
  static constexpr AudioFormat AUDIO_PCM_22050 =
    DataChunk_AudioFormat_AUDIO_PCM_22050;
  static inline bool AudioFormat_IsValid(int value) {
    return DataChunk_AudioFormat_IsValid(value);
  }
  static constexpr AudioFormat AudioFormat_MIN =
    DataChunk_AudioFormat_AudioFormat_MIN;
  static constexpr AudioFormat AudioFormat_MAX =
    DataChunk_AudioFormat_AudioFormat_MAX;
  static constexpr int AudioFormat_ARRAYSIZE =
    DataChunk_AudioFormat_AudioFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioFormat_descriptor() {
    return DataChunk_AudioFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioFormat_Name.");
    return DataChunk_AudioFormat_Name(enum_t_value);
  }
  static inline bool AudioFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioFormat* value) {
    return DataChunk_AudioFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPhonemeInfoFieldNumber = 4,
    kTypeFieldNumber = 2,
    kAudioFormatFieldNumber = 5,
    kChunkFieldNumber = 1,
    kDurationMsFieldNumber = 3,
  };
  // repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
  int additional_phoneme_info_size() const;
  private:
  int _internal_additional_phoneme_info_size() const;
  public:
  void clear_additional_phoneme_info();
  ::ai::inworld::packets::AdditionalPhonemeInfo* mutable_additional_phoneme_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
      mutable_additional_phoneme_info();
  private:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& _internal_additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* _internal_add_additional_phoneme_info();
  public:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* add_additional_phoneme_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
      additional_phoneme_info() const;

  // .ai.inworld.packets.DataChunk.DataType type = 2;
  void clear_type();
  ::ai::inworld::packets::DataChunk_DataType type() const;
  void set_type(::ai::inworld::packets::DataChunk_DataType value);
  private:
  ::ai::inworld::packets::DataChunk_DataType _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::DataChunk_DataType value);
  public:

  // .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
  void clear_audioformat();
  ::ai::inworld::packets::DataChunk_AudioFormat audioformat() const;
  void set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);
  private:
  ::ai::inworld::packets::DataChunk_AudioFormat _internal_audioformat() const;
  void _internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);
  public:

  // bytes chunk = 1;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const std::string& chunk() const;
  void set_chunk(const std::string& value);
  void set_chunk(std::string&& value);
  void set_chunk(const char* value);
  void set_chunk(const void* value, size_t size);
  std::string* mutable_chunk();
  std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // int64 duration_ms = 3 [deprecated = true];
  private:
  bool _internal_has_duration_ms() const;
  public:
  PROTOBUF_DEPRECATED void clear_duration_ms();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int64 duration_ms() const;
  PROTOBUF_DEPRECATED void set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration_ms() const;
  void _internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DataChunk)
 private:
  class _Internal;
  void set_has_chunk();
  void set_has_duration_ms();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo > additional_phoneme_info_;
  int type_;
  int audioformat_;
  union DataUnion {
    DataUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    ::PROTOBUF_NAMESPACE_ID::int64 duration_ms_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class AdditionalPhonemeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AdditionalPhonemeInfo) */ {
 public:
  inline AdditionalPhonemeInfo() : AdditionalPhonemeInfo(nullptr) {}
  virtual ~AdditionalPhonemeInfo();

  AdditionalPhonemeInfo(const AdditionalPhonemeInfo& from);
  AdditionalPhonemeInfo(AdditionalPhonemeInfo&& from) noexcept
    : AdditionalPhonemeInfo() {
    *this = ::std::move(from);
  }

  inline AdditionalPhonemeInfo& operator=(const AdditionalPhonemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPhonemeInfo& operator=(AdditionalPhonemeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalPhonemeInfo& default_instance();

  static inline const AdditionalPhonemeInfo* internal_default_instance() {
    return reinterpret_cast<const AdditionalPhonemeInfo*>(
               &_AdditionalPhonemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AdditionalPhonemeInfo& a, AdditionalPhonemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalPhonemeInfo* New() const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(nullptr);
  }

  AdditionalPhonemeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalPhonemeInfo& from);
  void MergeFrom(const AdditionalPhonemeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalPhonemeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AdditionalPhonemeInfo";
  }
  protected:
  explicit AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonemeFieldNumber = 1,
    kStartOffsetFieldNumber = 2,
  };
  // string phoneme = 1;
  void clear_phoneme();
  const std::string& phoneme() const;
  void set_phoneme(const std::string& value);
  void set_phoneme(std::string&& value);
  void set_phoneme(const char* value);
  void set_phoneme(const char* value, size_t size);
  std::string* mutable_phoneme();
  std::string* release_phoneme();
  void set_allocated_phoneme(std::string* phoneme);
  private:
  const std::string& _internal_phoneme() const;
  void _internal_set_phoneme(const std::string& value);
  std::string* _internal_mutable_phoneme();
  public:

  // .google.protobuf.Duration start_offset = 2;
  bool has_start_offset() const;
  private:
  bool _internal_has_start_offset() const;
  public:
  void clear_start_offset();
  const PROTOBUF_NAMESPACE_ID::Duration& start_offset() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_start_offset();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_start_offset();
  void set_allocated_start_offset(PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_start_offset() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_start_offset();
  public:
  void unsafe_arena_set_allocated_start_offset(
      PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_start_offset();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AdditionalPhonemeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phoneme_;
  PROTOBUF_NAMESPACE_ID::Duration* start_offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ActionEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ActionEvent) */ {
 public:
  inline ActionEvent() : ActionEvent(nullptr) {}
  virtual ~ActionEvent();

  ActionEvent(const ActionEvent& from);
  ActionEvent(ActionEvent&& from) noexcept
    : ActionEvent() {
    *this = ::std::move(from);
  }

  inline ActionEvent& operator=(const ActionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEvent& operator=(ActionEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionEvent& default_instance();

  enum ActionCase {
    kNarratedAction = 1,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionEvent* internal_default_instance() {
    return reinterpret_cast<const ActionEvent*>(
               &_ActionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ActionEvent& a, ActionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionEvent* New() const final {
    return CreateMaybeMessage<ActionEvent>(nullptr);
  }

  ActionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionEvent& from);
  void MergeFrom(const ActionEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ActionEvent";
  }
  protected:
  explicit ActionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaybackFieldNumber = 2,
    kNarratedActionFieldNumber = 1,
  };
  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // .ai.inworld.packets.NarratedAction narrated_action = 1;
  bool has_narrated_action() const;
  private:
  bool _internal_has_narrated_action() const;
  public:
  void clear_narrated_action();
  const ::ai::inworld::packets::NarratedAction& narrated_action() const;
  ::ai::inworld::packets::NarratedAction* release_narrated_action();
  ::ai::inworld::packets::NarratedAction* mutable_narrated_action();
  void set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action);
  private:
  const ::ai::inworld::packets::NarratedAction& _internal_narrated_action() const;
  ::ai::inworld::packets::NarratedAction* _internal_mutable_narrated_action();
  public:
  void unsafe_arena_set_allocated_narrated_action(
      ::ai::inworld::packets::NarratedAction* narrated_action);
  ::ai::inworld::packets::NarratedAction* unsafe_arena_release_narrated_action();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ActionEvent)
 private:
  class _Internal;
  void set_has_narrated_action();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int playback_;
  union ActionUnion {
    ActionUnion() {}
    ::ai::inworld::packets::NarratedAction* narrated_action_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class NarratedAction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.NarratedAction) */ {
 public:
  inline NarratedAction() : NarratedAction(nullptr) {}
  virtual ~NarratedAction();

  NarratedAction(const NarratedAction& from);
  NarratedAction(NarratedAction&& from) noexcept
    : NarratedAction() {
    *this = ::std::move(from);
  }

  inline NarratedAction& operator=(const NarratedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NarratedAction& operator=(NarratedAction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NarratedAction& default_instance();

  static inline const NarratedAction* internal_default_instance() {
    return reinterpret_cast<const NarratedAction*>(
               &_NarratedAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NarratedAction& a, NarratedAction& b) {
    a.Swap(&b);
  }
  inline void Swap(NarratedAction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NarratedAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NarratedAction* New() const final {
    return CreateMaybeMessage<NarratedAction>(nullptr);
  }

  NarratedAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NarratedAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NarratedAction& from);
  void MergeFrom(const NarratedAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NarratedAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.NarratedAction";
  }
  protected:
  explicit NarratedAction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.NarratedAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo_RelationAttributes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo.RelationAttributes) */ {
 public:
  inline RelationInfo_RelationAttributes() : RelationInfo_RelationAttributes(nullptr) {}
  virtual ~RelationInfo_RelationAttributes();

  RelationInfo_RelationAttributes(const RelationInfo_RelationAttributes& from);
  RelationInfo_RelationAttributes(RelationInfo_RelationAttributes&& from) noexcept
    : RelationInfo_RelationAttributes() {
    *this = ::std::move(from);
  }

  inline RelationInfo_RelationAttributes& operator=(const RelationInfo_RelationAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo_RelationAttributes& operator=(RelationInfo_RelationAttributes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationInfo_RelationAttributes& default_instance();

  static inline const RelationInfo_RelationAttributes* internal_default_instance() {
    return reinterpret_cast<const RelationInfo_RelationAttributes*>(
               &_RelationInfo_RelationAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RelationInfo_RelationAttributes& a, RelationInfo_RelationAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationInfo_RelationAttributes* New() const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(nullptr);
  }

  RelationInfo_RelationAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationInfo_RelationAttributes& from);
  void MergeFrom(const RelationInfo_RelationAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo_RelationAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo.RelationAttributes";
  }
  protected:
  explicit RelationInfo_RelationAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustFieldNumber = 1,
    kRespectFieldNumber = 2,
    kFamiliarFieldNumber = 3,
    kFlirtatiousFieldNumber = 4,
    kAttractionFieldNumber = 5,
  };
  // int32 trust = 1;
  void clear_trust();
  ::PROTOBUF_NAMESPACE_ID::int32 trust() const;
  void set_trust(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trust() const;
  void _internal_set_trust(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 respect = 2;
  void clear_respect();
  ::PROTOBUF_NAMESPACE_ID::int32 respect() const;
  void set_respect(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_respect() const;
  void _internal_set_respect(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 familiar = 3;
  void clear_familiar();
  ::PROTOBUF_NAMESPACE_ID::int32 familiar() const;
  void set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_familiar() const;
  void _internal_set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 flirtatious = 4;
  void clear_flirtatious();
  ::PROTOBUF_NAMESPACE_ID::int32 flirtatious() const;
  void set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flirtatious() const;
  void _internal_set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attraction = 5;
  void clear_attraction();
  ::PROTOBUF_NAMESPACE_ID::int32 attraction() const;
  void set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attraction() const;
  void _internal_set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo.RelationAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 trust_;
  ::PROTOBUF_NAMESPACE_ID::int32 respect_;
  ::PROTOBUF_NAMESPACE_ID::int32 familiar_;
  ::PROTOBUF_NAMESPACE_ID::int32 flirtatious_;
  ::PROTOBUF_NAMESPACE_ID::int32 attraction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo) */ {
 public:
  inline RelationInfo() : RelationInfo(nullptr) {}
  virtual ~RelationInfo();

  RelationInfo(const RelationInfo& from);
  RelationInfo(RelationInfo&& from) noexcept
    : RelationInfo() {
    *this = ::std::move(from);
  }

  inline RelationInfo& operator=(const RelationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo& operator=(RelationInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationInfo& default_instance();

  static inline const RelationInfo* internal_default_instance() {
    return reinterpret_cast<const RelationInfo*>(
               &_RelationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RelationInfo& a, RelationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationInfo* New() const final {
    return CreateMaybeMessage<RelationInfo>(nullptr);
  }

  RelationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationInfo& from);
  void MergeFrom(const RelationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo";
  }
  protected:
  explicit RelationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RelationInfo_RelationAttributes RelationAttributes;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationStateFieldNumber = 1,
    kRelationUpdateFieldNumber = 2,
  };
  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
  bool has_relation_state() const;
  private:
  bool _internal_has_relation_state() const;
  public:
  void clear_relation_state();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_state();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_state();
  void set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_state();
  public:
  void unsafe_arena_set_allocated_relation_state(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_state();

  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
  bool has_relation_update() const;
  private:
  bool _internal_has_relation_update() const;
  public:
  void clear_relation_update();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_update();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_update();
  void set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_update();
  public:
  void unsafe_arena_set_allocated_relation_update(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_update();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state_;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LatencyReportEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LatencyReportEvent) */ {
 public:
  inline LatencyReportEvent() : LatencyReportEvent(nullptr) {}
  virtual ~LatencyReportEvent();

  LatencyReportEvent(const LatencyReportEvent& from);
  LatencyReportEvent(LatencyReportEvent&& from) noexcept
    : LatencyReportEvent() {
    *this = ::std::move(from);
  }

  inline LatencyReportEvent& operator=(const LatencyReportEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatencyReportEvent& operator=(LatencyReportEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatencyReportEvent& default_instance();

  enum ReportCase {
    kPingPong = 1,
    kPerceivedLatency = 2,
    REPORT_NOT_SET = 0,
  };

  static inline const LatencyReportEvent* internal_default_instance() {
    return reinterpret_cast<const LatencyReportEvent*>(
               &_LatencyReportEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LatencyReportEvent& a, LatencyReportEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LatencyReportEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatencyReportEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatencyReportEvent* New() const final {
    return CreateMaybeMessage<LatencyReportEvent>(nullptr);
  }

  LatencyReportEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatencyReportEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatencyReportEvent& from);
  void MergeFrom(const LatencyReportEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatencyReportEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LatencyReportEvent";
  }
  protected:
  explicit LatencyReportEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingPongFieldNumber = 1,
    kPerceivedLatencyFieldNumber = 2,
  };
  // .ai.inworld.packets.PingPongReport ping_pong = 1;
  bool has_ping_pong() const;
  private:
  bool _internal_has_ping_pong() const;
  public:
  void clear_ping_pong();
  const ::ai::inworld::packets::PingPongReport& ping_pong() const;
  ::ai::inworld::packets::PingPongReport* release_ping_pong();
  ::ai::inworld::packets::PingPongReport* mutable_ping_pong();
  void set_allocated_ping_pong(::ai::inworld::packets::PingPongReport* ping_pong);
  private:
  const ::ai::inworld::packets::PingPongReport& _internal_ping_pong() const;
  ::ai::inworld::packets::PingPongReport* _internal_mutable_ping_pong();
  public:
  void unsafe_arena_set_allocated_ping_pong(
      ::ai::inworld::packets::PingPongReport* ping_pong);
  ::ai::inworld::packets::PingPongReport* unsafe_arena_release_ping_pong();

  // .ai.inworld.packets.PerceivedLatencyReport perceived_latency = 2;
  bool has_perceived_latency() const;
  private:
  bool _internal_has_perceived_latency() const;
  public:
  void clear_perceived_latency();
  const ::ai::inworld::packets::PerceivedLatencyReport& perceived_latency() const;
  ::ai::inworld::packets::PerceivedLatencyReport* release_perceived_latency();
  ::ai::inworld::packets::PerceivedLatencyReport* mutable_perceived_latency();
  void set_allocated_perceived_latency(::ai::inworld::packets::PerceivedLatencyReport* perceived_latency);
  private:
  const ::ai::inworld::packets::PerceivedLatencyReport& _internal_perceived_latency() const;
  ::ai::inworld::packets::PerceivedLatencyReport* _internal_mutable_perceived_latency();
  public:
  void unsafe_arena_set_allocated_perceived_latency(
      ::ai::inworld::packets::PerceivedLatencyReport* perceived_latency);
  ::ai::inworld::packets::PerceivedLatencyReport* unsafe_arena_release_perceived_latency();

  void clear_report();
  ReportCase report_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LatencyReportEvent)
 private:
  class _Internal;
  void set_has_ping_pong();
  void set_has_perceived_latency();

  inline bool has_report() const;
  inline void clear_has_report();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ReportUnion {
    ReportUnion() {}
    ::ai::inworld::packets::PingPongReport* ping_pong_;
    ::ai::inworld::packets::PerceivedLatencyReport* perceived_latency_;
  } report_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class PingPongReport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PingPongReport) */ {
 public:
  inline PingPongReport() : PingPongReport(nullptr) {}
  virtual ~PingPongReport();

  PingPongReport(const PingPongReport& from);
  PingPongReport(PingPongReport&& from) noexcept
    : PingPongReport() {
    *this = ::std::move(from);
  }

  inline PingPongReport& operator=(const PingPongReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingPongReport& operator=(PingPongReport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PingPongReport& default_instance();

  static inline const PingPongReport* internal_default_instance() {
    return reinterpret_cast<const PingPongReport*>(
               &_PingPongReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PingPongReport& a, PingPongReport& b) {
    a.Swap(&b);
  }
  inline void Swap(PingPongReport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingPongReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingPongReport* New() const final {
    return CreateMaybeMessage<PingPongReport>(nullptr);
  }

  PingPongReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingPongReport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PingPongReport& from);
  void MergeFrom(const PingPongReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingPongReport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PingPongReport";
  }
  protected:
  explicit PingPongReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PingPongReport_Type Type;
  static constexpr Type UNSPECIFIED =
    PingPongReport_Type_UNSPECIFIED;
  static constexpr Type PING =
    PingPongReport_Type_PING;
  static constexpr Type PONG =
    PingPongReport_Type_PONG;
  static inline bool Type_IsValid(int value) {
    return PingPongReport_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PingPongReport_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PingPongReport_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PingPongReport_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PingPongReport_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PingPongReport_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return PingPongReport_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPingPacketIdFieldNumber = 2,
    kPingTimestampFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .ai.inworld.packets.PacketId ping_packet_id = 2;
  bool has_ping_packet_id() const;
  private:
  bool _internal_has_ping_packet_id() const;
  public:
  void clear_ping_packet_id();
  const ::ai::inworld::packets::PacketId& ping_packet_id() const;
  ::ai::inworld::packets::PacketId* release_ping_packet_id();
  ::ai::inworld::packets::PacketId* mutable_ping_packet_id();
  void set_allocated_ping_packet_id(::ai::inworld::packets::PacketId* ping_packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_ping_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_ping_packet_id();
  public:
  void unsafe_arena_set_allocated_ping_packet_id(
      ::ai::inworld::packets::PacketId* ping_packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_ping_packet_id();

  // .google.protobuf.Timestamp ping_timestamp = 3;
  bool has_ping_timestamp() const;
  private:
  bool _internal_has_ping_timestamp() const;
  public:
  void clear_ping_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& ping_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_ping_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_ping_timestamp();
  void set_allocated_ping_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* ping_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_ping_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_ping_timestamp();
  public:
  void unsafe_arena_set_allocated_ping_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* ping_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_ping_timestamp();

  // .ai.inworld.packets.PingPongReport.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::PingPongReport_Type type() const;
  void set_type(::ai::inworld::packets::PingPongReport_Type value);
  private:
  ::ai::inworld::packets::PingPongReport_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::PingPongReport_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PingPongReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::PacketId* ping_packet_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* ping_timestamp_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class PerceivedLatencyReport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PerceivedLatencyReport) */ {
 public:
  inline PerceivedLatencyReport() : PerceivedLatencyReport(nullptr) {}
  virtual ~PerceivedLatencyReport();

  PerceivedLatencyReport(const PerceivedLatencyReport& from);
  PerceivedLatencyReport(PerceivedLatencyReport&& from) noexcept
    : PerceivedLatencyReport() {
    *this = ::std::move(from);
  }

  inline PerceivedLatencyReport& operator=(const PerceivedLatencyReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerceivedLatencyReport& operator=(PerceivedLatencyReport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PerceivedLatencyReport& default_instance();

  static inline const PerceivedLatencyReport* internal_default_instance() {
    return reinterpret_cast<const PerceivedLatencyReport*>(
               &_PerceivedLatencyReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PerceivedLatencyReport& a, PerceivedLatencyReport& b) {
    a.Swap(&b);
  }
  inline void Swap(PerceivedLatencyReport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerceivedLatencyReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PerceivedLatencyReport* New() const final {
    return CreateMaybeMessage<PerceivedLatencyReport>(nullptr);
  }

  PerceivedLatencyReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PerceivedLatencyReport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PerceivedLatencyReport& from);
  void MergeFrom(const PerceivedLatencyReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceivedLatencyReport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PerceivedLatencyReport";
  }
  protected:
  explicit PerceivedLatencyReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PerceivedLatencyReport_Precision Precision;
  static constexpr Precision UNSPECIFIED =
    PerceivedLatencyReport_Precision_UNSPECIFIED;
  static constexpr Precision FINE =
    PerceivedLatencyReport_Precision_FINE;
  static constexpr Precision ESTIMATED =
    PerceivedLatencyReport_Precision_ESTIMATED;
  static constexpr Precision PUSH_TO_TALK =
    PerceivedLatencyReport_Precision_PUSH_TO_TALK;
  static constexpr Precision NON_SPEECH =
    PerceivedLatencyReport_Precision_NON_SPEECH;
  static inline bool Precision_IsValid(int value) {
    return PerceivedLatencyReport_Precision_IsValid(value);
  }
  static constexpr Precision Precision_MIN =
    PerceivedLatencyReport_Precision_Precision_MIN;
  static constexpr Precision Precision_MAX =
    PerceivedLatencyReport_Precision_Precision_MAX;
  static constexpr int Precision_ARRAYSIZE =
    PerceivedLatencyReport_Precision_Precision_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Precision_descriptor() {
    return PerceivedLatencyReport_Precision_descriptor();
  }
  template<typename T>
  static inline const std::string& Precision_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Precision>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Precision_Name.");
    return PerceivedLatencyReport_Precision_Name(enum_t_value);
  }
  static inline bool Precision_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Precision* value) {
    return PerceivedLatencyReport_Precision_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLatencyFieldNumber = 2,
    kPrecisionFieldNumber = 1,
  };
  // .google.protobuf.Duration latency = 2;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  const PROTOBUF_NAMESPACE_ID::Duration& latency() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_latency();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_latency();
  void set_allocated_latency(PROTOBUF_NAMESPACE_ID::Duration* latency);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_latency() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_latency();
  public:
  void unsafe_arena_set_allocated_latency(
      PROTOBUF_NAMESPACE_ID::Duration* latency);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_latency();

  // .ai.inworld.packets.PerceivedLatencyReport.Precision precision = 1;
  void clear_precision();
  ::ai::inworld::packets::PerceivedLatencyReport_Precision precision() const;
  void set_precision(::ai::inworld::packets::PerceivedLatencyReport_Precision value);
  private:
  ::ai::inworld::packets::PerceivedLatencyReport_Precision _internal_precision() const;
  void _internal_set_precision(::ai::inworld::packets::PerceivedLatencyReport_Precision value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PerceivedLatencyReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Duration* latency_;
  int precision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LogsEvent_LogDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LogsEvent.LogDetail) */ {
 public:
  inline LogsEvent_LogDetail() : LogsEvent_LogDetail(nullptr) {}
  virtual ~LogsEvent_LogDetail();

  LogsEvent_LogDetail(const LogsEvent_LogDetail& from);
  LogsEvent_LogDetail(LogsEvent_LogDetail&& from) noexcept
    : LogsEvent_LogDetail() {
    *this = ::std::move(from);
  }

  inline LogsEvent_LogDetail& operator=(const LogsEvent_LogDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogsEvent_LogDetail& operator=(LogsEvent_LogDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogsEvent_LogDetail& default_instance();

  static inline const LogsEvent_LogDetail* internal_default_instance() {
    return reinterpret_cast<const LogsEvent_LogDetail*>(
               &_LogsEvent_LogDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LogsEvent_LogDetail& a, LogsEvent_LogDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(LogsEvent_LogDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogsEvent_LogDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogsEvent_LogDetail* New() const final {
    return CreateMaybeMessage<LogsEvent_LogDetail>(nullptr);
  }

  LogsEvent_LogDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogsEvent_LogDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogsEvent_LogDetail& from);
  void MergeFrom(const LogsEvent_LogDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogsEvent_LogDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LogsEvent.LogDetail";
  }
  protected:
  explicit LogsEvent_LogDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kDetailFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .google.protobuf.Value detail = 2;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const PROTOBUF_NAMESPACE_ID::Value& detail() const;
  PROTOBUF_NAMESPACE_ID::Value* release_detail();
  PROTOBUF_NAMESPACE_ID::Value* mutable_detail();
  void set_allocated_detail(PROTOBUF_NAMESPACE_ID::Value* detail);
  private:
  const PROTOBUF_NAMESPACE_ID::Value& _internal_detail() const;
  PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_detail();
  public:
  void unsafe_arena_set_allocated_detail(
      PROTOBUF_NAMESPACE_ID::Value* detail);
  PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_detail();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LogsEvent.LogDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  PROTOBUF_NAMESPACE_ID::Value* detail_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LogsEvent_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogsEvent_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LogsEvent_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LogsEvent_MetadataEntry_DoNotUse();
  explicit LogsEvent_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LogsEvent_MetadataEntry_DoNotUse& other);
  static const LogsEvent_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogsEvent_MetadataEntry_DoNotUse*>(&_LogsEvent_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ai.inworld.packets.LogsEvent.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ai.inworld.packets.LogsEvent.MetadataEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[23];
  }

  public:
};

// -------------------------------------------------------------------

class LogsEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LogsEvent) */ {
 public:
  inline LogsEvent() : LogsEvent(nullptr) {}
  virtual ~LogsEvent();

  LogsEvent(const LogsEvent& from);
  LogsEvent(LogsEvent&& from) noexcept
    : LogsEvent() {
    *this = ::std::move(from);
  }

  inline LogsEvent& operator=(const LogsEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogsEvent& operator=(LogsEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogsEvent& default_instance();

  static inline const LogsEvent* internal_default_instance() {
    return reinterpret_cast<const LogsEvent*>(
               &_LogsEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LogsEvent& a, LogsEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LogsEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogsEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogsEvent* New() const final {
    return CreateMaybeMessage<LogsEvent>(nullptr);
  }

  LogsEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogsEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogsEvent& from);
  void MergeFrom(const LogsEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogsEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LogsEvent";
  }
  protected:
  explicit LogsEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LogsEvent_LogDetail LogDetail;

  typedef LogsEvent_LogLevel LogLevel;
  static constexpr LogLevel UNSPECIFIED =
    LogsEvent_LogLevel_UNSPECIFIED;
  static constexpr LogLevel WARNING =
    LogsEvent_LogLevel_WARNING;
  static constexpr LogLevel INFO =
    LogsEvent_LogLevel_INFO;
  static constexpr LogLevel DEBUG =
    LogsEvent_LogLevel_DEBUG;
  static constexpr LogLevel INTERNAL =
    LogsEvent_LogLevel_INTERNAL;
  static inline bool LogLevel_IsValid(int value) {
    return LogsEvent_LogLevel_IsValid(value);
  }
  static constexpr LogLevel LogLevel_MIN =
    LogsEvent_LogLevel_LogLevel_MIN;
  static constexpr LogLevel LogLevel_MAX =
    LogsEvent_LogLevel_LogLevel_MAX;
  static constexpr int LogLevel_ARRAYSIZE =
    LogsEvent_LogLevel_LogLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogLevel_descriptor() {
    return LogsEvent_LogLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& LogLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogLevel_Name.");
    return LogsEvent_LogLevel_Name(enum_t_value);
  }
  static inline bool LogLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogLevel* value) {
    return LogsEvent_LogLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kDetailsFieldNumber = 4,
    kTextFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // map<string, string> metadata = 3 [deprecated = true];
  PROTOBUF_DEPRECATED int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // repeated .ai.inworld.packets.LogsEvent.LogDetail details = 4;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  ::ai::inworld::packets::LogsEvent_LogDetail* mutable_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LogsEvent_LogDetail >*
      mutable_details();
  private:
  const ::ai::inworld::packets::LogsEvent_LogDetail& _internal_details(int index) const;
  ::ai::inworld::packets::LogsEvent_LogDetail* _internal_add_details();
  public:
  const ::ai::inworld::packets::LogsEvent_LogDetail& details(int index) const;
  ::ai::inworld::packets::LogsEvent_LogDetail* add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LogsEvent_LogDetail >&
      details() const;

  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.LogsEvent.LogLevel level = 2;
  void clear_level();
  ::ai::inworld::packets::LogsEvent_LogLevel level() const;
  void set_level(::ai::inworld::packets::LogsEvent_LogLevel value);
  private:
  ::ai::inworld::packets::LogsEvent_LogLevel _internal_level() const;
  void _internal_set_level(::ai::inworld::packets::LogsEvent_LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LogsEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LogsEvent_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LogsEvent_LogDetail > details_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class MutationEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.MutationEvent) */ {
 public:
  inline MutationEvent() : MutationEvent(nullptr) {}
  virtual ~MutationEvent();

  MutationEvent(const MutationEvent& from);
  MutationEvent(MutationEvent&& from) noexcept
    : MutationEvent() {
    *this = ::std::move(from);
  }

  inline MutationEvent& operator=(const MutationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationEvent& operator=(MutationEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutationEvent& default_instance();

  enum MutationCase {
    kCancelResponses = 1,
    kRegenerateResponse = 2,
    kApplyResponse = 3,
    kLoadScene = 4,
    kModifyExactResponse = 5,
    kLoadCharacters = 6,
    kUnloadCharacters = 7,
    MUTATION_NOT_SET = 0,
  };

  static inline const MutationEvent* internal_default_instance() {
    return reinterpret_cast<const MutationEvent*>(
               &_MutationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MutationEvent& a, MutationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutationEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutationEvent* New() const final {
    return CreateMaybeMessage<MutationEvent>(nullptr);
  }

  MutationEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutationEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutationEvent& from);
  void MergeFrom(const MutationEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.MutationEvent";
  }
  protected:
  explicit MutationEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancelResponsesFieldNumber = 1,
    kRegenerateResponseFieldNumber = 2,
    kApplyResponseFieldNumber = 3,
    kLoadSceneFieldNumber = 4,
    kModifyExactResponseFieldNumber = 5,
    kLoadCharactersFieldNumber = 6,
    kUnloadCharactersFieldNumber = 7,
  };
  // .ai.inworld.packets.CancelResponses cancel_responses = 1;
  bool has_cancel_responses() const;
  private:
  bool _internal_has_cancel_responses() const;
  public:
  void clear_cancel_responses();
  const ::ai::inworld::packets::CancelResponses& cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* release_cancel_responses();
  ::ai::inworld::packets::CancelResponses* mutable_cancel_responses();
  void set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses);
  private:
  const ::ai::inworld::packets::CancelResponses& _internal_cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* _internal_mutable_cancel_responses();
  public:
  void unsafe_arena_set_allocated_cancel_responses(
      ::ai::inworld::packets::CancelResponses* cancel_responses);
  ::ai::inworld::packets::CancelResponses* unsafe_arena_release_cancel_responses();

  // .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
  bool has_regenerate_response() const;
  private:
  bool _internal_has_regenerate_response() const;
  public:
  void clear_regenerate_response();
  const ::ai::inworld::packets::RegenerateResponse& regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* release_regenerate_response();
  ::ai::inworld::packets::RegenerateResponse* mutable_regenerate_response();
  void set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response);
  private:
  const ::ai::inworld::packets::RegenerateResponse& _internal_regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* _internal_mutable_regenerate_response();
  public:
  void unsafe_arena_set_allocated_regenerate_response(
      ::ai::inworld::packets::RegenerateResponse* regenerate_response);
  ::ai::inworld::packets::RegenerateResponse* unsafe_arena_release_regenerate_response();

  // .ai.inworld.packets.ApplyResponse apply_response = 3;
  bool has_apply_response() const;
  private:
  bool _internal_has_apply_response() const;
  public:
  void clear_apply_response();
  const ::ai::inworld::packets::ApplyResponse& apply_response() const;
  ::ai::inworld::packets::ApplyResponse* release_apply_response();
  ::ai::inworld::packets::ApplyResponse* mutable_apply_response();
  void set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response);
  private:
  const ::ai::inworld::packets::ApplyResponse& _internal_apply_response() const;
  ::ai::inworld::packets::ApplyResponse* _internal_mutable_apply_response();
  public:
  void unsafe_arena_set_allocated_apply_response(
      ::ai::inworld::packets::ApplyResponse* apply_response);
  ::ai::inworld::packets::ApplyResponse* unsafe_arena_release_apply_response();

  // .ai.inworld.packets.LoadScene load_scene = 4;
  bool has_load_scene() const;
  private:
  bool _internal_has_load_scene() const;
  public:
  void clear_load_scene();
  const ::ai::inworld::packets::LoadScene& load_scene() const;
  ::ai::inworld::packets::LoadScene* release_load_scene();
  ::ai::inworld::packets::LoadScene* mutable_load_scene();
  void set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene);
  private:
  const ::ai::inworld::packets::LoadScene& _internal_load_scene() const;
  ::ai::inworld::packets::LoadScene* _internal_mutable_load_scene();
  public:
  void unsafe_arena_set_allocated_load_scene(
      ::ai::inworld::packets::LoadScene* load_scene);
  ::ai::inworld::packets::LoadScene* unsafe_arena_release_load_scene();

  // .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
  bool has_modify_exact_response() const;
  private:
  bool _internal_has_modify_exact_response() const;
  public:
  void clear_modify_exact_response();
  const ::ai::inworld::packets::ModifyExactResponse& modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* release_modify_exact_response();
  ::ai::inworld::packets::ModifyExactResponse* mutable_modify_exact_response();
  void set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  private:
  const ::ai::inworld::packets::ModifyExactResponse& _internal_modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* _internal_mutable_modify_exact_response();
  public:
  void unsafe_arena_set_allocated_modify_exact_response(
      ::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  ::ai::inworld::packets::ModifyExactResponse* unsafe_arena_release_modify_exact_response();

  // .ai.inworld.packets.LoadCharacters load_characters = 6;
  bool has_load_characters() const;
  private:
  bool _internal_has_load_characters() const;
  public:
  void clear_load_characters();
  const ::ai::inworld::packets::LoadCharacters& load_characters() const;
  ::ai::inworld::packets::LoadCharacters* release_load_characters();
  ::ai::inworld::packets::LoadCharacters* mutable_load_characters();
  void set_allocated_load_characters(::ai::inworld::packets::LoadCharacters* load_characters);
  private:
  const ::ai::inworld::packets::LoadCharacters& _internal_load_characters() const;
  ::ai::inworld::packets::LoadCharacters* _internal_mutable_load_characters();
  public:
  void unsafe_arena_set_allocated_load_characters(
      ::ai::inworld::packets::LoadCharacters* load_characters);
  ::ai::inworld::packets::LoadCharacters* unsafe_arena_release_load_characters();

  // .ai.inworld.packets.UnloadCharacters unload_characters = 7;
  bool has_unload_characters() const;
  private:
  bool _internal_has_unload_characters() const;
  public:
  void clear_unload_characters();
  const ::ai::inworld::packets::UnloadCharacters& unload_characters() const;
  ::ai::inworld::packets::UnloadCharacters* release_unload_characters();
  ::ai::inworld::packets::UnloadCharacters* mutable_unload_characters();
  void set_allocated_unload_characters(::ai::inworld::packets::UnloadCharacters* unload_characters);
  private:
  const ::ai::inworld::packets::UnloadCharacters& _internal_unload_characters() const;
  ::ai::inworld::packets::UnloadCharacters* _internal_mutable_unload_characters();
  public:
  void unsafe_arena_set_allocated_unload_characters(
      ::ai::inworld::packets::UnloadCharacters* unload_characters);
  ::ai::inworld::packets::UnloadCharacters* unsafe_arena_release_unload_characters();

  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.MutationEvent)
 private:
  class _Internal;
  void set_has_cancel_responses();
  void set_has_regenerate_response();
  void set_has_apply_response();
  void set_has_load_scene();
  void set_has_modify_exact_response();
  void set_has_load_characters();
  void set_has_unload_characters();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MutationUnion {
    MutationUnion() {}
    ::ai::inworld::packets::CancelResponses* cancel_responses_;
    ::ai::inworld::packets::RegenerateResponse* regenerate_response_;
    ::ai::inworld::packets::ApplyResponse* apply_response_;
    ::ai::inworld::packets::LoadScene* load_scene_;
    ::ai::inworld::packets::ModifyExactResponse* modify_exact_response_;
    ::ai::inworld::packets::LoadCharacters* load_characters_;
    ::ai::inworld::packets::UnloadCharacters* unload_characters_;
  } mutation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionControlResponseEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionControlResponseEvent) */ {
 public:
  inline SessionControlResponseEvent() : SessionControlResponseEvent(nullptr) {}
  virtual ~SessionControlResponseEvent();

  SessionControlResponseEvent(const SessionControlResponseEvent& from);
  SessionControlResponseEvent(SessionControlResponseEvent&& from) noexcept
    : SessionControlResponseEvent() {
    *this = ::std::move(from);
  }

  inline SessionControlResponseEvent& operator=(const SessionControlResponseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionControlResponseEvent& operator=(SessionControlResponseEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionControlResponseEvent& default_instance();

  enum ResponseCase {
    kLoadedScene = 1,
    kLoadedCharacters = 2,
    kSessionHistory = 3,
    RESPONSE_NOT_SET = 0,
  };

  static inline const SessionControlResponseEvent* internal_default_instance() {
    return reinterpret_cast<const SessionControlResponseEvent*>(
               &_SessionControlResponseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SessionControlResponseEvent& a, SessionControlResponseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionControlResponseEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionControlResponseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionControlResponseEvent* New() const final {
    return CreateMaybeMessage<SessionControlResponseEvent>(nullptr);
  }

  SessionControlResponseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionControlResponseEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionControlResponseEvent& from);
  void MergeFrom(const SessionControlResponseEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionControlResponseEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionControlResponseEvent";
  }
  protected:
  explicit SessionControlResponseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadedSceneFieldNumber = 1,
    kLoadedCharactersFieldNumber = 2,
    kSessionHistoryFieldNumber = 3,
  };
  // .ai.inworld.packets.LoadedScene loaded_scene = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_loaded_scene() const;
  private:
  bool _internal_has_loaded_scene() const;
  public:
  PROTOBUF_DEPRECATED void clear_loaded_scene();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::LoadedScene& loaded_scene() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedScene* release_loaded_scene();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedScene* mutable_loaded_scene();
  PROTOBUF_DEPRECATED void set_allocated_loaded_scene(::ai::inworld::packets::LoadedScene* loaded_scene);
  private:
  const ::ai::inworld::packets::LoadedScene& _internal_loaded_scene() const;
  ::ai::inworld::packets::LoadedScene* _internal_mutable_loaded_scene();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_loaded_scene(
      ::ai::inworld::packets::LoadedScene* loaded_scene);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedScene* unsafe_arena_release_loaded_scene();

  // .ai.inworld.packets.LoadedCharacters loaded_characters = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_loaded_characters() const;
  private:
  bool _internal_has_loaded_characters() const;
  public:
  PROTOBUF_DEPRECATED void clear_loaded_characters();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::LoadedCharacters& loaded_characters() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedCharacters* release_loaded_characters();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedCharacters* mutable_loaded_characters();
  PROTOBUF_DEPRECATED void set_allocated_loaded_characters(::ai::inworld::packets::LoadedCharacters* loaded_characters);
  private:
  const ::ai::inworld::packets::LoadedCharacters& _internal_loaded_characters() const;
  ::ai::inworld::packets::LoadedCharacters* _internal_mutable_loaded_characters();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_loaded_characters(
      ::ai::inworld::packets::LoadedCharacters* loaded_characters);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::LoadedCharacters* unsafe_arena_release_loaded_characters();

  // .ai.inworld.packets.SessionHistoryResponse session_history = 3;
  bool has_session_history() const;
  private:
  bool _internal_has_session_history() const;
  public:
  void clear_session_history();
  const ::ai::inworld::packets::SessionHistoryResponse& session_history() const;
  ::ai::inworld::packets::SessionHistoryResponse* release_session_history();
  ::ai::inworld::packets::SessionHistoryResponse* mutable_session_history();
  void set_allocated_session_history(::ai::inworld::packets::SessionHistoryResponse* session_history);
  private:
  const ::ai::inworld::packets::SessionHistoryResponse& _internal_session_history() const;
  ::ai::inworld::packets::SessionHistoryResponse* _internal_mutable_session_history();
  public:
  void unsafe_arena_set_allocated_session_history(
      ::ai::inworld::packets::SessionHistoryResponse* session_history);
  ::ai::inworld::packets::SessionHistoryResponse* unsafe_arena_release_session_history();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionControlResponseEvent)
 private:
  class _Internal;
  void set_has_loaded_scene();
  void set_has_loaded_characters();
  void set_has_session_history();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    ResponseUnion() {}
    ::ai::inworld::packets::LoadedScene* loaded_scene_;
    ::ai::inworld::packets::LoadedCharacters* loaded_characters_;
    ::ai::inworld::packets::SessionHistoryResponse* session_history_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponses PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponses) */ {
 public:
  inline CancelResponses() : CancelResponses(nullptr) {}
  virtual ~CancelResponses();

  CancelResponses(const CancelResponses& from);
  CancelResponses(CancelResponses&& from) noexcept
    : CancelResponses() {
    *this = ::std::move(from);
  }

  inline CancelResponses& operator=(const CancelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponses& operator=(CancelResponses&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelResponses& default_instance();

  static inline const CancelResponses* internal_default_instance() {
    return reinterpret_cast<const CancelResponses*>(
               &_CancelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CancelResponses& a, CancelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponses* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelResponses* New() const final {
    return CreateMaybeMessage<CancelResponses>(nullptr);
  }

  CancelResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelResponses>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelResponses& from);
  void MergeFrom(const CancelResponses& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponses* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponses";
  }
  protected:
  explicit CancelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class RegenerateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RegenerateResponse) */ {
 public:
  inline RegenerateResponse() : RegenerateResponse(nullptr) {}
  virtual ~RegenerateResponse();

  RegenerateResponse(const RegenerateResponse& from);
  RegenerateResponse(RegenerateResponse&& from) noexcept
    : RegenerateResponse() {
    *this = ::std::move(from);
  }

  inline RegenerateResponse& operator=(const RegenerateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegenerateResponse& operator=(RegenerateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegenerateResponse& default_instance();

  static inline const RegenerateResponse* internal_default_instance() {
    return reinterpret_cast<const RegenerateResponse*>(
               &_RegenerateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RegenerateResponse& a, RegenerateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegenerateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegenerateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegenerateResponse* New() const final {
    return CreateMaybeMessage<RegenerateResponse>(nullptr);
  }

  RegenerateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegenerateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegenerateResponse& from);
  void MergeFrom(const RegenerateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegenerateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RegenerateResponse";
  }
  protected:
  explicit RegenerateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RegenerateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ApplyResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ApplyResponse) */ {
 public:
  inline ApplyResponse() : ApplyResponse(nullptr) {}
  virtual ~ApplyResponse();

  ApplyResponse(const ApplyResponse& from);
  ApplyResponse(ApplyResponse&& from) noexcept
    : ApplyResponse() {
    *this = ::std::move(from);
  }

  inline ApplyResponse& operator=(const ApplyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyResponse& operator=(ApplyResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ApplyResponse& default_instance();

  static inline const ApplyResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyResponse*>(
               &_ApplyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ApplyResponse& a, ApplyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyResponse* New() const final {
    return CreateMaybeMessage<ApplyResponse>(nullptr);
  }

  ApplyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplyResponse& from);
  void MergeFrom(const ApplyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ApplyResponse";
  }
  protected:
  explicit ApplyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ApplyResponse_ApplyResponseType ApplyResponseType;
  static constexpr ApplyResponseType APPLY_RESPONSE_TYPE_DEFAULT =
    ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_DEFAULT;
  static constexpr ApplyResponseType APPLY_RESPONSE_TYPE_COMMIT =
    ApplyResponse_ApplyResponseType_APPLY_RESPONSE_TYPE_COMMIT;
  static inline bool ApplyResponseType_IsValid(int value) {
    return ApplyResponse_ApplyResponseType_IsValid(value);
  }
  static constexpr ApplyResponseType ApplyResponseType_MIN =
    ApplyResponse_ApplyResponseType_ApplyResponseType_MIN;
  static constexpr ApplyResponseType ApplyResponseType_MAX =
    ApplyResponse_ApplyResponseType_ApplyResponseType_MAX;
  static constexpr int ApplyResponseType_ARRAYSIZE =
    ApplyResponse_ApplyResponseType_ApplyResponseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ApplyResponseType_descriptor() {
    return ApplyResponse_ApplyResponseType_descriptor();
  }
  template<typename T>
  static inline const std::string& ApplyResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ApplyResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ApplyResponseType_Name.");
    return ApplyResponse_ApplyResponseType_Name(enum_t_value);
  }
  static inline bool ApplyResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ApplyResponseType* value) {
    return ApplyResponse_ApplyResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kApplyResponseTypeFieldNumber = 2,
  };
  // .ai.inworld.packets.PacketId packet_id = 1;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // .ai.inworld.packets.ApplyResponse.ApplyResponseType apply_response_type = 2;
  void clear_apply_response_type();
  ::ai::inworld::packets::ApplyResponse_ApplyResponseType apply_response_type() const;
  void set_apply_response_type(::ai::inworld::packets::ApplyResponse_ApplyResponseType value);
  private:
  ::ai::inworld::packets::ApplyResponse_ApplyResponseType _internal_apply_response_type() const;
  void _internal_set_apply_response_type(::ai::inworld::packets::ApplyResponse_ApplyResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ApplyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::PacketId* packet_id_;
  int apply_response_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadScene PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadScene) */ {
 public:
  inline LoadScene() : LoadScene(nullptr) {}
  virtual ~LoadScene();

  LoadScene(const LoadScene& from);
  LoadScene(LoadScene&& from) noexcept
    : LoadScene() {
    *this = ::std::move(from);
  }

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScene& operator=(LoadScene&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadScene& default_instance();

  static inline const LoadScene* internal_default_instance() {
    return reinterpret_cast<const LoadScene*>(
               &_LoadScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(LoadScene& a, LoadScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScene* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadScene* New() const final {
    return CreateMaybeMessage<LoadScene>(nullptr);
  }

  LoadScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadScene>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadScene& from);
  void MergeFrom(const LoadScene& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadScene* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadScene";
  }
  protected:
  explicit LoadScene(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIsResetSceneFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool is_reset_scene = 2;
  void clear_is_reset_scene();
  bool is_reset_scene() const;
  void set_is_reset_scene(bool value);
  private:
  bool _internal_is_reset_scene() const;
  void _internal_set_is_reset_scene(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool is_reset_scene_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadedScene PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadedScene) */ {
 public:
  inline LoadedScene() : LoadedScene(nullptr) {}
  virtual ~LoadedScene();

  LoadedScene(const LoadedScene& from);
  LoadedScene(LoadedScene&& from) noexcept
    : LoadedScene() {
    *this = ::std::move(from);
  }

  inline LoadedScene& operator=(const LoadedScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadedScene& operator=(LoadedScene&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadedScene& default_instance();

  static inline const LoadedScene* internal_default_instance() {
    return reinterpret_cast<const LoadedScene*>(
               &_LoadedScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(LoadedScene& a, LoadedScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadedScene* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadedScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadedScene* New() const final {
    return CreateMaybeMessage<LoadedScene>(nullptr);
  }

  LoadedScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadedScene>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadedScene& from);
  void MergeFrom(const LoadedScene& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadedScene* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadedScene";
  }
  protected:
  explicit LoadedScene(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
    kSceneNameFieldNumber = 2,
    kSceneDescriptionFieldNumber = 3,
    kSceneDisplayNameFieldNumber = 4,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;

  // string scene_name = 2;
  void clear_scene_name();
  const std::string& scene_name() const;
  void set_scene_name(const std::string& value);
  void set_scene_name(std::string&& value);
  void set_scene_name(const char* value);
  void set_scene_name(const char* value, size_t size);
  std::string* mutable_scene_name();
  std::string* release_scene_name();
  void set_allocated_scene_name(std::string* scene_name);
  private:
  const std::string& _internal_scene_name() const;
  void _internal_set_scene_name(const std::string& value);
  std::string* _internal_mutable_scene_name();
  public:

  // string scene_description = 3;
  void clear_scene_description();
  const std::string& scene_description() const;
  void set_scene_description(const std::string& value);
  void set_scene_description(std::string&& value);
  void set_scene_description(const char* value);
  void set_scene_description(const char* value, size_t size);
  std::string* mutable_scene_description();
  std::string* release_scene_description();
  void set_allocated_scene_description(std::string* scene_description);
  private:
  const std::string& _internal_scene_description() const;
  void _internal_set_scene_description(const std::string& value);
  std::string* _internal_mutable_scene_description();
  public:

  // string scene_display_name = 4;
  void clear_scene_display_name();
  const std::string& scene_display_name() const;
  void set_scene_display_name(const std::string& value);
  void set_scene_display_name(std::string&& value);
  void set_scene_display_name(const char* value);
  void set_scene_display_name(const char* value, size_t size);
  std::string* mutable_scene_display_name();
  std::string* release_scene_display_name();
  void set_allocated_scene_display_name(std::string* scene_display_name);
  private:
  const std::string& _internal_scene_display_name() const;
  void _internal_set_scene_display_name(const std::string& value);
  std::string* _internal_mutable_scene_display_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadedScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_display_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadCharacters_CharacterName PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadCharacters.CharacterName) */ {
 public:
  inline LoadCharacters_CharacterName() : LoadCharacters_CharacterName(nullptr) {}
  virtual ~LoadCharacters_CharacterName();

  LoadCharacters_CharacterName(const LoadCharacters_CharacterName& from);
  LoadCharacters_CharacterName(LoadCharacters_CharacterName&& from) noexcept
    : LoadCharacters_CharacterName() {
    *this = ::std::move(from);
  }

  inline LoadCharacters_CharacterName& operator=(const LoadCharacters_CharacterName& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCharacters_CharacterName& operator=(LoadCharacters_CharacterName&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadCharacters_CharacterName& default_instance();

  static inline const LoadCharacters_CharacterName* internal_default_instance() {
    return reinterpret_cast<const LoadCharacters_CharacterName*>(
               &_LoadCharacters_CharacterName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LoadCharacters_CharacterName& a, LoadCharacters_CharacterName& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCharacters_CharacterName* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCharacters_CharacterName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadCharacters_CharacterName* New() const final {
    return CreateMaybeMessage<LoadCharacters_CharacterName>(nullptr);
  }

  LoadCharacters_CharacterName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadCharacters_CharacterName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadCharacters_CharacterName& from);
  void MergeFrom(const LoadCharacters_CharacterName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadCharacters_CharacterName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadCharacters.CharacterName";
  }
  protected:
  explicit LoadCharacters_CharacterName(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLanguageCodeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.language_codes.LanguageCode language_code = 2;
  void clear_language_code();
  ::ai::inworld::language_codes::LanguageCode language_code() const;
  void set_language_code(::ai::inworld::language_codes::LanguageCode value);
  private:
  ::ai::inworld::language_codes::LanguageCode _internal_language_code() const;
  void _internal_set_language_code(::ai::inworld::language_codes::LanguageCode value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadCharacters.CharacterName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int language_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadCharacters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadCharacters) */ {
 public:
  inline LoadCharacters() : LoadCharacters(nullptr) {}
  virtual ~LoadCharacters();

  LoadCharacters(const LoadCharacters& from);
  LoadCharacters(LoadCharacters&& from) noexcept
    : LoadCharacters() {
    *this = ::std::move(from);
  }

  inline LoadCharacters& operator=(const LoadCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCharacters& operator=(LoadCharacters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadCharacters& default_instance();

  static inline const LoadCharacters* internal_default_instance() {
    return reinterpret_cast<const LoadCharacters*>(
               &_LoadCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LoadCharacters& a, LoadCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCharacters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCharacters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadCharacters* New() const final {
    return CreateMaybeMessage<LoadCharacters>(nullptr);
  }

  LoadCharacters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadCharacters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadCharacters& from);
  void MergeFrom(const LoadCharacters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadCharacters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadCharacters";
  }
  protected:
  explicit LoadCharacters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadCharacters_CharacterName CharacterName;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadCharacters.CharacterName name = 1;
  int name_size() const;
  private:
  int _internal_name_size() const;
  public:
  void clear_name();
  ::ai::inworld::packets::LoadCharacters_CharacterName* mutable_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >*
      mutable_name();
  private:
  const ::ai::inworld::packets::LoadCharacters_CharacterName& _internal_name(int index) const;
  ::ai::inworld::packets::LoadCharacters_CharacterName* _internal_add_name();
  public:
  const ::ai::inworld::packets::LoadCharacters_CharacterName& name(int index) const;
  ::ai::inworld::packets::LoadCharacters_CharacterName* add_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >&
      name() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadCharacters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName > name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadedCharacters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadedCharacters) */ {
 public:
  inline LoadedCharacters() : LoadedCharacters(nullptr) {}
  virtual ~LoadedCharacters();

  LoadedCharacters(const LoadedCharacters& from);
  LoadedCharacters(LoadedCharacters&& from) noexcept
    : LoadedCharacters() {
    *this = ::std::move(from);
  }

  inline LoadedCharacters& operator=(const LoadedCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadedCharacters& operator=(LoadedCharacters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadedCharacters& default_instance();

  static inline const LoadedCharacters* internal_default_instance() {
    return reinterpret_cast<const LoadedCharacters*>(
               &_LoadedCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(LoadedCharacters& a, LoadedCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadedCharacters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadedCharacters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadedCharacters* New() const final {
    return CreateMaybeMessage<LoadedCharacters>(nullptr);
  }

  LoadedCharacters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadedCharacters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadedCharacters& from);
  void MergeFrom(const LoadedCharacters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadedCharacters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadedCharacters";
  }
  protected:
  explicit LoadedCharacters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
    kSceneNameFieldNumber = 2,
    kSceneDescriptionFieldNumber = 3,
    kSceneDisplayNameFieldNumber = 4,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;

  // string scene_name = 2;
  void clear_scene_name();
  const std::string& scene_name() const;
  void set_scene_name(const std::string& value);
  void set_scene_name(std::string&& value);
  void set_scene_name(const char* value);
  void set_scene_name(const char* value, size_t size);
  std::string* mutable_scene_name();
  std::string* release_scene_name();
  void set_allocated_scene_name(std::string* scene_name);
  private:
  const std::string& _internal_scene_name() const;
  void _internal_set_scene_name(const std::string& value);
  std::string* _internal_mutable_scene_name();
  public:

  // string scene_description = 3;
  void clear_scene_description();
  const std::string& scene_description() const;
  void set_scene_description(const std::string& value);
  void set_scene_description(std::string&& value);
  void set_scene_description(const char* value);
  void set_scene_description(const char* value, size_t size);
  std::string* mutable_scene_description();
  std::string* release_scene_description();
  void set_allocated_scene_description(std::string* scene_description);
  private:
  const std::string& _internal_scene_description() const;
  void _internal_set_scene_description(const std::string& value);
  std::string* _internal_mutable_scene_description();
  public:

  // string scene_display_name = 4;
  void clear_scene_display_name();
  const std::string& scene_display_name() const;
  void set_scene_display_name(const std::string& value);
  void set_scene_display_name(std::string&& value);
  void set_scene_display_name(const char* value);
  void set_scene_display_name(const char* value, size_t size);
  std::string* mutable_scene_display_name();
  std::string* release_scene_display_name();
  void set_allocated_scene_display_name(std::string* scene_display_name);
  private:
  const std::string& _internal_scene_display_name() const;
  void _internal_set_scene_display_name(const std::string& value);
  std::string* _internal_mutable_scene_display_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadedCharacters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_display_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class UnloadCharacters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.UnloadCharacters) */ {
 public:
  inline UnloadCharacters() : UnloadCharacters(nullptr) {}
  virtual ~UnloadCharacters();

  UnloadCharacters(const UnloadCharacters& from);
  UnloadCharacters(UnloadCharacters&& from) noexcept
    : UnloadCharacters() {
    *this = ::std::move(from);
  }

  inline UnloadCharacters& operator=(const UnloadCharacters& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadCharacters& operator=(UnloadCharacters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnloadCharacters& default_instance();

  static inline const UnloadCharacters* internal_default_instance() {
    return reinterpret_cast<const UnloadCharacters*>(
               &_UnloadCharacters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UnloadCharacters& a, UnloadCharacters& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloadCharacters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadCharacters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnloadCharacters* New() const final {
    return CreateMaybeMessage<UnloadCharacters>(nullptr);
  }

  UnloadCharacters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnloadCharacters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnloadCharacters& from);
  void MergeFrom(const UnloadCharacters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnloadCharacters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.UnloadCharacters";
  }
  protected:
  explicit UnloadCharacters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.UnloadCharacters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class CurrentSceneStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CurrentSceneStatus) */ {
 public:
  inline CurrentSceneStatus() : CurrentSceneStatus(nullptr) {}
  virtual ~CurrentSceneStatus();

  CurrentSceneStatus(const CurrentSceneStatus& from);
  CurrentSceneStatus(CurrentSceneStatus&& from) noexcept
    : CurrentSceneStatus() {
    *this = ::std::move(from);
  }

  inline CurrentSceneStatus& operator=(const CurrentSceneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentSceneStatus& operator=(CurrentSceneStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CurrentSceneStatus& default_instance();

  static inline const CurrentSceneStatus* internal_default_instance() {
    return reinterpret_cast<const CurrentSceneStatus*>(
               &_CurrentSceneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CurrentSceneStatus& a, CurrentSceneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentSceneStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentSceneStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrentSceneStatus* New() const final {
    return CreateMaybeMessage<CurrentSceneStatus>(nullptr);
  }

  CurrentSceneStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrentSceneStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CurrentSceneStatus& from);
  void MergeFrom(const CurrentSceneStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentSceneStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CurrentSceneStatus";
  }
  protected:
  explicit CurrentSceneStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
    kSceneNameFieldNumber = 2,
    kSceneDescriptionFieldNumber = 3,
    kSceneDisplayNameFieldNumber = 4,
  };
  // repeated .ai.inworld.packets.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::Agent& agents(int index) const;
  ::ai::inworld::packets::Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
      agents() const;

  // string scene_name = 2;
  void clear_scene_name();
  const std::string& scene_name() const;
  void set_scene_name(const std::string& value);
  void set_scene_name(std::string&& value);
  void set_scene_name(const char* value);
  void set_scene_name(const char* value, size_t size);
  std::string* mutable_scene_name();
  std::string* release_scene_name();
  void set_allocated_scene_name(std::string* scene_name);
  private:
  const std::string& _internal_scene_name() const;
  void _internal_set_scene_name(const std::string& value);
  std::string* _internal_mutable_scene_name();
  public:

  // string scene_description = 3;
  void clear_scene_description();
  const std::string& scene_description() const;
  void set_scene_description(const std::string& value);
  void set_scene_description(std::string&& value);
  void set_scene_description(const char* value);
  void set_scene_description(const char* value, size_t size);
  std::string* mutable_scene_description();
  std::string* release_scene_description();
  void set_allocated_scene_description(std::string* scene_description);
  private:
  const std::string& _internal_scene_description() const;
  void _internal_set_scene_description(const std::string& value);
  std::string* _internal_mutable_scene_description();
  public:

  // string scene_display_name = 4;
  void clear_scene_display_name();
  const std::string& scene_display_name() const;
  void set_scene_display_name(const std::string& value);
  void set_scene_display_name(std::string&& value);
  void set_scene_display_name(const char* value);
  void set_scene_display_name(const char* value, size_t size);
  std::string* mutable_scene_display_name();
  std::string* release_scene_display_name();
  void set_allocated_scene_display_name(std::string* scene_display_name);
  private:
  const std::string& _internal_scene_display_name() const;
  void _internal_set_scene_display_name(const std::string& value);
  std::string* _internal_mutable_scene_display_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CurrentSceneStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent > agents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scene_display_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ModifyExactResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ModifyExactResponse) */ {
 public:
  inline ModifyExactResponse() : ModifyExactResponse(nullptr) {}
  virtual ~ModifyExactResponse();

  ModifyExactResponse(const ModifyExactResponse& from);
  ModifyExactResponse(ModifyExactResponse&& from) noexcept
    : ModifyExactResponse() {
    *this = ::std::move(from);
  }

  inline ModifyExactResponse& operator=(const ModifyExactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyExactResponse& operator=(ModifyExactResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModifyExactResponse& default_instance();

  static inline const ModifyExactResponse* internal_default_instance() {
    return reinterpret_cast<const ModifyExactResponse*>(
               &_ModifyExactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ModifyExactResponse& a, ModifyExactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyExactResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyExactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyExactResponse* New() const final {
    return CreateMaybeMessage<ModifyExactResponse>(nullptr);
  }

  ModifyExactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyExactResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModifyExactResponse& from);
  void MergeFrom(const ModifyExactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyExactResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ModifyExactResponse";
  }
  protected:
  explicit ModifyExactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kExactTextFieldNumber = 2,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string exact_text = 2;
  void clear_exact_text();
  const std::string& exact_text() const;
  void set_exact_text(const std::string& value);
  void set_exact_text(std::string&& value);
  void set_exact_text(const char* value);
  void set_exact_text(const char* value, size_t size);
  std::string* mutable_exact_text();
  std::string* release_exact_text();
  void set_allocated_exact_text(std::string* exact_text);
  private:
  const std::string& _internal_exact_text() const;
  void _internal_set_exact_text(const std::string& value);
  std::string* _internal_mutable_exact_text();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ModifyExactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exact_text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent_Agent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent.Agent) */ {
 public:
  inline LoadSceneOutputEvent_Agent() : LoadSceneOutputEvent_Agent(nullptr) {}
  virtual ~LoadSceneOutputEvent_Agent();

  LoadSceneOutputEvent_Agent(const LoadSceneOutputEvent_Agent& from);
  LoadSceneOutputEvent_Agent(LoadSceneOutputEvent_Agent&& from) noexcept
    : LoadSceneOutputEvent_Agent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent_Agent& operator=(const LoadSceneOutputEvent_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent_Agent& operator=(LoadSceneOutputEvent_Agent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadSceneOutputEvent_Agent& default_instance();

  static inline const LoadSceneOutputEvent_Agent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent_Agent*>(
               &_LoadSceneOutputEvent_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(LoadSceneOutputEvent_Agent& a, LoadSceneOutputEvent_Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadSceneOutputEvent_Agent* New() const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(nullptr);
  }

  LoadSceneOutputEvent_Agent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadSceneOutputEvent_Agent& from);
  void MergeFrom(const LoadSceneOutputEvent_Agent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent_Agent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent.Agent";
  }
  protected:
  explicit LoadSceneOutputEvent_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  void set_agent_id(const std::string& value);
  void set_agent_id(std::string&& value);
  void set_agent_id(const char* value);
  void set_agent_id(const char* value, size_t size);
  std::string* mutable_agent_id();
  std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string brain_name = 2;
  void clear_brain_name();
  const std::string& brain_name() const;
  void set_brain_name(const std::string& value);
  void set_brain_name(std::string&& value);
  void set_brain_name(const char* value);
  void set_brain_name(const char* value, size_t size);
  std::string* mutable_brain_name();
  std::string* release_brain_name();
  void set_allocated_brain_name(std::string* brain_name);
  private:
  const std::string& _internal_brain_name() const;
  void _internal_set_brain_name(const std::string& value);
  std::string* _internal_mutable_brain_name();
  public:

  // string given_name = 3;
  void clear_given_name();
  const std::string& given_name() const;
  void set_given_name(const std::string& value);
  void set_given_name(std::string&& value);
  void set_given_name(const char* value);
  void set_given_name(const char* value, size_t size);
  std::string* mutable_given_name();
  std::string* release_given_name();
  void set_allocated_given_name(std::string* given_name);
  private:
  const std::string& _internal_given_name() const;
  void _internal_set_given_name(const std::string& value);
  std::string* _internal_mutable_given_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent.Agent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brain_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr given_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent) */ {
 public:
  inline LoadSceneOutputEvent() : LoadSceneOutputEvent(nullptr) {}
  virtual ~LoadSceneOutputEvent();

  LoadSceneOutputEvent(const LoadSceneOutputEvent& from);
  LoadSceneOutputEvent(LoadSceneOutputEvent&& from) noexcept
    : LoadSceneOutputEvent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent& operator=(const LoadSceneOutputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent& operator=(LoadSceneOutputEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadSceneOutputEvent& default_instance();

  static inline const LoadSceneOutputEvent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent*>(
               &_LoadSceneOutputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(LoadSceneOutputEvent& a, LoadSceneOutputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadSceneOutputEvent* New() const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(nullptr);
  }

  LoadSceneOutputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadSceneOutputEvent& from);
  void MergeFrom(const LoadSceneOutputEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent";
  }
  protected:
  explicit LoadSceneOutputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadSceneOutputEvent_Agent Agent;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
      agents() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent > agents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Agent_CharacterAssets PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Agent.CharacterAssets) */ {
 public:
  inline Agent_CharacterAssets() : Agent_CharacterAssets(nullptr) {}
  virtual ~Agent_CharacterAssets();

  Agent_CharacterAssets(const Agent_CharacterAssets& from);
  Agent_CharacterAssets(Agent_CharacterAssets&& from) noexcept
    : Agent_CharacterAssets() {
    *this = ::std::move(from);
  }

  inline Agent_CharacterAssets& operator=(const Agent_CharacterAssets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent_CharacterAssets& operator=(Agent_CharacterAssets&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Agent_CharacterAssets& default_instance();

  static inline const Agent_CharacterAssets* internal_default_instance() {
    return reinterpret_cast<const Agent_CharacterAssets*>(
               &_Agent_CharacterAssets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Agent_CharacterAssets& a, Agent_CharacterAssets& b) {
    a.Swap(&b);
  }
  inline void Swap(Agent_CharacterAssets* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent_CharacterAssets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Agent_CharacterAssets* New() const final {
    return CreateMaybeMessage<Agent_CharacterAssets>(nullptr);
  }

  Agent_CharacterAssets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Agent_CharacterAssets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Agent_CharacterAssets& from);
  void MergeFrom(const Agent_CharacterAssets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Agent_CharacterAssets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Agent.CharacterAssets";
  }
  protected:
  explicit Agent_CharacterAssets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpmModelUriFieldNumber = 1,
    kRpmImageUriPortraitFieldNumber = 2,
    kRpmImageUriPostureFieldNumber = 3,
    kAvatarImgFieldNumber = 4,
    kAvatarImgOriginalFieldNumber = 5,
  };
  // string rpm_model_uri = 1;
  void clear_rpm_model_uri();
  const std::string& rpm_model_uri() const;
  void set_rpm_model_uri(const std::string& value);
  void set_rpm_model_uri(std::string&& value);
  void set_rpm_model_uri(const char* value);
  void set_rpm_model_uri(const char* value, size_t size);
  std::string* mutable_rpm_model_uri();
  std::string* release_rpm_model_uri();
  void set_allocated_rpm_model_uri(std::string* rpm_model_uri);
  private:
  const std::string& _internal_rpm_model_uri() const;
  void _internal_set_rpm_model_uri(const std::string& value);
  std::string* _internal_mutable_rpm_model_uri();
  public:

  // string rpm_image_uri_portrait = 2;
  void clear_rpm_image_uri_portrait();
  const std::string& rpm_image_uri_portrait() const;
  void set_rpm_image_uri_portrait(const std::string& value);
  void set_rpm_image_uri_portrait(std::string&& value);
  void set_rpm_image_uri_portrait(const char* value);
  void set_rpm_image_uri_portrait(const char* value, size_t size);
  std::string* mutable_rpm_image_uri_portrait();
  std::string* release_rpm_image_uri_portrait();
  void set_allocated_rpm_image_uri_portrait(std::string* rpm_image_uri_portrait);
  private:
  const std::string& _internal_rpm_image_uri_portrait() const;
  void _internal_set_rpm_image_uri_portrait(const std::string& value);
  std::string* _internal_mutable_rpm_image_uri_portrait();
  public:

  // string rpm_image_uri_posture = 3;
  void clear_rpm_image_uri_posture();
  const std::string& rpm_image_uri_posture() const;
  void set_rpm_image_uri_posture(const std::string& value);
  void set_rpm_image_uri_posture(std::string&& value);
  void set_rpm_image_uri_posture(const char* value);
  void set_rpm_image_uri_posture(const char* value, size_t size);
  std::string* mutable_rpm_image_uri_posture();
  std::string* release_rpm_image_uri_posture();
  void set_allocated_rpm_image_uri_posture(std::string* rpm_image_uri_posture);
  private:
  const std::string& _internal_rpm_image_uri_posture() const;
  void _internal_set_rpm_image_uri_posture(const std::string& value);
  std::string* _internal_mutable_rpm_image_uri_posture();
  public:

  // string avatar_img = 4;
  void clear_avatar_img();
  const std::string& avatar_img() const;
  void set_avatar_img(const std::string& value);
  void set_avatar_img(std::string&& value);
  void set_avatar_img(const char* value);
  void set_avatar_img(const char* value, size_t size);
  std::string* mutable_avatar_img();
  std::string* release_avatar_img();
  void set_allocated_avatar_img(std::string* avatar_img);
  private:
  const std::string& _internal_avatar_img() const;
  void _internal_set_avatar_img(const std::string& value);
  std::string* _internal_mutable_avatar_img();
  public:

  // string avatar_img_original = 5;
  void clear_avatar_img_original();
  const std::string& avatar_img_original() const;
  void set_avatar_img_original(const std::string& value);
  void set_avatar_img_original(std::string&& value);
  void set_avatar_img_original(const char* value);
  void set_avatar_img_original(const char* value, size_t size);
  std::string* mutable_avatar_img_original();
  std::string* release_avatar_img_original();
  void set_allocated_avatar_img_original(std::string* avatar_img_original);
  private:
  const std::string& _internal_avatar_img_original() const;
  void _internal_set_avatar_img_original(const std::string& value);
  std::string* _internal_mutable_avatar_img_original();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Agent.CharacterAssets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpm_model_uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpm_image_uri_portrait_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rpm_image_uri_posture_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_img_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_img_original_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Agent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Agent) */ {
 public:
  inline Agent() : Agent(nullptr) {}
  virtual ~Agent();

  Agent(const Agent& from);
  Agent(Agent&& from) noexcept
    : Agent() {
    *this = ::std::move(from);
  }

  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Agent& operator=(Agent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Agent& default_instance();

  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
               &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Agent& a, Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(Agent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Agent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Agent* New() const final {
    return CreateMaybeMessage<Agent>(nullptr);
  }

  Agent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Agent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Agent& from);
  void MergeFrom(const Agent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Agent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Agent";
  }
  protected:
  explicit Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Agent_CharacterAssets CharacterAssets;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
    kCharacterAssetsFieldNumber = 4,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  void set_agent_id(const std::string& value);
  void set_agent_id(std::string&& value);
  void set_agent_id(const char* value);
  void set_agent_id(const char* value, size_t size);
  std::string* mutable_agent_id();
  std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string brain_name = 2;
  void clear_brain_name();
  const std::string& brain_name() const;
  void set_brain_name(const std::string& value);
  void set_brain_name(std::string&& value);
  void set_brain_name(const char* value);
  void set_brain_name(const char* value, size_t size);
  std::string* mutable_brain_name();
  std::string* release_brain_name();
  void set_allocated_brain_name(std::string* brain_name);
  private:
  const std::string& _internal_brain_name() const;
  void _internal_set_brain_name(const std::string& value);
  std::string* _internal_mutable_brain_name();
  public:

  // string given_name = 3;
  void clear_given_name();
  const std::string& given_name() const;
  void set_given_name(const std::string& value);
  void set_given_name(std::string&& value);
  void set_given_name(const char* value);
  void set_given_name(const char* value, size_t size);
  std::string* mutable_given_name();
  std::string* release_given_name();
  void set_allocated_given_name(std::string* given_name);
  private:
  const std::string& _internal_given_name() const;
  void _internal_set_given_name(const std::string& value);
  std::string* _internal_mutable_given_name();
  public:

  // .ai.inworld.packets.Agent.CharacterAssets character_assets = 4;
  bool has_character_assets() const;
  private:
  bool _internal_has_character_assets() const;
  public:
  void clear_character_assets();
  const ::ai::inworld::packets::Agent_CharacterAssets& character_assets() const;
  ::ai::inworld::packets::Agent_CharacterAssets* release_character_assets();
  ::ai::inworld::packets::Agent_CharacterAssets* mutable_character_assets();
  void set_allocated_character_assets(::ai::inworld::packets::Agent_CharacterAssets* character_assets);
  private:
  const ::ai::inworld::packets::Agent_CharacterAssets& _internal_character_assets() const;
  ::ai::inworld::packets::Agent_CharacterAssets* _internal_mutable_character_assets();
  public:
  void unsafe_arena_set_allocated_character_assets(
      ::ai::inworld::packets::Agent_CharacterAssets* character_assets);
  ::ai::inworld::packets::Agent_CharacterAssets* unsafe_arena_release_character_assets();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Agent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brain_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr given_name_;
  ::ai::inworld::packets::Agent_CharacterAssets* character_assets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class DebugInfoEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DebugInfoEvent) */ {
 public:
  inline DebugInfoEvent() : DebugInfoEvent(nullptr) {}
  virtual ~DebugInfoEvent();

  DebugInfoEvent(const DebugInfoEvent& from);
  DebugInfoEvent(DebugInfoEvent&& from) noexcept
    : DebugInfoEvent() {
    *this = ::std::move(from);
  }

  inline DebugInfoEvent& operator=(const DebugInfoEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInfoEvent& operator=(DebugInfoEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugInfoEvent& default_instance();

  enum InfoCase {
    kRelation = 1,
    INFO_NOT_SET = 0,
  };

  static inline const DebugInfoEvent* internal_default_instance() {
    return reinterpret_cast<const DebugInfoEvent*>(
               &_DebugInfoEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DebugInfoEvent& a, DebugInfoEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugInfoEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInfoEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugInfoEvent* New() const final {
    return CreateMaybeMessage<DebugInfoEvent>(nullptr);
  }

  DebugInfoEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugInfoEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugInfoEvent& from);
  void MergeFrom(const DebugInfoEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugInfoEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DebugInfoEvent";
  }
  protected:
  explicit DebugInfoEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // .ai.inworld.packets.RelationInfo relation = 1;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  const ::ai::inworld::packets::RelationInfo& relation() const;
  ::ai::inworld::packets::RelationInfo* release_relation();
  ::ai::inworld::packets::RelationInfo* mutable_relation();
  void set_allocated_relation(::ai::inworld::packets::RelationInfo* relation);
  private:
  const ::ai::inworld::packets::RelationInfo& _internal_relation() const;
  ::ai::inworld::packets::RelationInfo* _internal_mutable_relation();
  public:
  void unsafe_arena_set_allocated_relation(
      ::ai::inworld::packets::RelationInfo* relation);
  ::ai::inworld::packets::RelationInfo* unsafe_arena_release_relation();

  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DebugInfoEvent)
 private:
  class _Internal;
  void set_has_relation();

  inline bool has_info() const;
  inline void clear_has_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InfoUnion {
    InfoUnion() {}
    ::ai::inworld::packets::RelationInfo* relation_;
  } info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionControlEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionControlEvent) */ {
 public:
  inline SessionControlEvent() : SessionControlEvent(nullptr) {}
  virtual ~SessionControlEvent();

  SessionControlEvent(const SessionControlEvent& from);
  SessionControlEvent(SessionControlEvent&& from) noexcept
    : SessionControlEvent() {
    *this = ::std::move(from);
  }

  inline SessionControlEvent& operator=(const SessionControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionControlEvent& operator=(SessionControlEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionControlEvent& default_instance();

  enum SessionControlCase {
    kSessionConfiguration = 1,
    kUserConfiguration = 2,
    kClientConfiguration = 3,
    kCapabilitiesConfiguration = 4,
    kContinuation = 5,
    kSessionHistoryRequest = 6,
    kSessionConfigurationPayload = 7,
    SESSION_CONTROL_NOT_SET = 0,
  };

  static inline const SessionControlEvent* internal_default_instance() {
    return reinterpret_cast<const SessionControlEvent*>(
               &_SessionControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SessionControlEvent& a, SessionControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionControlEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionControlEvent* New() const final {
    return CreateMaybeMessage<SessionControlEvent>(nullptr);
  }

  SessionControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionControlEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionControlEvent& from);
  void MergeFrom(const SessionControlEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionControlEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionControlEvent";
  }
  protected:
  explicit SessionControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionConfigurationFieldNumber = 1,
    kUserConfigurationFieldNumber = 2,
    kClientConfigurationFieldNumber = 3,
    kCapabilitiesConfigurationFieldNumber = 4,
    kContinuationFieldNumber = 5,
    kSessionHistoryRequestFieldNumber = 6,
    kSessionConfigurationPayloadFieldNumber = 7,
  };
  // .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
  bool has_session_configuration() const;
  private:
  bool _internal_has_session_configuration() const;
  public:
  void clear_session_configuration();
  const ::ai::inworld::engine::configuration::SessionConfiguration& session_configuration() const;
  ::ai::inworld::engine::configuration::SessionConfiguration* release_session_configuration();
  ::ai::inworld::engine::configuration::SessionConfiguration* mutable_session_configuration();
  void set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* session_configuration);
  private:
  const ::ai::inworld::engine::configuration::SessionConfiguration& _internal_session_configuration() const;
  ::ai::inworld::engine::configuration::SessionConfiguration* _internal_mutable_session_configuration();
  public:
  void unsafe_arena_set_allocated_session_configuration(
      ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration);
  ::ai::inworld::engine::configuration::SessionConfiguration* unsafe_arena_release_session_configuration();

  // .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
  bool has_user_configuration() const;
  private:
  bool _internal_has_user_configuration() const;
  public:
  void clear_user_configuration();
  const ::ai::inworld::engine::configuration::UserConfiguration& user_configuration() const;
  ::ai::inworld::engine::configuration::UserConfiguration* release_user_configuration();
  ::ai::inworld::engine::configuration::UserConfiguration* mutable_user_configuration();
  void set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* user_configuration);
  private:
  const ::ai::inworld::engine::configuration::UserConfiguration& _internal_user_configuration() const;
  ::ai::inworld::engine::configuration::UserConfiguration* _internal_mutable_user_configuration();
  public:
  void unsafe_arena_set_allocated_user_configuration(
      ::ai::inworld::engine::configuration::UserConfiguration* user_configuration);
  ::ai::inworld::engine::configuration::UserConfiguration* unsafe_arena_release_user_configuration();

  // .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;
  public:
  void clear_client_configuration();
  const ::ai::inworld::engine::configuration::ClientConfiguration& client_configuration() const;
  ::ai::inworld::engine::configuration::ClientConfiguration* release_client_configuration();
  ::ai::inworld::engine::configuration::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* client_configuration);
  private:
  const ::ai::inworld::engine::configuration::ClientConfiguration& _internal_client_configuration() const;
  ::ai::inworld::engine::configuration::ClientConfiguration* _internal_mutable_client_configuration();
  public:
  void unsafe_arena_set_allocated_client_configuration(
      ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration);
  ::ai::inworld::engine::configuration::ClientConfiguration* unsafe_arena_release_client_configuration();

  // .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
  bool has_capabilities_configuration() const;
  private:
  bool _internal_has_capabilities_configuration() const;
  public:
  void clear_capabilities_configuration();
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& capabilities_configuration() const;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* release_capabilities_configuration();
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* mutable_capabilities_configuration();
  void set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration);
  private:
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& _internal_capabilities_configuration() const;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* _internal_mutable_capabilities_configuration();
  public:
  void unsafe_arena_set_allocated_capabilities_configuration(
      ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration);
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* unsafe_arena_release_capabilities_configuration();

  // .ai.inworld.packets.Continuation continuation = 5;
  bool has_continuation() const;
  private:
  bool _internal_has_continuation() const;
  public:
  void clear_continuation();
  const ::ai::inworld::packets::Continuation& continuation() const;
  ::ai::inworld::packets::Continuation* release_continuation();
  ::ai::inworld::packets::Continuation* mutable_continuation();
  void set_allocated_continuation(::ai::inworld::packets::Continuation* continuation);
  private:
  const ::ai::inworld::packets::Continuation& _internal_continuation() const;
  ::ai::inworld::packets::Continuation* _internal_mutable_continuation();
  public:
  void unsafe_arena_set_allocated_continuation(
      ::ai::inworld::packets::Continuation* continuation);
  ::ai::inworld::packets::Continuation* unsafe_arena_release_continuation();

  // .ai.inworld.packets.SessionHistoryRequest session_history_request = 6;
  bool has_session_history_request() const;
  private:
  bool _internal_has_session_history_request() const;
  public:
  void clear_session_history_request();
  const ::ai::inworld::packets::SessionHistoryRequest& session_history_request() const;
  ::ai::inworld::packets::SessionHistoryRequest* release_session_history_request();
  ::ai::inworld::packets::SessionHistoryRequest* mutable_session_history_request();
  void set_allocated_session_history_request(::ai::inworld::packets::SessionHistoryRequest* session_history_request);
  private:
  const ::ai::inworld::packets::SessionHistoryRequest& _internal_session_history_request() const;
  ::ai::inworld::packets::SessionHistoryRequest* _internal_mutable_session_history_request();
  public:
  void unsafe_arena_set_allocated_session_history_request(
      ::ai::inworld::packets::SessionHistoryRequest* session_history_request);
  ::ai::inworld::packets::SessionHistoryRequest* unsafe_arena_release_session_history_request();

  // .ai.inworld.packets.SessionConfigurationPayload session_configuration_payload = 7;
  bool has_session_configuration_payload() const;
  private:
  bool _internal_has_session_configuration_payload() const;
  public:
  void clear_session_configuration_payload();
  const ::ai::inworld::packets::SessionConfigurationPayload& session_configuration_payload() const;
  ::ai::inworld::packets::SessionConfigurationPayload* release_session_configuration_payload();
  ::ai::inworld::packets::SessionConfigurationPayload* mutable_session_configuration_payload();
  void set_allocated_session_configuration_payload(::ai::inworld::packets::SessionConfigurationPayload* session_configuration_payload);
  private:
  const ::ai::inworld::packets::SessionConfigurationPayload& _internal_session_configuration_payload() const;
  ::ai::inworld::packets::SessionConfigurationPayload* _internal_mutable_session_configuration_payload();
  public:
  void unsafe_arena_set_allocated_session_configuration_payload(
      ::ai::inworld::packets::SessionConfigurationPayload* session_configuration_payload);
  ::ai::inworld::packets::SessionConfigurationPayload* unsafe_arena_release_session_configuration_payload();

  void clear_session_control();
  SessionControlCase session_control_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionControlEvent)
 private:
  class _Internal;
  void set_has_session_configuration();
  void set_has_user_configuration();
  void set_has_client_configuration();
  void set_has_capabilities_configuration();
  void set_has_continuation();
  void set_has_session_history_request();
  void set_has_session_configuration_payload();

  inline bool has_session_control() const;
  inline void clear_has_session_control();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SessionControlUnion {
    SessionControlUnion() {}
    ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration_;
    ::ai::inworld::engine::configuration::UserConfiguration* user_configuration_;
    ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration_;
    ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration_;
    ::ai::inworld::packets::Continuation* continuation_;
    ::ai::inworld::packets::SessionHistoryRequest* session_history_request_;
    ::ai::inworld::packets::SessionConfigurationPayload* session_configuration_payload_;
  } session_control_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionConfigurationPayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionConfigurationPayload) */ {
 public:
  inline SessionConfigurationPayload() : SessionConfigurationPayload(nullptr) {}
  virtual ~SessionConfigurationPayload();

  SessionConfigurationPayload(const SessionConfigurationPayload& from);
  SessionConfigurationPayload(SessionConfigurationPayload&& from) noexcept
    : SessionConfigurationPayload() {
    *this = ::std::move(from);
  }

  inline SessionConfigurationPayload& operator=(const SessionConfigurationPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionConfigurationPayload& operator=(SessionConfigurationPayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionConfigurationPayload& default_instance();

  static inline const SessionConfigurationPayload* internal_default_instance() {
    return reinterpret_cast<const SessionConfigurationPayload*>(
               &_SessionConfigurationPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SessionConfigurationPayload& a, SessionConfigurationPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionConfigurationPayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionConfigurationPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionConfigurationPayload* New() const final {
    return CreateMaybeMessage<SessionConfigurationPayload>(nullptr);
  }

  SessionConfigurationPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionConfigurationPayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionConfigurationPayload& from);
  void MergeFrom(const SessionConfigurationPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionConfigurationPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionConfigurationPayload";
  }
  protected:
  explicit SessionConfigurationPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionConfigurationFieldNumber = 1,
    kUserConfigurationFieldNumber = 2,
    kClientConfigurationFieldNumber = 3,
    kCapabilitiesConfigurationFieldNumber = 4,
    kContinuationFieldNumber = 5,
  };
  // .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
  bool has_session_configuration() const;
  private:
  bool _internal_has_session_configuration() const;
  public:
  void clear_session_configuration();
  const ::ai::inworld::engine::configuration::SessionConfiguration& session_configuration() const;
  ::ai::inworld::engine::configuration::SessionConfiguration* release_session_configuration();
  ::ai::inworld::engine::configuration::SessionConfiguration* mutable_session_configuration();
  void set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* session_configuration);
  private:
  const ::ai::inworld::engine::configuration::SessionConfiguration& _internal_session_configuration() const;
  ::ai::inworld::engine::configuration::SessionConfiguration* _internal_mutable_session_configuration();
  public:
  void unsafe_arena_set_allocated_session_configuration(
      ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration);
  ::ai::inworld::engine::configuration::SessionConfiguration* unsafe_arena_release_session_configuration();

  // .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
  bool has_user_configuration() const;
  private:
  bool _internal_has_user_configuration() const;
  public:
  void clear_user_configuration();
  const ::ai::inworld::engine::configuration::UserConfiguration& user_configuration() const;
  ::ai::inworld::engine::configuration::UserConfiguration* release_user_configuration();
  ::ai::inworld::engine::configuration::UserConfiguration* mutable_user_configuration();
  void set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* user_configuration);
  private:
  const ::ai::inworld::engine::configuration::UserConfiguration& _internal_user_configuration() const;
  ::ai::inworld::engine::configuration::UserConfiguration* _internal_mutable_user_configuration();
  public:
  void unsafe_arena_set_allocated_user_configuration(
      ::ai::inworld::engine::configuration::UserConfiguration* user_configuration);
  ::ai::inworld::engine::configuration::UserConfiguration* unsafe_arena_release_user_configuration();

  // .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;
  public:
  void clear_client_configuration();
  const ::ai::inworld::engine::configuration::ClientConfiguration& client_configuration() const;
  ::ai::inworld::engine::configuration::ClientConfiguration* release_client_configuration();
  ::ai::inworld::engine::configuration::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* client_configuration);
  private:
  const ::ai::inworld::engine::configuration::ClientConfiguration& _internal_client_configuration() const;
  ::ai::inworld::engine::configuration::ClientConfiguration* _internal_mutable_client_configuration();
  public:
  void unsafe_arena_set_allocated_client_configuration(
      ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration);
  ::ai::inworld::engine::configuration::ClientConfiguration* unsafe_arena_release_client_configuration();

  // .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
  bool has_capabilities_configuration() const;
  private:
  bool _internal_has_capabilities_configuration() const;
  public:
  void clear_capabilities_configuration();
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& capabilities_configuration() const;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* release_capabilities_configuration();
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* mutable_capabilities_configuration();
  void set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration);
  private:
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& _internal_capabilities_configuration() const;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* _internal_mutable_capabilities_configuration();
  public:
  void unsafe_arena_set_allocated_capabilities_configuration(
      ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration);
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* unsafe_arena_release_capabilities_configuration();

  // .ai.inworld.packets.Continuation continuation = 5;
  bool has_continuation() const;
  private:
  bool _internal_has_continuation() const;
  public:
  void clear_continuation();
  const ::ai::inworld::packets::Continuation& continuation() const;
  ::ai::inworld::packets::Continuation* release_continuation();
  ::ai::inworld::packets::Continuation* mutable_continuation();
  void set_allocated_continuation(::ai::inworld::packets::Continuation* continuation);
  private:
  const ::ai::inworld::packets::Continuation& _internal_continuation() const;
  ::ai::inworld::packets::Continuation* _internal_mutable_continuation();
  public:
  void unsafe_arena_set_allocated_continuation(
      ::ai::inworld::packets::Continuation* continuation);
  ::ai::inworld::packets::Continuation* unsafe_arena_release_continuation();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionConfigurationPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration_;
  ::ai::inworld::engine::configuration::UserConfiguration* user_configuration_;
  ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration_;
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration_;
  ::ai::inworld::packets::Continuation* continuation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Continuation_ContinuationInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Continuation.ContinuationInfo) */ {
 public:
  inline Continuation_ContinuationInfo() : Continuation_ContinuationInfo(nullptr) {}
  virtual ~Continuation_ContinuationInfo();

  Continuation_ContinuationInfo(const Continuation_ContinuationInfo& from);
  Continuation_ContinuationInfo(Continuation_ContinuationInfo&& from) noexcept
    : Continuation_ContinuationInfo() {
    *this = ::std::move(from);
  }

  inline Continuation_ContinuationInfo& operator=(const Continuation_ContinuationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Continuation_ContinuationInfo& operator=(Continuation_ContinuationInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Continuation_ContinuationInfo& default_instance();

  static inline const Continuation_ContinuationInfo* internal_default_instance() {
    return reinterpret_cast<const Continuation_ContinuationInfo*>(
               &_Continuation_ContinuationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Continuation_ContinuationInfo& a, Continuation_ContinuationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Continuation_ContinuationInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Continuation_ContinuationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Continuation_ContinuationInfo* New() const final {
    return CreateMaybeMessage<Continuation_ContinuationInfo>(nullptr);
  }

  Continuation_ContinuationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Continuation_ContinuationInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Continuation_ContinuationInfo& from);
  void MergeFrom(const Continuation_ContinuationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Continuation_ContinuationInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Continuation.ContinuationInfo";
  }
  protected:
  explicit Continuation_ContinuationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassedTimeFieldNumber = 1,
  };
  // .google.protobuf.Timestamp passed_time = 1;
  bool has_passed_time() const;
  private:
  bool _internal_has_passed_time() const;
  public:
  void clear_passed_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& passed_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_passed_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_passed_time();
  void set_allocated_passed_time(PROTOBUF_NAMESPACE_ID::Timestamp* passed_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_passed_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_passed_time();
  public:
  void unsafe_arena_set_allocated_passed_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* passed_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_passed_time();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Continuation.ContinuationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* passed_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Continuation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Continuation) */ {
 public:
  inline Continuation() : Continuation(nullptr) {}
  virtual ~Continuation();

  Continuation(const Continuation& from);
  Continuation(Continuation&& from) noexcept
    : Continuation() {
    *this = ::std::move(from);
  }

  inline Continuation& operator=(const Continuation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Continuation& operator=(Continuation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Continuation& default_instance();

  static inline const Continuation* internal_default_instance() {
    return reinterpret_cast<const Continuation*>(
               &_Continuation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Continuation& a, Continuation& b) {
    a.Swap(&b);
  }
  inline void Swap(Continuation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Continuation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Continuation* New() const final {
    return CreateMaybeMessage<Continuation>(nullptr);
  }

  Continuation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Continuation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Continuation& from);
  void MergeFrom(const Continuation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Continuation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Continuation";
  }
  protected:
  explicit Continuation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Continuation_ContinuationInfo ContinuationInfo;

  typedef Continuation_ContinuationType ContinuationType;
  static constexpr ContinuationType CONTINUATION_TYPE_UNKNOWN =
    Continuation_ContinuationType_CONTINUATION_TYPE_UNKNOWN;
  static constexpr ContinuationType CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE =
    Continuation_ContinuationType_CONTINUATION_TYPE_EXTERNALLY_SAVED_STATE;
  static constexpr ContinuationType CONTINUATION_TYPE_DIALOG_HISTORY =
    Continuation_ContinuationType_CONTINUATION_TYPE_DIALOG_HISTORY;
  static inline bool ContinuationType_IsValid(int value) {
    return Continuation_ContinuationType_IsValid(value);
  }
  static constexpr ContinuationType ContinuationType_MIN =
    Continuation_ContinuationType_ContinuationType_MIN;
  static constexpr ContinuationType ContinuationType_MAX =
    Continuation_ContinuationType_ContinuationType_MAX;
  static constexpr int ContinuationType_ARRAYSIZE =
    Continuation_ContinuationType_ContinuationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContinuationType_descriptor() {
    return Continuation_ContinuationType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContinuationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContinuationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContinuationType_Name.");
    return Continuation_ContinuationType_Name(enum_t_value);
  }
  static inline bool ContinuationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContinuationType* value) {
    return Continuation_ContinuationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExternallySavedStateFieldNumber = 4,
    kContinuationInfoFieldNumber = 1,
    kDialogHistoryFieldNumber = 3,
    kContinuationTypeFieldNumber = 2,
  };
  // bytes externally_saved_state = 4;
  void clear_externally_saved_state();
  const std::string& externally_saved_state() const;
  void set_externally_saved_state(const std::string& value);
  void set_externally_saved_state(std::string&& value);
  void set_externally_saved_state(const char* value);
  void set_externally_saved_state(const void* value, size_t size);
  std::string* mutable_externally_saved_state();
  std::string* release_externally_saved_state();
  void set_allocated_externally_saved_state(std::string* externally_saved_state);
  private:
  const std::string& _internal_externally_saved_state() const;
  void _internal_set_externally_saved_state(const std::string& value);
  std::string* _internal_mutable_externally_saved_state();
  public:

  // .ai.inworld.packets.Continuation.ContinuationInfo continuation_info = 1;
  bool has_continuation_info() const;
  private:
  bool _internal_has_continuation_info() const;
  public:
  void clear_continuation_info();
  const ::ai::inworld::packets::Continuation_ContinuationInfo& continuation_info() const;
  ::ai::inworld::packets::Continuation_ContinuationInfo* release_continuation_info();
  ::ai::inworld::packets::Continuation_ContinuationInfo* mutable_continuation_info();
  void set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info);
  private:
  const ::ai::inworld::packets::Continuation_ContinuationInfo& _internal_continuation_info() const;
  ::ai::inworld::packets::Continuation_ContinuationInfo* _internal_mutable_continuation_info();
  public:
  void unsafe_arena_set_allocated_continuation_info(
      ::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info);
  ::ai::inworld::packets::Continuation_ContinuationInfo* unsafe_arena_release_continuation_info();

  // .ai.inworld.packets.DialogHistory dialog_history = 3;
  bool has_dialog_history() const;
  private:
  bool _internal_has_dialog_history() const;
  public:
  void clear_dialog_history();
  const ::ai::inworld::packets::DialogHistory& dialog_history() const;
  ::ai::inworld::packets::DialogHistory* release_dialog_history();
  ::ai::inworld::packets::DialogHistory* mutable_dialog_history();
  void set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* dialog_history);
  private:
  const ::ai::inworld::packets::DialogHistory& _internal_dialog_history() const;
  ::ai::inworld::packets::DialogHistory* _internal_mutable_dialog_history();
  public:
  void unsafe_arena_set_allocated_dialog_history(
      ::ai::inworld::packets::DialogHistory* dialog_history);
  ::ai::inworld::packets::DialogHistory* unsafe_arena_release_dialog_history();

  // .ai.inworld.packets.Continuation.ContinuationType continuation_type = 2;
  void clear_continuation_type();
  ::ai::inworld::packets::Continuation_ContinuationType continuation_type() const;
  void set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value);
  private:
  ::ai::inworld::packets::Continuation_ContinuationType _internal_continuation_type() const;
  void _internal_set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Continuation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr externally_saved_state_;
  ::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info_;
  ::ai::inworld::packets::DialogHistory* dialog_history_;
  int continuation_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class DialogHistory_HistoryItem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DialogHistory.HistoryItem) */ {
 public:
  inline DialogHistory_HistoryItem() : DialogHistory_HistoryItem(nullptr) {}
  virtual ~DialogHistory_HistoryItem();

  DialogHistory_HistoryItem(const DialogHistory_HistoryItem& from);
  DialogHistory_HistoryItem(DialogHistory_HistoryItem&& from) noexcept
    : DialogHistory_HistoryItem() {
    *this = ::std::move(from);
  }

  inline DialogHistory_HistoryItem& operator=(const DialogHistory_HistoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DialogHistory_HistoryItem& operator=(DialogHistory_HistoryItem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DialogHistory_HistoryItem& default_instance();

  static inline const DialogHistory_HistoryItem* internal_default_instance() {
    return reinterpret_cast<const DialogHistory_HistoryItem*>(
               &_DialogHistory_HistoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DialogHistory_HistoryItem& a, DialogHistory_HistoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(DialogHistory_HistoryItem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DialogHistory_HistoryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DialogHistory_HistoryItem* New() const final {
    return CreateMaybeMessage<DialogHistory_HistoryItem>(nullptr);
  }

  DialogHistory_HistoryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DialogHistory_HistoryItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DialogHistory_HistoryItem& from);
  void MergeFrom(const DialogHistory_HistoryItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DialogHistory_HistoryItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DialogHistory.HistoryItem";
  }
  protected:
  explicit DialogHistory_HistoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kActorFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.Actor actor = 1;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  const ::ai::inworld::packets::Actor& actor() const;
  ::ai::inworld::packets::Actor* release_actor();
  ::ai::inworld::packets::Actor* mutable_actor();
  void set_allocated_actor(::ai::inworld::packets::Actor* actor);
  private:
  const ::ai::inworld::packets::Actor& _internal_actor() const;
  ::ai::inworld::packets::Actor* _internal_mutable_actor();
  public:
  void unsafe_arena_set_allocated_actor(
      ::ai::inworld::packets::Actor* actor);
  ::ai::inworld::packets::Actor* unsafe_arena_release_actor();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DialogHistory.HistoryItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::ai::inworld::packets::Actor* actor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class DialogHistory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DialogHistory) */ {
 public:
  inline DialogHistory() : DialogHistory(nullptr) {}
  virtual ~DialogHistory();

  DialogHistory(const DialogHistory& from);
  DialogHistory(DialogHistory&& from) noexcept
    : DialogHistory() {
    *this = ::std::move(from);
  }

  inline DialogHistory& operator=(const DialogHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline DialogHistory& operator=(DialogHistory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DialogHistory& default_instance();

  static inline const DialogHistory* internal_default_instance() {
    return reinterpret_cast<const DialogHistory*>(
               &_DialogHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(DialogHistory& a, DialogHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(DialogHistory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DialogHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DialogHistory* New() const final {
    return CreateMaybeMessage<DialogHistory>(nullptr);
  }

  DialogHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DialogHistory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DialogHistory& from);
  void MergeFrom(const DialogHistory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DialogHistory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DialogHistory";
  }
  protected:
  explicit DialogHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DialogHistory_HistoryItem HistoryItem;

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.DialogHistory.HistoryItem history = 1;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::ai::inworld::packets::DialogHistory_HistoryItem* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >*
      mutable_history();
  private:
  const ::ai::inworld::packets::DialogHistory_HistoryItem& _internal_history(int index) const;
  ::ai::inworld::packets::DialogHistory_HistoryItem* _internal_add_history();
  public:
  const ::ai::inworld::packets::DialogHistory_HistoryItem& history(int index) const;
  ::ai::inworld::packets::DialogHistory_HistoryItem* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >&
      history() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DialogHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem > history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Relations_Relation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Relations.Relation) */ {
 public:
  inline Relations_Relation() : Relations_Relation(nullptr) {}
  virtual ~Relations_Relation();

  Relations_Relation(const Relations_Relation& from);
  Relations_Relation(Relations_Relation&& from) noexcept
    : Relations_Relation() {
    *this = ::std::move(from);
  }

  inline Relations_Relation& operator=(const Relations_Relation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relations_Relation& operator=(Relations_Relation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Relations_Relation& default_instance();

  static inline const Relations_Relation* internal_default_instance() {
    return reinterpret_cast<const Relations_Relation*>(
               &_Relations_Relation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Relations_Relation& a, Relations_Relation& b) {
    a.Swap(&b);
  }
  inline void Swap(Relations_Relation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relations_Relation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Relations_Relation* New() const final {
    return CreateMaybeMessage<Relations_Relation>(nullptr);
  }

  Relations_Relation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Relations_Relation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Relations_Relation& from);
  void MergeFrom(const Relations_Relation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relations_Relation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Relations.Relation";
  }
  protected:
  explicit Relations_Relation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLabelFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  void set_label(const std::string& value);
  void set_label(std::string&& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  std::string* mutable_label();
  std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Relations.Relation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class Relations PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Relations) */ {
 public:
  inline Relations() : Relations(nullptr) {}
  virtual ~Relations();

  Relations(const Relations& from);
  Relations(Relations&& from) noexcept
    : Relations() {
    *this = ::std::move(from);
  }

  inline Relations& operator=(const Relations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relations& operator=(Relations&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Relations& default_instance();

  static inline const Relations* internal_default_instance() {
    return reinterpret_cast<const Relations*>(
               &_Relations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Relations& a, Relations& b) {
    a.Swap(&b);
  }
  inline void Swap(Relations* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Relations* New() const final {
    return CreateMaybeMessage<Relations>(nullptr);
  }

  Relations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Relations>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Relations& from);
  void MergeFrom(const Relations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Relations";
  }
  protected:
  explicit Relations(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Relations_Relation Relation;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationsFieldNumber = 2,
    kActorFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Relations.Relation relations = 2;
  int relations_size() const;
  private:
  int _internal_relations_size() const;
  public:
  void clear_relations();
  ::ai::inworld::packets::Relations_Relation* mutable_relations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >*
      mutable_relations();
  private:
  const ::ai::inworld::packets::Relations_Relation& _internal_relations(int index) const;
  ::ai::inworld::packets::Relations_Relation* _internal_add_relations();
  public:
  const ::ai::inworld::packets::Relations_Relation& relations(int index) const;
  ::ai::inworld::packets::Relations_Relation* add_relations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >&
      relations() const;

  // .ai.inworld.packets.Actor actor = 1;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  const ::ai::inworld::packets::Actor& actor() const;
  ::ai::inworld::packets::Actor* release_actor();
  ::ai::inworld::packets::Actor* mutable_actor();
  void set_allocated_actor(::ai::inworld::packets::Actor* actor);
  private:
  const ::ai::inworld::packets::Actor& _internal_actor() const;
  ::ai::inworld::packets::Actor* _internal_mutable_actor();
  public:
  void unsafe_arena_set_allocated_actor(
      ::ai::inworld::packets::Actor* actor);
  ::ai::inworld::packets::Actor* unsafe_arena_release_actor();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Relations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation > relations_;
  ::ai::inworld::packets::Actor* actor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionHistoryRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionHistoryRequest) */ {
 public:
  inline SessionHistoryRequest() : SessionHistoryRequest(nullptr) {}
  virtual ~SessionHistoryRequest();

  SessionHistoryRequest(const SessionHistoryRequest& from);
  SessionHistoryRequest(SessionHistoryRequest&& from) noexcept
    : SessionHistoryRequest() {
    *this = ::std::move(from);
  }

  inline SessionHistoryRequest& operator=(const SessionHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHistoryRequest& operator=(SessionHistoryRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionHistoryRequest& default_instance();

  static inline const SessionHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const SessionHistoryRequest*>(
               &_SessionHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(SessionHistoryRequest& a, SessionHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionHistoryRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHistoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionHistoryRequest* New() const final {
    return CreateMaybeMessage<SessionHistoryRequest>(nullptr);
  }

  SessionHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionHistoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionHistoryRequest& from);
  void MergeFrom(const SessionHistoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionHistoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionHistoryRequest";
  }
  protected:
  explicit SessionHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionHistoryResponse_SessionHistoryItem PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem) */ {
 public:
  inline SessionHistoryResponse_SessionHistoryItem() : SessionHistoryResponse_SessionHistoryItem(nullptr) {}
  virtual ~SessionHistoryResponse_SessionHistoryItem();

  SessionHistoryResponse_SessionHistoryItem(const SessionHistoryResponse_SessionHistoryItem& from);
  SessionHistoryResponse_SessionHistoryItem(SessionHistoryResponse_SessionHistoryItem&& from) noexcept
    : SessionHistoryResponse_SessionHistoryItem() {
    *this = ::std::move(from);
  }

  inline SessionHistoryResponse_SessionHistoryItem& operator=(const SessionHistoryResponse_SessionHistoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHistoryResponse_SessionHistoryItem& operator=(SessionHistoryResponse_SessionHistoryItem&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionHistoryResponse_SessionHistoryItem& default_instance();

  static inline const SessionHistoryResponse_SessionHistoryItem* internal_default_instance() {
    return reinterpret_cast<const SessionHistoryResponse_SessionHistoryItem*>(
               &_SessionHistoryResponse_SessionHistoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(SessionHistoryResponse_SessionHistoryItem& a, SessionHistoryResponse_SessionHistoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionHistoryResponse_SessionHistoryItem* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHistoryResponse_SessionHistoryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionHistoryResponse_SessionHistoryItem* New() const final {
    return CreateMaybeMessage<SessionHistoryResponse_SessionHistoryItem>(nullptr);
  }

  SessionHistoryResponse_SessionHistoryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionHistoryResponse_SessionHistoryItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionHistoryResponse_SessionHistoryItem& from);
  void MergeFrom(const SessionHistoryResponse_SessionHistoryItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionHistoryResponse_SessionHistoryItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem";
  }
  protected:
  explicit SessionHistoryResponse_SessionHistoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketsFieldNumber = 2,
    kAgentFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.InworldPacket packets = 2;
  int packets_size() const;
  private:
  int _internal_packets_size() const;
  public:
  void clear_packets();
  ::ai::inworld::packets::InworldPacket* mutable_packets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::InworldPacket >*
      mutable_packets();
  private:
  const ::ai::inworld::packets::InworldPacket& _internal_packets(int index) const;
  ::ai::inworld::packets::InworldPacket* _internal_add_packets();
  public:
  const ::ai::inworld::packets::InworldPacket& packets(int index) const;
  ::ai::inworld::packets::InworldPacket* add_packets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::InworldPacket >&
      packets() const;

  // .ai.inworld.packets.Agent agent = 1;
  bool has_agent() const;
  private:
  bool _internal_has_agent() const;
  public:
  void clear_agent();
  const ::ai::inworld::packets::Agent& agent() const;
  ::ai::inworld::packets::Agent* release_agent();
  ::ai::inworld::packets::Agent* mutable_agent();
  void set_allocated_agent(::ai::inworld::packets::Agent* agent);
  private:
  const ::ai::inworld::packets::Agent& _internal_agent() const;
  ::ai::inworld::packets::Agent* _internal_mutable_agent();
  public:
  void unsafe_arena_set_allocated_agent(
      ::ai::inworld::packets::Agent* agent);
  ::ai::inworld::packets::Agent* unsafe_arena_release_agent();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::InworldPacket > packets_;
  ::ai::inworld::packets::Agent* agent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class SessionHistoryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.SessionHistoryResponse) */ {
 public:
  inline SessionHistoryResponse() : SessionHistoryResponse(nullptr) {}
  virtual ~SessionHistoryResponse();

  SessionHistoryResponse(const SessionHistoryResponse& from);
  SessionHistoryResponse(SessionHistoryResponse&& from) noexcept
    : SessionHistoryResponse() {
    *this = ::std::move(from);
  }

  inline SessionHistoryResponse& operator=(const SessionHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHistoryResponse& operator=(SessionHistoryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionHistoryResponse& default_instance();

  static inline const SessionHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const SessionHistoryResponse*>(
               &_SessionHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(SessionHistoryResponse& a, SessionHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionHistoryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHistoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionHistoryResponse* New() const final {
    return CreateMaybeMessage<SessionHistoryResponse>(nullptr);
  }

  SessionHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionHistoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionHistoryResponse& from);
  void MergeFrom(const SessionHistoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionHistoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.SessionHistoryResponse";
  }
  protected:
  explicit SessionHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SessionHistoryResponse_SessionHistoryItem SessionHistoryItem;

  // accessors -------------------------------------------------------

  enum : int {
    kSessionHistoryItemsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem session_history_items = 1;
  int session_history_items_size() const;
  private:
  int _internal_session_history_items_size() const;
  public:
  void clear_session_history_items();
  ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* mutable_session_history_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem >*
      mutable_session_history_items();
  private:
  const ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem& _internal_session_history_items(int index) const;
  ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* _internal_add_session_history_items();
  public:
  const ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem& session_history_items(int index) const;
  ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* add_session_history_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem >&
      session_history_items() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.SessionHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem > session_history_items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ConversationUpdatePayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ConversationUpdatePayload) */ {
 public:
  inline ConversationUpdatePayload() : ConversationUpdatePayload(nullptr) {}
  virtual ~ConversationUpdatePayload();

  ConversationUpdatePayload(const ConversationUpdatePayload& from);
  ConversationUpdatePayload(ConversationUpdatePayload&& from) noexcept
    : ConversationUpdatePayload() {
    *this = ::std::move(from);
  }

  inline ConversationUpdatePayload& operator=(const ConversationUpdatePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationUpdatePayload& operator=(ConversationUpdatePayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConversationUpdatePayload& default_instance();

  static inline const ConversationUpdatePayload* internal_default_instance() {
    return reinterpret_cast<const ConversationUpdatePayload*>(
               &_ConversationUpdatePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ConversationUpdatePayload& a, ConversationUpdatePayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationUpdatePayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationUpdatePayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConversationUpdatePayload* New() const final {
    return CreateMaybeMessage<ConversationUpdatePayload>(nullptr);
  }

  ConversationUpdatePayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConversationUpdatePayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConversationUpdatePayload& from);
  void MergeFrom(const ConversationUpdatePayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationUpdatePayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ConversationUpdatePayload";
  }
  protected:
  explicit ConversationUpdatePayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.Actor participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::ai::inworld::packets::Actor* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
      mutable_participants();
  private:
  const ::ai::inworld::packets::Actor& _internal_participants(int index) const;
  ::ai::inworld::packets::Actor* _internal_add_participants();
  public:
  const ::ai::inworld::packets::Actor& participants(int index) const;
  ::ai::inworld::packets::Actor* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
      participants() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ConversationUpdatePayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor > participants_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class ConversationEventPayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ConversationEventPayload) */ {
 public:
  inline ConversationEventPayload() : ConversationEventPayload(nullptr) {}
  virtual ~ConversationEventPayload();

  ConversationEventPayload(const ConversationEventPayload& from);
  ConversationEventPayload(ConversationEventPayload&& from) noexcept
    : ConversationEventPayload() {
    *this = ::std::move(from);
  }

  inline ConversationEventPayload& operator=(const ConversationEventPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationEventPayload& operator=(ConversationEventPayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConversationEventPayload& default_instance();

  static inline const ConversationEventPayload* internal_default_instance() {
    return reinterpret_cast<const ConversationEventPayload*>(
               &_ConversationEventPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ConversationEventPayload& a, ConversationEventPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationEventPayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationEventPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConversationEventPayload* New() const final {
    return CreateMaybeMessage<ConversationEventPayload>(nullptr);
  }

  ConversationEventPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConversationEventPayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConversationEventPayload& from);
  void MergeFrom(const ConversationEventPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationEventPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ConversationEventPayload";
  }
  protected:
  explicit ConversationEventPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ConversationEventPayload_ConversationEventType ConversationEventType;
  static constexpr ConversationEventType UNKNOWN =
    ConversationEventPayload_ConversationEventType_UNKNOWN;
  static constexpr ConversationEventType STARTED =
    ConversationEventPayload_ConversationEventType_STARTED;
  static constexpr ConversationEventType UPDATED =
    ConversationEventPayload_ConversationEventType_UPDATED;
  static constexpr ConversationEventType EVICTED =
    ConversationEventPayload_ConversationEventType_EVICTED;
  static inline bool ConversationEventType_IsValid(int value) {
    return ConversationEventPayload_ConversationEventType_IsValid(value);
  }
  static constexpr ConversationEventType ConversationEventType_MIN =
    ConversationEventPayload_ConversationEventType_ConversationEventType_MIN;
  static constexpr ConversationEventType ConversationEventType_MAX =
    ConversationEventPayload_ConversationEventType_ConversationEventType_MAX;
  static constexpr int ConversationEventType_ARRAYSIZE =
    ConversationEventPayload_ConversationEventType_ConversationEventType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConversationEventType_descriptor() {
    return ConversationEventPayload_ConversationEventType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConversationEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConversationEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConversationEventType_Name.");
    return ConversationEventPayload_ConversationEventType_Name(enum_t_value);
  }
  static inline bool ConversationEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConversationEventType* value) {
    return ConversationEventPayload_ConversationEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
    kEventTypeFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.Actor participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::ai::inworld::packets::Actor* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
      mutable_participants();
  private:
  const ::ai::inworld::packets::Actor& _internal_participants(int index) const;
  ::ai::inworld::packets::Actor* _internal_add_participants();
  public:
  const ::ai::inworld::packets::Actor& participants(int index) const;
  ::ai::inworld::packets::Actor* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
      participants() const;

  // .ai.inworld.packets.ConversationEventPayload.ConversationEventType event_type = 2;
  void clear_event_type();
  ::ai::inworld::packets::ConversationEventPayload_ConversationEventType event_type() const;
  void set_event_type(::ai::inworld::packets::ConversationEventPayload_ConversationEventType value);
  private:
  ::ai::inworld::packets::ConversationEventPayload_ConversationEventType _internal_event_type() const;
  void _internal_set_event_type(::ai::inworld::packets::ConversationEventPayload_ConversationEventType value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ConversationEventPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor > participants_;
  int event_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// -------------------------------------------------------------------

class OperationStatusEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.OperationStatusEvent) */ {
 public:
  inline OperationStatusEvent() : OperationStatusEvent(nullptr) {}
  virtual ~OperationStatusEvent();

  OperationStatusEvent(const OperationStatusEvent& from);
  OperationStatusEvent(OperationStatusEvent&& from) noexcept
    : OperationStatusEvent() {
    *this = ::std::move(from);
  }

  inline OperationStatusEvent& operator=(const OperationStatusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationStatusEvent& operator=(OperationStatusEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperationStatusEvent& default_instance();

  static inline const OperationStatusEvent* internal_default_instance() {
    return reinterpret_cast<const OperationStatusEvent*>(
               &_OperationStatusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(OperationStatusEvent& a, OperationStatusEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationStatusEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationStatusEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperationStatusEvent* New() const final {
    return CreateMaybeMessage<OperationStatusEvent>(nullptr);
  }

  OperationStatusEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperationStatusEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperationStatusEvent& from);
  void MergeFrom(const OperationStatusEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationStatusEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.OperationStatusEvent";
  }
  protected:
  explicit OperationStatusEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto);
    return ::descriptor_table_ai_2finworld_2fpackets_2fpackets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .google.rpc.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::google::rpc::Status& status() const;
  ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.OperationStatusEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::rpc::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ai_2finworld_2fpackets_2fpackets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Actor

// .ai.inworld.packets.Actor.Type type = 1;
inline void Actor::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::Actor_Type Actor::_internal_type() const {
  return static_cast< ::ai::inworld::packets::Actor_Type >(type_);
}
inline ::ai::inworld::packets::Actor_Type Actor::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.type)
  return _internal_type();
}
inline void Actor::_internal_set_type(::ai::inworld::packets::Actor_Type value) {
  
  type_ = value;
}
inline void Actor::set_type(::ai::inworld::packets::Actor_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.type)
}

// string name = 2;
inline void Actor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Actor::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.name)
  return _internal_name();
}
inline void Actor::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Actor.name)
  return _internal_mutable_name();
}
inline const std::string& Actor::_internal_name() const {
  return name_.Get();
}
inline void Actor::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Actor::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Actor.name)
}
inline void Actor::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Actor.name)
}
inline void Actor::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Actor::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Actor.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Actor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Actor.name)
}

// -------------------------------------------------------------------

// Routing

// .ai.inworld.packets.Actor source = 1;
inline bool Routing::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Routing::has_source() const {
  return _internal_has_source();
}
inline void Routing::clear_source() {
  if (GetArena() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_source() const {
  const ::ai::inworld::packets::Actor* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::source() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.source)
  return _internal_source();
}
inline void Routing::unsafe_arena_set_allocated_source(
    ::ai::inworld::packets::Actor* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.source)
}
inline ::ai::inworld::packets::Actor* Routing::release_source() {
  
  ::ai::inworld::packets::Actor* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.source)
  
  ::ai::inworld::packets::Actor* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_source() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.source)
  return _internal_mutable_source();
}
inline void Routing::set_allocated_source(::ai::inworld::packets::Actor* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.source)
}

// .ai.inworld.packets.Actor target = 2;
inline bool Routing::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool Routing::has_target() const {
  return _internal_has_target();
}
inline void Routing::clear_target() {
  if (GetArena() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_target() const {
  const ::ai::inworld::packets::Actor* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::target() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.target)
  return _internal_target();
}
inline void Routing::unsafe_arena_set_allocated_target(
    ::ai::inworld::packets::Actor* target) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.target)
}
inline ::ai::inworld::packets::Actor* Routing::release_target() {
  
  ::ai::inworld::packets::Actor* temp = target_;
  target_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.target)
  
  ::ai::inworld::packets::Actor* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    target_ = p;
  }
  return target_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_target() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.target)
  return _internal_mutable_target();
}
inline void Routing::set_allocated_target(::ai::inworld::packets::Actor* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.target)
}

// repeated .ai.inworld.packets.Actor targets = 3;
inline int Routing::_internal_targets_size() const {
  return targets_.size();
}
inline int Routing::targets_size() const {
  return _internal_targets_size();
}
inline void Routing::clear_targets() {
  targets_.Clear();
}
inline ::ai::inworld::packets::Actor* Routing::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
Routing::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.Routing.targets)
  return &targets_;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::ai::inworld::packets::Actor& Routing::targets(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.targets)
  return _internal_targets(index);
}
inline ::ai::inworld::packets::Actor* Routing::_internal_add_targets() {
  return targets_.Add();
}
inline ::ai::inworld::packets::Actor* Routing::add_targets() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.Routing.targets)
  return _internal_add_targets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
Routing::targets() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.Routing.targets)
  return targets_;
}

// -------------------------------------------------------------------

// PacketId

// string packet_id = 1;
inline void PacketId::clear_packet_id() {
  packet_id_.ClearToEmpty();
}
inline const std::string& PacketId::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.packet_id)
  return _internal_packet_id();
}
inline void PacketId::set_packet_id(const std::string& value) {
  _internal_set_packet_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.packet_id)
  return _internal_mutable_packet_id();
}
inline const std::string& PacketId::_internal_packet_id() const {
  return packet_id_.Get();
}
inline void PacketId::_internal_set_packet_id(const std::string& value) {
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_packet_id(std::string&& value) {
  
  packet_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.packet_id)
}
inline void PacketId::set_packet_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.packet_id)
}
inline void PacketId::set_packet_id(const char* value,
    size_t size) {
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::_internal_mutable_packet_id() {
  
  return packet_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.packet_id)
  return packet_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_packet_id(std::string* packet_id) {
  if (packet_id != nullptr) {
    
  } else {
    
  }
  packet_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), packet_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.packet_id)
}

// string utterance_id = 2;
inline void PacketId::clear_utterance_id() {
  utterance_id_.ClearToEmpty();
}
inline const std::string& PacketId::utterance_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.utterance_id)
  return _internal_utterance_id();
}
inline void PacketId::set_utterance_id(const std::string& value) {
  _internal_set_utterance_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.utterance_id)
  return _internal_mutable_utterance_id();
}
inline const std::string& PacketId::_internal_utterance_id() const {
  return utterance_id_.Get();
}
inline void PacketId::_internal_set_utterance_id(const std::string& value) {
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_utterance_id(std::string&& value) {
  
  utterance_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.utterance_id)
}
inline void PacketId::set_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.utterance_id)
}
inline void PacketId::set_utterance_id(const char* value,
    size_t size) {
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::_internal_mutable_utterance_id() {
  
  return utterance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_utterance_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.utterance_id)
  return utterance_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_utterance_id(std::string* utterance_id) {
  if (utterance_id != nullptr) {
    
  } else {
    
  }
  utterance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), utterance_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.utterance_id)
}

// string interaction_id = 3;
inline void PacketId::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& PacketId::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.interaction_id)
  return _internal_interaction_id();
}
inline void PacketId::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& PacketId::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void PacketId::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.interaction_id)
}
inline void PacketId::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.interaction_id)
}
inline void PacketId::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.interaction_id)
}

// string correlation_id = 4;
inline void PacketId::clear_correlation_id() {
  correlation_id_.ClearToEmpty();
}
inline const std::string& PacketId::correlation_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.correlation_id)
  return _internal_correlation_id();
}
inline void PacketId::set_correlation_id(const std::string& value) {
  _internal_set_correlation_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::mutable_correlation_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.correlation_id)
  return _internal_mutable_correlation_id();
}
inline const std::string& PacketId::_internal_correlation_id() const {
  return correlation_id_.Get();
}
inline void PacketId::_internal_set_correlation_id(const std::string& value) {
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_correlation_id(std::string&& value) {
  
  correlation_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.correlation_id)
}
inline void PacketId::set_correlation_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.correlation_id)
}
inline void PacketId::set_correlation_id(const char* value,
    size_t size) {
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::_internal_mutable_correlation_id() {
  
  return correlation_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_correlation_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.correlation_id)
  return correlation_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  correlation_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), correlation_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.correlation_id)
}

// string conversation_id = 5;
inline void PacketId::clear_conversation_id() {
  conversation_id_.ClearToEmpty();
}
inline const std::string& PacketId::conversation_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.conversation_id)
  return _internal_conversation_id();
}
inline void PacketId::set_conversation_id(const std::string& value) {
  _internal_set_conversation_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.conversation_id)
}
inline std::string* PacketId::mutable_conversation_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.conversation_id)
  return _internal_mutable_conversation_id();
}
inline const std::string& PacketId::_internal_conversation_id() const {
  return conversation_id_.Get();
}
inline void PacketId::_internal_set_conversation_id(const std::string& value) {
  
  conversation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_conversation_id(std::string&& value) {
  
  conversation_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.conversation_id)
}
inline void PacketId::set_conversation_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  conversation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.conversation_id)
}
inline void PacketId::set_conversation_id(const char* value,
    size_t size) {
  
  conversation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.conversation_id)
}
inline std::string* PacketId::_internal_mutable_conversation_id() {
  
  return conversation_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_conversation_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.conversation_id)
  return conversation_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  conversation_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), conversation_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.conversation_id)
}

// -------------------------------------------------------------------

// InworldPacket

// .google.protobuf.Timestamp timestamp = 1;
inline bool InworldPacket::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool InworldPacket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_timestamp();
}
inline void InworldPacket::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_mutable_timestamp();
}
inline void InworldPacket::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}

// .ai.inworld.packets.Routing routing = 6;
inline bool InworldPacket::_internal_has_routing() const {
  return this != internal_default_instance() && routing_ != nullptr;
}
inline bool InworldPacket::has_routing() const {
  return _internal_has_routing();
}
inline void InworldPacket::clear_routing() {
  if (GetArena() == nullptr && routing_ != nullptr) {
    delete routing_;
  }
  routing_ = nullptr;
}
inline const ::ai::inworld::packets::Routing& InworldPacket::_internal_routing() const {
  const ::ai::inworld::packets::Routing* p = routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Routing&>(
      ::ai::inworld::packets::_Routing_default_instance_);
}
inline const ::ai::inworld::packets::Routing& InworldPacket::routing() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.routing)
  return _internal_routing();
}
inline void InworldPacket::unsafe_arena_set_allocated_routing(
    ::ai::inworld::packets::Routing* routing) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_);
  }
  routing_ = routing;
  if (routing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.routing)
}
inline ::ai::inworld::packets::Routing* InworldPacket::release_routing() {
  
  ::ai::inworld::packets::Routing* temp = routing_;
  routing_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.routing)
  
  ::ai::inworld::packets::Routing* temp = routing_;
  routing_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::_internal_mutable_routing() {
  
  if (routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Routing>(GetArena());
    routing_ = p;
  }
  return routing_;
}
inline ::ai::inworld::packets::Routing* InworldPacket::mutable_routing() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.routing)
  return _internal_mutable_routing();
}
inline void InworldPacket::set_allocated_routing(::ai::inworld::packets::Routing* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete routing_;
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(routing);
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    
  } else {
    
  }
  routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.routing)
}

// .ai.inworld.packets.PacketId packet_id = 9;
inline bool InworldPacket::_internal_has_packet_id() const {
  return this != internal_default_instance() && packet_id_ != nullptr;
}
inline bool InworldPacket::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void InworldPacket::clear_packet_id() {
  if (GetArena() == nullptr && packet_id_ != nullptr) {
    delete packet_id_;
  }
  packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_packet_id();
}
inline void InworldPacket::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_id_);
  }
  packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}
inline ::ai::inworld::packets::PacketId* InworldPacket::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::_internal_mutable_packet_id() {
  
  if (packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    packet_id_ = p;
  }
  return packet_id_;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_mutable_packet_id();
}
inline void InworldPacket::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}

// .ai.inworld.packets.TextEvent text = 2;
inline bool InworldPacket::_internal_has_text() const {
  return packet_case() == kText;
}
inline bool InworldPacket::has_text() const {
  return _internal_has_text();
}
inline void InworldPacket::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void InworldPacket::clear_text() {
  if (_internal_has_text()) {
    if (GetArena() == nullptr) {
      delete packet_.text_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
      ::ai::inworld::packets::TextEvent* temp = packet_.text_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::_internal_text() const {
  return _internal_has_text()
      ? *packet_.text_
      : reinterpret_cast< ::ai::inworld::packets::TextEvent&>(::ai::inworld::packets::_TextEvent_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.text)
  return _internal_text();
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = packet_.text_;
    packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* text) {
  clear_packet();
  if (text) {
    set_has_text();
    packet_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.text)
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_packet();
    set_has_text();
    packet_.text_ = CreateMaybeMessage< ::ai::inworld::packets::TextEvent >(GetArena());
  }
  return packet_.text_;
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.text)
  return _internal_mutable_text();
}

// .ai.inworld.packets.ControlEvent control = 3;
inline bool InworldPacket::_internal_has_control() const {
  return packet_case() == kControl;
}
inline bool InworldPacket::has_control() const {
  return _internal_has_control();
}
inline void InworldPacket::set_has_control() {
  _oneof_case_[0] = kControl;
}
inline void InworldPacket::clear_control() {
  if (_internal_has_control()) {
    if (GetArena() == nullptr) {
      delete packet_.control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::release_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
      ::ai::inworld::packets::ControlEvent* temp = packet_.control_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::_internal_control() const {
  return _internal_has_control()
      ? *packet_.control_
      : reinterpret_cast< ::ai::inworld::packets::ControlEvent&>(::ai::inworld::packets::_ControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::control() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.control)
  return _internal_control();
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = packet_.control_;
    packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* control) {
  clear_packet();
  if (control) {
    set_has_control();
    packet_.control_ = control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.control)
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::_internal_mutable_control() {
  if (!_internal_has_control()) {
    clear_packet();
    set_has_control();
    packet_.control_ = CreateMaybeMessage< ::ai::inworld::packets::ControlEvent >(GetArena());
  }
  return packet_.control_;
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::mutable_control() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.control)
  return _internal_mutable_control();
}

// .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
inline bool InworldPacket::_internal_has_audio_chunk() const {
  return packet_case() == kAudioChunk;
}
inline bool InworldPacket::has_audio_chunk() const {
  return _internal_has_audio_chunk();
}
inline void InworldPacket::set_has_audio_chunk() {
  _oneof_case_[0] = kAudioChunk;
}
inline void InworldPacket::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    if (GetArena() == nullptr) {
      delete packet_.audio_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
      ::ai::inworld::packets::AudioChunk* temp = packet_.audio_chunk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::_internal_audio_chunk() const {
  return _internal_has_audio_chunk()
      ? *packet_.audio_chunk_
      : reinterpret_cast< ::ai::inworld::packets::AudioChunk&>(::ai::inworld::packets::_AudioChunk_default_instance_);
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::audio_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_audio_chunk();
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::unsafe_arena_release_audio_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::AudioChunk* temp = packet_.audio_chunk_;
    packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk) {
  clear_packet();
  if (audio_chunk) {
    set_has_audio_chunk();
    packet_.audio_chunk_ = audio_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.audio_chunk)
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_packet();
    set_has_audio_chunk();
    packet_.audio_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::AudioChunk >(GetArena());
  }
  return packet_.audio_chunk_;
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::mutable_audio_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_mutable_audio_chunk();
}

// .ai.inworld.packets.CustomEvent custom = 8;
inline bool InworldPacket::_internal_has_custom() const {
  return packet_case() == kCustom;
}
inline bool InworldPacket::has_custom() const {
  return _internal_has_custom();
}
inline void InworldPacket::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void InworldPacket::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArena() == nullptr) {
      delete packet_.custom_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::release_custom() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
      ::ai::inworld::packets::CustomEvent* temp = packet_.custom_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::_internal_custom() const {
  return _internal_has_custom()
      ? *packet_.custom_
      : reinterpret_cast< ::ai::inworld::packets::CustomEvent&>(::ai::inworld::packets::_CustomEvent_default_instance_);
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::custom() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.custom)
  return _internal_custom();
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = packet_.custom_;
    packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* custom) {
  clear_packet();
  if (custom) {
    set_has_custom();
    packet_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.custom)
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_packet();
    set_has_custom();
    packet_.custom_ = CreateMaybeMessage< ::ai::inworld::packets::CustomEvent >(GetArena());
  }
  return packet_.custom_;
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::mutable_custom() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.custom)
  return _internal_mutable_custom();
}

// .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
inline bool InworldPacket::_internal_has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline bool InworldPacket::has_cancelresponses() const {
  return _internal_has_cancelresponses();
}
inline void InworldPacket::set_has_cancelresponses() {
  _oneof_case_[0] = kCancelResponses;
}
inline void InworldPacket::clear_cancelresponses() {
  if (_internal_has_cancelresponses()) {
    if (GetArena() == nullptr) {
      delete packet_.cancelresponses_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::release_cancelresponses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
      ::ai::inworld::packets::CancelResponsesEvent* temp = packet_.cancelresponses_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::_internal_cancelresponses() const {
  return _internal_has_cancelresponses()
      ? *packet_.cancelresponses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponsesEvent&>(::ai::inworld::packets::_CancelResponsesEvent_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::cancelresponses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_cancelresponses();
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::unsafe_arena_release_cancelresponses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = packet_.cancelresponses_;
    packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses) {
  clear_packet();
  if (cancelresponses) {
    set_has_cancelresponses();
    packet_.cancelresponses_ = cancelresponses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.cancelResponses)
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::_internal_mutable_cancelresponses() {
  if (!_internal_has_cancelresponses()) {
    clear_packet();
    set_has_cancelresponses();
    packet_.cancelresponses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponsesEvent >(GetArena());
  }
  return packet_.cancelresponses_;
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::mutable_cancelresponses() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_mutable_cancelresponses();
}

// .ai.inworld.packets.EmotionEvent emotion = 11;
inline bool InworldPacket::_internal_has_emotion() const {
  return packet_case() == kEmotion;
}
inline bool InworldPacket::has_emotion() const {
  return _internal_has_emotion();
}
inline void InworldPacket::set_has_emotion() {
  _oneof_case_[0] = kEmotion;
}
inline void InworldPacket::clear_emotion() {
  if (_internal_has_emotion()) {
    if (GetArena() == nullptr) {
      delete packet_.emotion_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::release_emotion() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
      ::ai::inworld::packets::EmotionEvent* temp = packet_.emotion_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::_internal_emotion() const {
  return _internal_has_emotion()
      ? *packet_.emotion_
      : reinterpret_cast< ::ai::inworld::packets::EmotionEvent&>(::ai::inworld::packets::_EmotionEvent_default_instance_);
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::emotion() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.emotion)
  return _internal_emotion();
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::unsafe_arena_release_emotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = packet_.emotion_;
    packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion) {
  clear_packet();
  if (emotion) {
    set_has_emotion();
    packet_.emotion_ = emotion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.emotion)
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::_internal_mutable_emotion() {
  if (!_internal_has_emotion()) {
    clear_packet();
    set_has_emotion();
    packet_.emotion_ = CreateMaybeMessage< ::ai::inworld::packets::EmotionEvent >(GetArena());
  }
  return packet_.emotion_;
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::mutable_emotion() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.emotion)
  return _internal_mutable_emotion();
}

// .ai.inworld.packets.DataChunk data_chunk = 12;
inline bool InworldPacket::_internal_has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline bool InworldPacket::has_data_chunk() const {
  return _internal_has_data_chunk();
}
inline void InworldPacket::set_has_data_chunk() {
  _oneof_case_[0] = kDataChunk;
}
inline void InworldPacket::clear_data_chunk() {
  if (_internal_has_data_chunk()) {
    if (GetArena() == nullptr) {
      delete packet_.data_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::release_data_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
      ::ai::inworld::packets::DataChunk* temp = packet_.data_chunk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::_internal_data_chunk() const {
  return _internal_has_data_chunk()
      ? *packet_.data_chunk_
      : reinterpret_cast< ::ai::inworld::packets::DataChunk&>(::ai::inworld::packets::_DataChunk_default_instance_);
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::data_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_data_chunk();
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::unsafe_arena_release_data_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = packet_.data_chunk_;
    packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk) {
  clear_packet();
  if (data_chunk) {
    set_has_data_chunk();
    packet_.data_chunk_ = data_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.data_chunk)
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::_internal_mutable_data_chunk() {
  if (!_internal_has_data_chunk()) {
    clear_packet();
    set_has_data_chunk();
    packet_.data_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::DataChunk >(GetArena());
  }
  return packet_.data_chunk_;
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::mutable_data_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_mutable_data_chunk();
}

// .ai.inworld.packets.ActionEvent action = 13;
inline bool InworldPacket::_internal_has_action() const {
  return packet_case() == kAction;
}
inline bool InworldPacket::has_action() const {
  return _internal_has_action();
}
inline void InworldPacket::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void InworldPacket::clear_action() {
  if (_internal_has_action()) {
    if (GetArena() == nullptr) {
      delete packet_.action_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::release_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
      ::ai::inworld::packets::ActionEvent* temp = packet_.action_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::_internal_action() const {
  return _internal_has_action()
      ? *packet_.action_
      : reinterpret_cast< ::ai::inworld::packets::ActionEvent&>(::ai::inworld::packets::_ActionEvent_default_instance_);
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.action)
  return _internal_action();
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
    ::ai::inworld::packets::ActionEvent* temp = packet_.action_;
    packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_action(::ai::inworld::packets::ActionEvent* action) {
  clear_packet();
  if (action) {
    set_has_action();
    packet_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.action)
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_packet();
    set_has_action();
    packet_.action_ = CreateMaybeMessage< ::ai::inworld::packets::ActionEvent >(GetArena());
  }
  return packet_.action_;
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::mutable_action() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.action)
  return _internal_mutable_action();
}

// .ai.inworld.packets.MutationEvent mutation = 15;
inline bool InworldPacket::_internal_has_mutation() const {
  return packet_case() == kMutation;
}
inline bool InworldPacket::has_mutation() const {
  return _internal_has_mutation();
}
inline void InworldPacket::set_has_mutation() {
  _oneof_case_[0] = kMutation;
}
inline void InworldPacket::clear_mutation() {
  if (_internal_has_mutation()) {
    if (GetArena() == nullptr) {
      delete packet_.mutation_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::release_mutation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
      ::ai::inworld::packets::MutationEvent* temp = packet_.mutation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::_internal_mutation() const {
  return _internal_has_mutation()
      ? *packet_.mutation_
      : reinterpret_cast< ::ai::inworld::packets::MutationEvent&>(::ai::inworld::packets::_MutationEvent_default_instance_);
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::mutation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutation();
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::unsafe_arena_release_mutation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
    ::ai::inworld::packets::MutationEvent* temp = packet_.mutation_;
    packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation) {
  clear_packet();
  if (mutation) {
    set_has_mutation();
    packet_.mutation_ = mutation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.mutation)
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::_internal_mutable_mutation() {
  if (!_internal_has_mutation()) {
    clear_packet();
    set_has_mutation();
    packet_.mutation_ = CreateMaybeMessage< ::ai::inworld::packets::MutationEvent >(GetArena());
  }
  return packet_.mutation_;
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::mutable_mutation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutable_mutation();
}

// .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16 [deprecated = true];
inline bool InworldPacket::_internal_has_load_scene_output() const {
  return packet_case() == kLoadSceneOutput;
}
inline bool InworldPacket::has_load_scene_output() const {
  return _internal_has_load_scene_output();
}
inline void InworldPacket::set_has_load_scene_output() {
  _oneof_case_[0] = kLoadSceneOutput;
}
inline void InworldPacket::clear_load_scene_output() {
  if (_internal_has_load_scene_output()) {
    if (GetArena() == nullptr) {
      delete packet_.load_scene_output_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::release_load_scene_output() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
      ::ai::inworld::packets::LoadSceneOutputEvent* temp = packet_.load_scene_output_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::_internal_load_scene_output() const {
  return _internal_has_load_scene_output()
      ? *packet_.load_scene_output_
      : reinterpret_cast< ::ai::inworld::packets::LoadSceneOutputEvent&>(::ai::inworld::packets::_LoadSceneOutputEvent_default_instance_);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::load_scene_output() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_load_scene_output();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::unsafe_arena_release_load_scene_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
    ::ai::inworld::packets::LoadSceneOutputEvent* temp = packet_.load_scene_output_;
    packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output) {
  clear_packet();
  if (load_scene_output) {
    set_has_load_scene_output();
    packet_.load_scene_output_ = load_scene_output;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.load_scene_output)
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::_internal_mutable_load_scene_output() {
  if (!_internal_has_load_scene_output()) {
    clear_packet();
    set_has_load_scene_output();
    packet_.load_scene_output_ = CreateMaybeMessage< ::ai::inworld::packets::LoadSceneOutputEvent >(GetArena());
  }
  return packet_.load_scene_output_;
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::mutable_load_scene_output() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_mutable_load_scene_output();
}

// .ai.inworld.packets.DebugInfoEvent debug_info = 18;
inline bool InworldPacket::_internal_has_debug_info() const {
  return packet_case() == kDebugInfo;
}
inline bool InworldPacket::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void InworldPacket::set_has_debug_info() {
  _oneof_case_[0] = kDebugInfo;
}
inline void InworldPacket::clear_debug_info() {
  if (_internal_has_debug_info()) {
    if (GetArena() == nullptr) {
      delete packet_.debug_info_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::release_debug_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
      ::ai::inworld::packets::DebugInfoEvent* temp = packet_.debug_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::_internal_debug_info() const {
  return _internal_has_debug_info()
      ? *packet_.debug_info_
      : reinterpret_cast< ::ai::inworld::packets::DebugInfoEvent&>(::ai::inworld::packets::_DebugInfoEvent_default_instance_);
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::debug_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_debug_info();
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
    ::ai::inworld::packets::DebugInfoEvent* temp = packet_.debug_info_;
    packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info) {
  clear_packet();
  if (debug_info) {
    set_has_debug_info();
    packet_.debug_info_ = debug_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.debug_info)
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::_internal_mutable_debug_info() {
  if (!_internal_has_debug_info()) {
    clear_packet();
    set_has_debug_info();
    packet_.debug_info_ = CreateMaybeMessage< ::ai::inworld::packets::DebugInfoEvent >(GetArena());
  }
  return packet_.debug_info_;
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_mutable_debug_info();
}

// .ai.inworld.packets.SessionControlEvent session_control = 19;
inline bool InworldPacket::_internal_has_session_control() const {
  return packet_case() == kSessionControl;
}
inline bool InworldPacket::has_session_control() const {
  return _internal_has_session_control();
}
inline void InworldPacket::set_has_session_control() {
  _oneof_case_[0] = kSessionControl;
}
inline void InworldPacket::clear_session_control() {
  if (_internal_has_session_control()) {
    if (GetArena() == nullptr) {
      delete packet_.session_control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::release_session_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.session_control)
  if (_internal_has_session_control()) {
    clear_has_packet();
      ::ai::inworld::packets::SessionControlEvent* temp = packet_.session_control_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.session_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionControlEvent& InworldPacket::_internal_session_control() const {
  return _internal_has_session_control()
      ? *packet_.session_control_
      : reinterpret_cast< ::ai::inworld::packets::SessionControlEvent&>(::ai::inworld::packets::_SessionControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::SessionControlEvent& InworldPacket::session_control() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.session_control)
  return _internal_session_control();
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::unsafe_arena_release_session_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.session_control)
  if (_internal_has_session_control()) {
    clear_has_packet();
    ::ai::inworld::packets::SessionControlEvent* temp = packet_.session_control_;
    packet_.session_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_session_control(::ai::inworld::packets::SessionControlEvent* session_control) {
  clear_packet();
  if (session_control) {
    set_has_session_control();
    packet_.session_control_ = session_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.session_control)
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::_internal_mutable_session_control() {
  if (!_internal_has_session_control()) {
    clear_packet();
    set_has_session_control();
    packet_.session_control_ = CreateMaybeMessage< ::ai::inworld::packets::SessionControlEvent >(GetArena());
  }
  return packet_.session_control_;
}
inline ::ai::inworld::packets::SessionControlEvent* InworldPacket::mutable_session_control() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.session_control)
  return _internal_mutable_session_control();
}

// .ai.inworld.packets.SessionControlResponseEvent session_control_response = 20;
inline bool InworldPacket::_internal_has_session_control_response() const {
  return packet_case() == kSessionControlResponse;
}
inline bool InworldPacket::has_session_control_response() const {
  return _internal_has_session_control_response();
}
inline void InworldPacket::set_has_session_control_response() {
  _oneof_case_[0] = kSessionControlResponse;
}
inline void InworldPacket::clear_session_control_response() {
  if (_internal_has_session_control_response()) {
    if (GetArena() == nullptr) {
      delete packet_.session_control_response_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::release_session_control_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.session_control_response)
  if (_internal_has_session_control_response()) {
    clear_has_packet();
      ::ai::inworld::packets::SessionControlResponseEvent* temp = packet_.session_control_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.session_control_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionControlResponseEvent& InworldPacket::_internal_session_control_response() const {
  return _internal_has_session_control_response()
      ? *packet_.session_control_response_
      : reinterpret_cast< ::ai::inworld::packets::SessionControlResponseEvent&>(::ai::inworld::packets::_SessionControlResponseEvent_default_instance_);
}
inline const ::ai::inworld::packets::SessionControlResponseEvent& InworldPacket::session_control_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.session_control_response)
  return _internal_session_control_response();
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::unsafe_arena_release_session_control_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.session_control_response)
  if (_internal_has_session_control_response()) {
    clear_has_packet();
    ::ai::inworld::packets::SessionControlResponseEvent* temp = packet_.session_control_response_;
    packet_.session_control_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_session_control_response(::ai::inworld::packets::SessionControlResponseEvent* session_control_response) {
  clear_packet();
  if (session_control_response) {
    set_has_session_control_response();
    packet_.session_control_response_ = session_control_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.session_control_response)
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::_internal_mutable_session_control_response() {
  if (!_internal_has_session_control_response()) {
    clear_packet();
    set_has_session_control_response();
    packet_.session_control_response_ = CreateMaybeMessage< ::ai::inworld::packets::SessionControlResponseEvent >(GetArena());
  }
  return packet_.session_control_response_;
}
inline ::ai::inworld::packets::SessionControlResponseEvent* InworldPacket::mutable_session_control_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.session_control_response)
  return _internal_mutable_session_control_response();
}

// .ai.inworld.packets.LatencyReportEvent latency_report = 22;
inline bool InworldPacket::_internal_has_latency_report() const {
  return packet_case() == kLatencyReport;
}
inline bool InworldPacket::has_latency_report() const {
  return _internal_has_latency_report();
}
inline void InworldPacket::set_has_latency_report() {
  _oneof_case_[0] = kLatencyReport;
}
inline void InworldPacket::clear_latency_report() {
  if (_internal_has_latency_report()) {
    if (GetArena() == nullptr) {
      delete packet_.latency_report_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LatencyReportEvent* InworldPacket::release_latency_report() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.latency_report)
  if (_internal_has_latency_report()) {
    clear_has_packet();
      ::ai::inworld::packets::LatencyReportEvent* temp = packet_.latency_report_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.latency_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LatencyReportEvent& InworldPacket::_internal_latency_report() const {
  return _internal_has_latency_report()
      ? *packet_.latency_report_
      : reinterpret_cast< ::ai::inworld::packets::LatencyReportEvent&>(::ai::inworld::packets::_LatencyReportEvent_default_instance_);
}
inline const ::ai::inworld::packets::LatencyReportEvent& InworldPacket::latency_report() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.latency_report)
  return _internal_latency_report();
}
inline ::ai::inworld::packets::LatencyReportEvent* InworldPacket::unsafe_arena_release_latency_report() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.latency_report)
  if (_internal_has_latency_report()) {
    clear_has_packet();
    ::ai::inworld::packets::LatencyReportEvent* temp = packet_.latency_report_;
    packet_.latency_report_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_latency_report(::ai::inworld::packets::LatencyReportEvent* latency_report) {
  clear_packet();
  if (latency_report) {
    set_has_latency_report();
    packet_.latency_report_ = latency_report;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.latency_report)
}
inline ::ai::inworld::packets::LatencyReportEvent* InworldPacket::_internal_mutable_latency_report() {
  if (!_internal_has_latency_report()) {
    clear_packet();
    set_has_latency_report();
    packet_.latency_report_ = CreateMaybeMessage< ::ai::inworld::packets::LatencyReportEvent >(GetArena());
  }
  return packet_.latency_report_;
}
inline ::ai::inworld::packets::LatencyReportEvent* InworldPacket::mutable_latency_report() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.latency_report)
  return _internal_mutable_latency_report();
}

// .ai.inworld.packets.OperationStatusEvent operation_status = 23;
inline bool InworldPacket::_internal_has_operation_status() const {
  return packet_case() == kOperationStatus;
}
inline bool InworldPacket::has_operation_status() const {
  return _internal_has_operation_status();
}
inline void InworldPacket::set_has_operation_status() {
  _oneof_case_[0] = kOperationStatus;
}
inline void InworldPacket::clear_operation_status() {
  if (_internal_has_operation_status()) {
    if (GetArena() == nullptr) {
      delete packet_.operation_status_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::OperationStatusEvent* InworldPacket::release_operation_status() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.operation_status)
  if (_internal_has_operation_status()) {
    clear_has_packet();
      ::ai::inworld::packets::OperationStatusEvent* temp = packet_.operation_status_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.operation_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::OperationStatusEvent& InworldPacket::_internal_operation_status() const {
  return _internal_has_operation_status()
      ? *packet_.operation_status_
      : reinterpret_cast< ::ai::inworld::packets::OperationStatusEvent&>(::ai::inworld::packets::_OperationStatusEvent_default_instance_);
}
inline const ::ai::inworld::packets::OperationStatusEvent& InworldPacket::operation_status() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.operation_status)
  return _internal_operation_status();
}
inline ::ai::inworld::packets::OperationStatusEvent* InworldPacket::unsafe_arena_release_operation_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.operation_status)
  if (_internal_has_operation_status()) {
    clear_has_packet();
    ::ai::inworld::packets::OperationStatusEvent* temp = packet_.operation_status_;
    packet_.operation_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_operation_status(::ai::inworld::packets::OperationStatusEvent* operation_status) {
  clear_packet();
  if (operation_status) {
    set_has_operation_status();
    packet_.operation_status_ = operation_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.operation_status)
}
inline ::ai::inworld::packets::OperationStatusEvent* InworldPacket::_internal_mutable_operation_status() {
  if (!_internal_has_operation_status()) {
    clear_packet();
    set_has_operation_status();
    packet_.operation_status_ = CreateMaybeMessage< ::ai::inworld::packets::OperationStatusEvent >(GetArena());
  }
  return packet_.operation_status_;
}
inline ::ai::inworld::packets::OperationStatusEvent* InworldPacket::mutable_operation_status() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.operation_status)
  return _internal_mutable_operation_status();
}

// .ai.inworld.packets.entities.ItemsOperationEvent entities_items_operation = 24;
inline bool InworldPacket::_internal_has_entities_items_operation() const {
  return packet_case() == kEntitiesItemsOperation;
}
inline bool InworldPacket::has_entities_items_operation() const {
  return _internal_has_entities_items_operation();
}
inline void InworldPacket::set_has_entities_items_operation() {
  _oneof_case_[0] = kEntitiesItemsOperation;
}
inline ::ai::inworld::packets::entities::ItemsOperationEvent* InworldPacket::release_entities_items_operation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.entities_items_operation)
  if (_internal_has_entities_items_operation()) {
    clear_has_packet();
      ::ai::inworld::packets::entities::ItemsOperationEvent* temp = packet_.entities_items_operation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.entities_items_operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::entities::ItemsOperationEvent& InworldPacket::_internal_entities_items_operation() const {
  return _internal_has_entities_items_operation()
      ? *packet_.entities_items_operation_
      : reinterpret_cast< ::ai::inworld::packets::entities::ItemsOperationEvent&>(::ai::inworld::packets::entities::_ItemsOperationEvent_default_instance_);
}
inline const ::ai::inworld::packets::entities::ItemsOperationEvent& InworldPacket::entities_items_operation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.entities_items_operation)
  return _internal_entities_items_operation();
}
inline ::ai::inworld::packets::entities::ItemsOperationEvent* InworldPacket::unsafe_arena_release_entities_items_operation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.entities_items_operation)
  if (_internal_has_entities_items_operation()) {
    clear_has_packet();
    ::ai::inworld::packets::entities::ItemsOperationEvent* temp = packet_.entities_items_operation_;
    packet_.entities_items_operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_entities_items_operation(::ai::inworld::packets::entities::ItemsOperationEvent* entities_items_operation) {
  clear_packet();
  if (entities_items_operation) {
    set_has_entities_items_operation();
    packet_.entities_items_operation_ = entities_items_operation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.entities_items_operation)
}
inline ::ai::inworld::packets::entities::ItemsOperationEvent* InworldPacket::_internal_mutable_entities_items_operation() {
  if (!_internal_has_entities_items_operation()) {
    clear_packet();
    set_has_entities_items_operation();
    packet_.entities_items_operation_ = CreateMaybeMessage< ::ai::inworld::packets::entities::ItemsOperationEvent >(GetArena());
  }
  return packet_.entities_items_operation_;
}
inline ::ai::inworld::packets::entities::ItemsOperationEvent* InworldPacket::mutable_entities_items_operation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.entities_items_operation)
  return _internal_mutable_entities_items_operation();
}

// .ai.inworld.packets.LogsEvent log = 25;
inline bool InworldPacket::_internal_has_log() const {
  return packet_case() == kLog;
}
inline bool InworldPacket::has_log() const {
  return _internal_has_log();
}
inline void InworldPacket::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void InworldPacket::clear_log() {
  if (_internal_has_log()) {
    if (GetArena() == nullptr) {
      delete packet_.log_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LogsEvent* InworldPacket::release_log() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.log)
  if (_internal_has_log()) {
    clear_has_packet();
      ::ai::inworld::packets::LogsEvent* temp = packet_.log_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LogsEvent& InworldPacket::_internal_log() const {
  return _internal_has_log()
      ? *packet_.log_
      : reinterpret_cast< ::ai::inworld::packets::LogsEvent&>(::ai::inworld::packets::_LogsEvent_default_instance_);
}
inline const ::ai::inworld::packets::LogsEvent& InworldPacket::log() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.log)
  return _internal_log();
}
inline ::ai::inworld::packets::LogsEvent* InworldPacket::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.log)
  if (_internal_has_log()) {
    clear_has_packet();
    ::ai::inworld::packets::LogsEvent* temp = packet_.log_;
    packet_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_log(::ai::inworld::packets::LogsEvent* log) {
  clear_packet();
  if (log) {
    set_has_log();
    packet_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.log)
}
inline ::ai::inworld::packets::LogsEvent* InworldPacket::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_packet();
    set_has_log();
    packet_.log_ = CreateMaybeMessage< ::ai::inworld::packets::LogsEvent >(GetArena());
  }
  return packet_.log_;
}
inline ::ai::inworld::packets::LogsEvent* InworldPacket::mutable_log() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.log)
  return _internal_mutable_log();
}

inline bool InworldPacket::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void InworldPacket::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline InworldPacket::PacketCase InworldPacket::packet_case() const {
  return InworldPacket::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextEvent_ModelInfo

// string service = 1;
inline void TextEvent_ModelInfo::clear_service() {
  service_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::service() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _internal_service();
}
inline void TextEvent_ModelInfo::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline std::string* TextEvent_ModelInfo::mutable_service() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _internal_mutable_service();
}
inline const std::string& TextEvent_ModelInfo::_internal_service() const {
  return service_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_service(const std::string& value) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent_ModelInfo::set_service(std::string&& value) {
  
  service_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline void TextEvent_ModelInfo::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline void TextEvent_ModelInfo::set_service(const char* value,
    size_t size) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_service() {
  
  return service_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent_ModelInfo::release_service() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent_ModelInfo::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.service)
}

// string model = 2;
inline void TextEvent_ModelInfo::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::model() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _internal_model();
}
inline void TextEvent_ModelInfo::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline std::string* TextEvent_ModelInfo::mutable_model() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _internal_mutable_model();
}
inline const std::string& TextEvent_ModelInfo::_internal_model() const {
  return model_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent_ModelInfo::set_model(std::string&& value) {
  
  model_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline void TextEvent_ModelInfo::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline void TextEvent_ModelInfo::set_model(const char* value,
    size_t size) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent_ModelInfo::release_model() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent_ModelInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.model)
}

// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.text)
  return _internal_text();
}
inline void TextEvent::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.text)
  return _internal_mutable_text();
}
inline const std::string& TextEvent::_internal_text() const {
  return text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.text)
}
inline void TextEvent::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.text)
}
inline void TextEvent::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.text)
}

// .ai.inworld.packets.TextEvent.SourceType source_type = 2;
inline void TextEvent::clear_source_type() {
  source_type_ = 0;
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::_internal_source_type() const {
  return static_cast< ::ai::inworld::packets::TextEvent_SourceType >(source_type_);
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::source_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.source_type)
  return _internal_source_type();
}
inline void TextEvent::_internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  
  source_type_ = value;
}
inline void TextEvent::set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.source_type)
}

// bool final = 3;
inline void TextEvent::clear_final() {
  final_ = false;
}
inline bool TextEvent::_internal_final() const {
  return final_;
}
inline bool TextEvent::final() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.final)
  return _internal_final();
}
inline void TextEvent::_internal_set_final(bool value) {
  
  final_ = value;
}
inline void TextEvent::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.final)
}

// .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
inline bool TextEvent::_internal_has_model_info() const {
  return this != internal_default_instance() && model_info_ != nullptr;
}
inline bool TextEvent::has_model_info() const {
  return _internal_has_model_info();
}
inline void TextEvent::clear_model_info() {
  if (GetArena() == nullptr && model_info_ != nullptr) {
    delete model_info_;
  }
  model_info_ = nullptr;
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::_internal_model_info() const {
  const ::ai::inworld::packets::TextEvent_ModelInfo* p = model_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::TextEvent_ModelInfo&>(
      ::ai::inworld::packets::_TextEvent_ModelInfo_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::model_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.model_info)
  return _internal_model_info();
}
inline void TextEvent::unsafe_arena_set_allocated_model_info(
    ::ai::inworld::packets::TextEvent_ModelInfo* model_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_info_);
  }
  model_info_ = model_info;
  if (model_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.TextEvent.model_info)
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::release_model_info() {
  
  ::ai::inworld::packets::TextEvent_ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.model_info)
  
  ::ai::inworld::packets::TextEvent_ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::_internal_mutable_model_info() {
  
  if (model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::TextEvent_ModelInfo>(GetArena());
    model_info_ = p;
  }
  return model_info_;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.model_info)
  return _internal_mutable_model_info();
}
inline void TextEvent::set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete model_info_;
  }
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_info);
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    
  } else {
    
  }
  model_info_ = model_info;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.model_info)
}

// -------------------------------------------------------------------

// ControlEvent

// .ai.inworld.packets.ControlEvent.Action action = 1;
inline void ControlEvent::clear_action() {
  action_ = 0;
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::_internal_action() const {
  return static_cast< ::ai::inworld::packets::ControlEvent_Action >(action_);
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.action)
  return _internal_action();
}
inline void ControlEvent::_internal_set_action(::ai::inworld::packets::ControlEvent_Action value) {
  
  action_ = value;
}
inline void ControlEvent::set_action(::ai::inworld::packets::ControlEvent_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.action)
}

// string description = 2;
inline void ControlEvent::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ControlEvent::description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.description)
  return _internal_description();
}
inline void ControlEvent::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::mutable_description() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.description)
  return _internal_mutable_description();
}
inline const std::string& ControlEvent::_internal_description() const {
  return description_.Get();
}
inline void ControlEvent::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ControlEvent::set_description(std::string&& value) {
  
  description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ControlEvent.description)
}
inline void ControlEvent::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ControlEvent.description)
}
inline void ControlEvent::set_description(const char* value,
    size_t size) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ControlEvent::release_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlEvent::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.description)
}

// .google.protobuf.Struct payload = 3;
inline bool ControlEvent::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool ControlEvent::has_payload() const {
  return _internal_has_payload();
}
inline const PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::_internal_payload() const {
  const PROTOBUF_NAMESPACE_ID::Struct* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Struct&>(
      PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::payload() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.payload)
  return _internal_payload();
}
inline void ControlEvent::unsafe_arena_set_allocated_payload(
    PROTOBUF_NAMESPACE_ID::Struct* payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.payload)
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::release_payload() {
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = payload_;
  payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.payload)
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Struct>(GetArena());
    payload_ = p;
  }
  return payload_;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.payload)
  return _internal_mutable_payload();
}
inline void ControlEvent::set_allocated_payload(PROTOBUF_NAMESPACE_ID::Struct* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload)->GetArena();
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.payload)
}

// .ai.inworld.packets.ConversationUpdatePayload conversation_update = 4;
inline bool ControlEvent::_internal_has_conversation_update() const {
  return payload_structured_case() == kConversationUpdate;
}
inline bool ControlEvent::has_conversation_update() const {
  return _internal_has_conversation_update();
}
inline void ControlEvent::set_has_conversation_update() {
  _oneof_case_[0] = kConversationUpdate;
}
inline void ControlEvent::clear_conversation_update() {
  if (_internal_has_conversation_update()) {
    if (GetArena() == nullptr) {
      delete payload_structured_.conversation_update_;
    }
    clear_has_payload_structured();
  }
}
inline ::ai::inworld::packets::ConversationUpdatePayload* ControlEvent::release_conversation_update() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.conversation_update)
  if (_internal_has_conversation_update()) {
    clear_has_payload_structured();
      ::ai::inworld::packets::ConversationUpdatePayload* temp = payload_structured_.conversation_update_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_structured_.conversation_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ConversationUpdatePayload& ControlEvent::_internal_conversation_update() const {
  return _internal_has_conversation_update()
      ? *payload_structured_.conversation_update_
      : reinterpret_cast< ::ai::inworld::packets::ConversationUpdatePayload&>(::ai::inworld::packets::_ConversationUpdatePayload_default_instance_);
}
inline const ::ai::inworld::packets::ConversationUpdatePayload& ControlEvent::conversation_update() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.conversation_update)
  return _internal_conversation_update();
}
inline ::ai::inworld::packets::ConversationUpdatePayload* ControlEvent::unsafe_arena_release_conversation_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ControlEvent.conversation_update)
  if (_internal_has_conversation_update()) {
    clear_has_payload_structured();
    ::ai::inworld::packets::ConversationUpdatePayload* temp = payload_structured_.conversation_update_;
    payload_structured_.conversation_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlEvent::unsafe_arena_set_allocated_conversation_update(::ai::inworld::packets::ConversationUpdatePayload* conversation_update) {
  clear_payload_structured();
  if (conversation_update) {
    set_has_conversation_update();
    payload_structured_.conversation_update_ = conversation_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.conversation_update)
}
inline ::ai::inworld::packets::ConversationUpdatePayload* ControlEvent::_internal_mutable_conversation_update() {
  if (!_internal_has_conversation_update()) {
    clear_payload_structured();
    set_has_conversation_update();
    payload_structured_.conversation_update_ = CreateMaybeMessage< ::ai::inworld::packets::ConversationUpdatePayload >(GetArena());
  }
  return payload_structured_.conversation_update_;
}
inline ::ai::inworld::packets::ConversationUpdatePayload* ControlEvent::mutable_conversation_update() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.conversation_update)
  return _internal_mutable_conversation_update();
}

// .ai.inworld.packets.ConversationEventPayload conversation_event = 5;
inline bool ControlEvent::_internal_has_conversation_event() const {
  return payload_structured_case() == kConversationEvent;
}
inline bool ControlEvent::has_conversation_event() const {
  return _internal_has_conversation_event();
}
inline void ControlEvent::set_has_conversation_event() {
  _oneof_case_[0] = kConversationEvent;
}
inline void ControlEvent::clear_conversation_event() {
  if (_internal_has_conversation_event()) {
    if (GetArena() == nullptr) {
      delete payload_structured_.conversation_event_;
    }
    clear_has_payload_structured();
  }
}
inline ::ai::inworld::packets::ConversationEventPayload* ControlEvent::release_conversation_event() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.conversation_event)
  if (_internal_has_conversation_event()) {
    clear_has_payload_structured();
      ::ai::inworld::packets::ConversationEventPayload* temp = payload_structured_.conversation_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_structured_.conversation_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ConversationEventPayload& ControlEvent::_internal_conversation_event() const {
  return _internal_has_conversation_event()
      ? *payload_structured_.conversation_event_
      : reinterpret_cast< ::ai::inworld::packets::ConversationEventPayload&>(::ai::inworld::packets::_ConversationEventPayload_default_instance_);
}
inline const ::ai::inworld::packets::ConversationEventPayload& ControlEvent::conversation_event() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.conversation_event)
  return _internal_conversation_event();
}
inline ::ai::inworld::packets::ConversationEventPayload* ControlEvent::unsafe_arena_release_conversation_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ControlEvent.conversation_event)
  if (_internal_has_conversation_event()) {
    clear_has_payload_structured();
    ::ai::inworld::packets::ConversationEventPayload* temp = payload_structured_.conversation_event_;
    payload_structured_.conversation_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlEvent::unsafe_arena_set_allocated_conversation_event(::ai::inworld::packets::ConversationEventPayload* conversation_event) {
  clear_payload_structured();
  if (conversation_event) {
    set_has_conversation_event();
    payload_structured_.conversation_event_ = conversation_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.conversation_event)
}
inline ::ai::inworld::packets::ConversationEventPayload* ControlEvent::_internal_mutable_conversation_event() {
  if (!_internal_has_conversation_event()) {
    clear_payload_structured();
    set_has_conversation_event();
    payload_structured_.conversation_event_ = CreateMaybeMessage< ::ai::inworld::packets::ConversationEventPayload >(GetArena());
  }
  return payload_structured_.conversation_event_;
}
inline ::ai::inworld::packets::ConversationEventPayload* ControlEvent::mutable_conversation_event() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.conversation_event)
  return _internal_mutable_conversation_event();
}

// .ai.inworld.packets.AudioSessionStartPayload audio_session_start = 6;
inline bool ControlEvent::_internal_has_audio_session_start() const {
  return payload_structured_case() == kAudioSessionStart;
}
inline bool ControlEvent::has_audio_session_start() const {
  return _internal_has_audio_session_start();
}
inline void ControlEvent::set_has_audio_session_start() {
  _oneof_case_[0] = kAudioSessionStart;
}
inline void ControlEvent::clear_audio_session_start() {
  if (_internal_has_audio_session_start()) {
    if (GetArena() == nullptr) {
      delete payload_structured_.audio_session_start_;
    }
    clear_has_payload_structured();
  }
}
inline ::ai::inworld::packets::AudioSessionStartPayload* ControlEvent::release_audio_session_start() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.audio_session_start)
  if (_internal_has_audio_session_start()) {
    clear_has_payload_structured();
      ::ai::inworld::packets::AudioSessionStartPayload* temp = payload_structured_.audio_session_start_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_structured_.audio_session_start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::AudioSessionStartPayload& ControlEvent::_internal_audio_session_start() const {
  return _internal_has_audio_session_start()
      ? *payload_structured_.audio_session_start_
      : reinterpret_cast< ::ai::inworld::packets::AudioSessionStartPayload&>(::ai::inworld::packets::_AudioSessionStartPayload_default_instance_);
}
inline const ::ai::inworld::packets::AudioSessionStartPayload& ControlEvent::audio_session_start() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.audio_session_start)
  return _internal_audio_session_start();
}
inline ::ai::inworld::packets::AudioSessionStartPayload* ControlEvent::unsafe_arena_release_audio_session_start() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ControlEvent.audio_session_start)
  if (_internal_has_audio_session_start()) {
    clear_has_payload_structured();
    ::ai::inworld::packets::AudioSessionStartPayload* temp = payload_structured_.audio_session_start_;
    payload_structured_.audio_session_start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlEvent::unsafe_arena_set_allocated_audio_session_start(::ai::inworld::packets::AudioSessionStartPayload* audio_session_start) {
  clear_payload_structured();
  if (audio_session_start) {
    set_has_audio_session_start();
    payload_structured_.audio_session_start_ = audio_session_start;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.audio_session_start)
}
inline ::ai::inworld::packets::AudioSessionStartPayload* ControlEvent::_internal_mutable_audio_session_start() {
  if (!_internal_has_audio_session_start()) {
    clear_payload_structured();
    set_has_audio_session_start();
    payload_structured_.audio_session_start_ = CreateMaybeMessage< ::ai::inworld::packets::AudioSessionStartPayload >(GetArena());
  }
  return payload_structured_.audio_session_start_;
}
inline ::ai::inworld::packets::AudioSessionStartPayload* ControlEvent::mutable_audio_session_start() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.audio_session_start)
  return _internal_mutable_audio_session_start();
}

// .ai.inworld.packets.CurrentSceneStatus current_scene_status = 7;
inline bool ControlEvent::_internal_has_current_scene_status() const {
  return payload_structured_case() == kCurrentSceneStatus;
}
inline bool ControlEvent::has_current_scene_status() const {
  return _internal_has_current_scene_status();
}
inline void ControlEvent::set_has_current_scene_status() {
  _oneof_case_[0] = kCurrentSceneStatus;
}
inline void ControlEvent::clear_current_scene_status() {
  if (_internal_has_current_scene_status()) {
    if (GetArena() == nullptr) {
      delete payload_structured_.current_scene_status_;
    }
    clear_has_payload_structured();
  }
}
inline ::ai::inworld::packets::CurrentSceneStatus* ControlEvent::release_current_scene_status() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.current_scene_status)
  if (_internal_has_current_scene_status()) {
    clear_has_payload_structured();
      ::ai::inworld::packets::CurrentSceneStatus* temp = payload_structured_.current_scene_status_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_structured_.current_scene_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CurrentSceneStatus& ControlEvent::_internal_current_scene_status() const {
  return _internal_has_current_scene_status()
      ? *payload_structured_.current_scene_status_
      : reinterpret_cast< ::ai::inworld::packets::CurrentSceneStatus&>(::ai::inworld::packets::_CurrentSceneStatus_default_instance_);
}
inline const ::ai::inworld::packets::CurrentSceneStatus& ControlEvent::current_scene_status() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.current_scene_status)
  return _internal_current_scene_status();
}
inline ::ai::inworld::packets::CurrentSceneStatus* ControlEvent::unsafe_arena_release_current_scene_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ControlEvent.current_scene_status)
  if (_internal_has_current_scene_status()) {
    clear_has_payload_structured();
    ::ai::inworld::packets::CurrentSceneStatus* temp = payload_structured_.current_scene_status_;
    payload_structured_.current_scene_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlEvent::unsafe_arena_set_allocated_current_scene_status(::ai::inworld::packets::CurrentSceneStatus* current_scene_status) {
  clear_payload_structured();
  if (current_scene_status) {
    set_has_current_scene_status();
    payload_structured_.current_scene_status_ = current_scene_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.current_scene_status)
}
inline ::ai::inworld::packets::CurrentSceneStatus* ControlEvent::_internal_mutable_current_scene_status() {
  if (!_internal_has_current_scene_status()) {
    clear_payload_structured();
    set_has_current_scene_status();
    payload_structured_.current_scene_status_ = CreateMaybeMessage< ::ai::inworld::packets::CurrentSceneStatus >(GetArena());
  }
  return payload_structured_.current_scene_status_;
}
inline ::ai::inworld::packets::CurrentSceneStatus* ControlEvent::mutable_current_scene_status() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.current_scene_status)
  return _internal_mutable_current_scene_status();
}

// .ai.inworld.packets.SessionConfigurationPayload session_configuration = 8;
inline bool ControlEvent::_internal_has_session_configuration() const {
  return payload_structured_case() == kSessionConfiguration;
}
inline bool ControlEvent::has_session_configuration() const {
  return _internal_has_session_configuration();
}
inline void ControlEvent::set_has_session_configuration() {
  _oneof_case_[0] = kSessionConfiguration;
}
inline void ControlEvent::clear_session_configuration() {
  if (_internal_has_session_configuration()) {
    if (GetArena() == nullptr) {
      delete payload_structured_.session_configuration_;
    }
    clear_has_payload_structured();
  }
}
inline ::ai::inworld::packets::SessionConfigurationPayload* ControlEvent::release_session_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.session_configuration)
  if (_internal_has_session_configuration()) {
    clear_has_payload_structured();
      ::ai::inworld::packets::SessionConfigurationPayload* temp = payload_structured_.session_configuration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_structured_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionConfigurationPayload& ControlEvent::_internal_session_configuration() const {
  return _internal_has_session_configuration()
      ? *payload_structured_.session_configuration_
      : reinterpret_cast< ::ai::inworld::packets::SessionConfigurationPayload&>(::ai::inworld::packets::_SessionConfigurationPayload_default_instance_);
}
inline const ::ai::inworld::packets::SessionConfigurationPayload& ControlEvent::session_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.session_configuration)
  return _internal_session_configuration();
}
inline ::ai::inworld::packets::SessionConfigurationPayload* ControlEvent::unsafe_arena_release_session_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ControlEvent.session_configuration)
  if (_internal_has_session_configuration()) {
    clear_has_payload_structured();
    ::ai::inworld::packets::SessionConfigurationPayload* temp = payload_structured_.session_configuration_;
    payload_structured_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlEvent::unsafe_arena_set_allocated_session_configuration(::ai::inworld::packets::SessionConfigurationPayload* session_configuration) {
  clear_payload_structured();
  if (session_configuration) {
    set_has_session_configuration();
    payload_structured_.session_configuration_ = session_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.session_configuration)
}
inline ::ai::inworld::packets::SessionConfigurationPayload* ControlEvent::_internal_mutable_session_configuration() {
  if (!_internal_has_session_configuration()) {
    clear_payload_structured();
    set_has_session_configuration();
    payload_structured_.session_configuration_ = CreateMaybeMessage< ::ai::inworld::packets::SessionConfigurationPayload >(GetArena());
  }
  return payload_structured_.session_configuration_;
}
inline ::ai::inworld::packets::SessionConfigurationPayload* ControlEvent::mutable_session_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.session_configuration)
  return _internal_mutable_session_configuration();
}

inline bool ControlEvent::has_payload_structured() const {
  return payload_structured_case() != PAYLOAD_STRUCTURED_NOT_SET;
}
inline void ControlEvent::clear_has_payload_structured() {
  _oneof_case_[0] = PAYLOAD_STRUCTURED_NOT_SET;
}
inline ControlEvent::PayloadStructuredCase ControlEvent::payload_structured_case() const {
  return ControlEvent::PayloadStructuredCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AudioSessionStartPayload

// .ai.inworld.packets.AudioSessionStartPayload.MicrophoneMode mode = 1;
inline void AudioSessionStartPayload::clear_mode() {
  mode_ = 0;
}
inline ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode AudioSessionStartPayload::_internal_mode() const {
  return static_cast< ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode >(mode_);
}
inline ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode AudioSessionStartPayload::mode() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioSessionStartPayload.mode)
  return _internal_mode();
}
inline void AudioSessionStartPayload::_internal_set_mode(::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode value) {
  
  mode_ = value;
}
inline void AudioSessionStartPayload::set_mode(::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioSessionStartPayload.mode)
}

// .ai.inworld.packets.AudioSessionStartPayload.UnderstandingMode understanding_mode = 2;
inline void AudioSessionStartPayload::clear_understanding_mode() {
  understanding_mode_ = 0;
}
inline ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode AudioSessionStartPayload::_internal_understanding_mode() const {
  return static_cast< ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode >(understanding_mode_);
}
inline ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode AudioSessionStartPayload::understanding_mode() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioSessionStartPayload.understanding_mode)
  return _internal_understanding_mode();
}
inline void AudioSessionStartPayload::_internal_set_understanding_mode(::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode value) {
  
  understanding_mode_ = value;
}
inline void AudioSessionStartPayload::set_understanding_mode(::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode value) {
  _internal_set_understanding_mode(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioSessionStartPayload.understanding_mode)
}

// -------------------------------------------------------------------

// AudioChunk

// bytes chunk = 1;
inline void AudioChunk::clear_chunk() {
  chunk_.ClearToEmpty();
}
inline const std::string& AudioChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioChunk.chunk)
  return _internal_chunk();
}
inline void AudioChunk::set_chunk(const std::string& value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::mutable_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AudioChunk.chunk)
  return _internal_mutable_chunk();
}
inline const std::string& AudioChunk::_internal_chunk() const {
  return chunk_.Get();
}
inline void AudioChunk::_internal_set_chunk(const std::string& value) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AudioChunk::set_chunk(std::string&& value) {
  
  chunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.AudioChunk.chunk)
}
inline void AudioChunk::set_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.AudioChunk.chunk)
}
inline void AudioChunk::set_chunk(const void* value,
    size_t size) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::_internal_mutable_chunk() {
  
  return chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AudioChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AudioChunk.chunk)
  return chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AudioChunk.chunk)
}

// -------------------------------------------------------------------

// CustomEvent_Parameter

// string name = 1;
inline void CustomEvent_Parameter::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_name();
}
inline void CustomEvent_Parameter::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_mutable_name();
}
inline const std::string& CustomEvent_Parameter::_internal_name() const {
  return name_.Get();
}
inline void CustomEvent_Parameter::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent_Parameter::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline void CustomEvent_Parameter::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline void CustomEvent_Parameter::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent_Parameter::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent_Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.name)
}

// string value = 2;
inline void CustomEvent_Parameter::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::value() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_value();
}
inline void CustomEvent_Parameter::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::mutable_value() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_mutable_value();
}
inline const std::string& CustomEvent_Parameter::_internal_value() const {
  return value_.Get();
}
inline void CustomEvent_Parameter::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent_Parameter::set_value(std::string&& value) {
  
  value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline void CustomEvent_Parameter::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline void CustomEvent_Parameter::set_value(const char* value,
    size_t size) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent_Parameter::release_value() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent_Parameter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.value)
}

// -------------------------------------------------------------------

// CustomEvent

// string name = 1;
inline void CustomEvent::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.name)
  return _internal_name();
}
inline void CustomEvent::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.name)
  return _internal_mutable_name();
}
inline const std::string& CustomEvent::_internal_name() const {
  return name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.name)
}
inline void CustomEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.name)
}
inline void CustomEvent::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.name)
}

// .ai.inworld.packets.Playback playback = 2;
inline void CustomEvent::clear_playback() {
  playback_ = 0;
}
inline ::ai::inworld::packets::Playback CustomEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(playback_);
}
inline ::ai::inworld::packets::Playback CustomEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.playback)
  return _internal_playback();
}
inline void CustomEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  playback_ = value;
}
inline void CustomEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.playback)
}

// repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
inline int CustomEvent::_internal_parameters_size() const {
  return parameters_.size();
}
inline int CustomEvent::parameters_size() const {
  return _internal_parameters_size();
}
inline void CustomEvent::clear_parameters() {
  parameters_.Clear();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
CustomEvent::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CustomEvent.parameters)
  return &parameters_;
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::parameters(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.parameters)
  return _internal_parameters(index);
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::add_parameters() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CustomEvent.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
CustomEvent::parameters() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CustomEvent.parameters)
  return parameters_;
}

// .ai.inworld.packets.CustomEvent.Type type = 4;
inline void CustomEvent::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::CustomEvent_Type CustomEvent::_internal_type() const {
  return static_cast< ::ai::inworld::packets::CustomEvent_Type >(type_);
}
inline ::ai::inworld::packets::CustomEvent_Type CustomEvent::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.type)
  return _internal_type();
}
inline void CustomEvent::_internal_set_type(::ai::inworld::packets::CustomEvent_Type value) {
  
  type_ = value;
}
inline void CustomEvent::set_type(::ai::inworld::packets::CustomEvent_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.type)
}

// -------------------------------------------------------------------

// CancelResponsesEvent

// string interaction_id = 1;
inline void CancelResponsesEvent::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponsesEvent::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_interaction_id();
}
inline void CancelResponsesEvent::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& CancelResponsesEvent::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void CancelResponsesEvent::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CancelResponsesEvent::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline void CancelResponsesEvent::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline void CancelResponsesEvent::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CancelResponsesEvent::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelResponsesEvent::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponsesEvent::_internal_utterance_id_size() const {
  return utterance_id_.size();
}
inline int CancelResponsesEvent::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponsesEvent::clear_utterance_id() {
  utterance_id_.Clear();
}
inline std::string* CancelResponsesEvent::add_utterance_id() {
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_add_utterance_id();
}
inline const std::string& CancelResponsesEvent::_internal_utterance_id(int index) const {
  return utterance_id_.Get(index);
}
inline const std::string& CancelResponsesEvent::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponsesEvent::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return utterance_id_.Mutable(index);
}
inline void CancelResponsesEvent::set_utterance_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  utterance_id_.Mutable(index)->assign(value);
}
inline void CancelResponsesEvent::set_utterance_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  utterance_id_.Mutable(index)->assign(std::move(value));
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value, size_t size) {
  utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline std::string* CancelResponsesEvent::_internal_add_utterance_id() {
  return utterance_id_.Add();
}
inline void CancelResponsesEvent::add_utterance_id(const std::string& value) {
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(std::string&& value) {
  utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value, size_t size) {
  utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponsesEvent::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponsesEvent::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return &utterance_id_;
}

// -------------------------------------------------------------------

// EmotionEvent

// float joy = 1;
inline void EmotionEvent::clear_joy() {
  joy_ = 0;
}
inline float EmotionEvent::_internal_joy() const {
  return joy_;
}
inline float EmotionEvent::joy() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.joy)
  return _internal_joy();
}
inline void EmotionEvent::_internal_set_joy(float value) {
  
  joy_ = value;
}
inline void EmotionEvent::set_joy(float value) {
  _internal_set_joy(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.joy)
}

// float fear = 2;
inline void EmotionEvent::clear_fear() {
  fear_ = 0;
}
inline float EmotionEvent::_internal_fear() const {
  return fear_;
}
inline float EmotionEvent::fear() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.fear)
  return _internal_fear();
}
inline void EmotionEvent::_internal_set_fear(float value) {
  
  fear_ = value;
}
inline void EmotionEvent::set_fear(float value) {
  _internal_set_fear(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.fear)
}

// float trust = 3;
inline void EmotionEvent::clear_trust() {
  trust_ = 0;
}
inline float EmotionEvent::_internal_trust() const {
  return trust_;
}
inline float EmotionEvent::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.trust)
  return _internal_trust();
}
inline void EmotionEvent::_internal_set_trust(float value) {
  
  trust_ = value;
}
inline void EmotionEvent::set_trust(float value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.trust)
}

// float surprise = 4;
inline void EmotionEvent::clear_surprise() {
  surprise_ = 0;
}
inline float EmotionEvent::_internal_surprise() const {
  return surprise_;
}
inline float EmotionEvent::surprise() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.surprise)
  return _internal_surprise();
}
inline void EmotionEvent::_internal_set_surprise(float value) {
  
  surprise_ = value;
}
inline void EmotionEvent::set_surprise(float value) {
  _internal_set_surprise(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.surprise)
}

// .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
inline void EmotionEvent::clear_behavior() {
  behavior_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::_internal_behavior() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_SpaffCode >(behavior_);
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::behavior() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.behavior)
  return _internal_behavior();
}
inline void EmotionEvent::_internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  
  behavior_ = value;
}
inline void EmotionEvent::set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.behavior)
}

// .ai.inworld.packets.EmotionEvent.Strength strength = 6;
inline void EmotionEvent::clear_strength() {
  strength_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::_internal_strength() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_Strength >(strength_);
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::strength() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.strength)
  return _internal_strength();
}
inline void EmotionEvent::_internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  
  strength_ = value;
}
inline void EmotionEvent::set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.strength)
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk = 1;
inline bool DataChunk::_internal_has_chunk() const {
  return data_case() == kChunk;
}
inline void DataChunk::set_has_chunk() {
  _oneof_case_[0] = kChunk;
}
inline void DataChunk::clear_chunk() {
  if (_internal_has_chunk()) {
    data_.chunk_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_data();
  }
}
inline const std::string& DataChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.chunk)
  return _internal_chunk();
}
inline void DataChunk::set_chunk(const std::string& value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::mutable_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.chunk)
  return _internal_mutable_chunk();
}
inline const std::string& DataChunk::_internal_chunk() const {
  if (_internal_has_chunk()) {
    return data_.chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataChunk::_internal_set_chunk(const std::string& value) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataChunk::set_chunk(std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.DataChunk.chunk)
}
inline void DataChunk::set_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.DataChunk.chunk)
}
inline void DataChunk::set_chunk(const void* value,
                             size_t size) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return data_.chunk_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DataChunk.chunk)
  if (_internal_has_chunk()) {
    clear_has_data();
    return data_.chunk_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void DataChunk::set_allocated_chunk(std::string* chunk) {
  if (has_data()) {
    clear_data();
  }
  if (chunk != nullptr) {
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(chunk);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(chunk);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DataChunk.chunk)
}

// int64 duration_ms = 3 [deprecated = true];
inline bool DataChunk::_internal_has_duration_ms() const {
  return data_case() == kDurationMs;
}
inline void DataChunk::set_has_duration_ms() {
  _oneof_case_[0] = kDurationMs;
}
inline void DataChunk::clear_duration_ms() {
  if (_internal_has_duration_ms()) {
    data_.duration_ms_ = PROTOBUF_LONGLONG(0);
    clear_has_data();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataChunk::_internal_duration_ms() const {
  if (_internal_has_duration_ms()) {
    return data_.duration_ms_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void DataChunk::_internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_duration_ms()) {
    clear_data();
    set_has_duration_ms();
  }
  data_.duration_ms_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataChunk::duration_ms() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.duration_ms)
  return _internal_duration_ms();
}
inline void DataChunk::set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.duration_ms)
}

// .ai.inworld.packets.DataChunk.DataType type = 2;
inline void DataChunk::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::_internal_type() const {
  return static_cast< ::ai::inworld::packets::DataChunk_DataType >(type_);
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.type)
  return _internal_type();
}
inline void DataChunk::_internal_set_type(::ai::inworld::packets::DataChunk_DataType value) {
  
  type_ = value;
}
inline void DataChunk::set_type(::ai::inworld::packets::DataChunk_DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.type)
}

// repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
inline int DataChunk::_internal_additional_phoneme_info_size() const {
  return additional_phoneme_info_.size();
}
inline int DataChunk::additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info_size();
}
inline void DataChunk::clear_additional_phoneme_info() {
  additional_phoneme_info_.Clear();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::mutable_additional_phoneme_info(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return additional_phoneme_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
DataChunk::mutable_additional_phoneme_info() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return &additional_phoneme_info_;
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::_internal_additional_phoneme_info(int index) const {
  return additional_phoneme_info_.Get(index);
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::additional_phoneme_info(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info(index);
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::_internal_add_additional_phoneme_info() {
  return additional_phoneme_info_.Add();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::add_additional_phoneme_info() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_add_additional_phoneme_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
DataChunk::additional_phoneme_info() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return additional_phoneme_info_;
}

// .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
inline void DataChunk::clear_audioformat() {
  audioformat_ = 0;
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::_internal_audioformat() const {
  return static_cast< ::ai::inworld::packets::DataChunk_AudioFormat >(audioformat_);
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::audioformat() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.audioFormat)
  return _internal_audioformat();
}
inline void DataChunk::_internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  
  audioformat_ = value;
}
inline void DataChunk::set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  _internal_set_audioformat(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.audioFormat)
}

inline bool DataChunk::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void DataChunk::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline DataChunk::DataCase DataChunk::data_case() const {
  return DataChunk::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdditionalPhonemeInfo

// string phoneme = 1;
inline void AdditionalPhonemeInfo::clear_phoneme() {
  phoneme_.ClearToEmpty();
}
inline const std::string& AdditionalPhonemeInfo::phoneme() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_phoneme();
}
inline void AdditionalPhonemeInfo::set_phoneme(const std::string& value) {
  _internal_set_phoneme(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::mutable_phoneme() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_mutable_phoneme();
}
inline const std::string& AdditionalPhonemeInfo::_internal_phoneme() const {
  return phoneme_.Get();
}
inline void AdditionalPhonemeInfo::_internal_set_phoneme(const std::string& value) {
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AdditionalPhonemeInfo::set_phoneme(std::string&& value) {
  
  phoneme_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline void AdditionalPhonemeInfo::set_phoneme(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline void AdditionalPhonemeInfo::set_phoneme(const char* value,
    size_t size) {
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::_internal_mutable_phoneme() {
  
  return phoneme_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AdditionalPhonemeInfo::release_phoneme() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return phoneme_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalPhonemeInfo::set_allocated_phoneme(std::string* phoneme) {
  if (phoneme != nullptr) {
    
  } else {
    
  }
  phoneme_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phoneme,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}

// .google.protobuf.Duration start_offset = 2;
inline bool AdditionalPhonemeInfo::_internal_has_start_offset() const {
  return this != internal_default_instance() && start_offset_ != nullptr;
}
inline bool AdditionalPhonemeInfo::has_start_offset() const {
  return _internal_has_start_offset();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::_internal_start_offset() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = start_offset_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration&>(
      PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::start_offset() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_start_offset();
}
inline void AdditionalPhonemeInfo::unsafe_arena_set_allocated_start_offset(
    PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset_);
  }
  start_offset_ = start_offset;
  if (start_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::release_start_offset() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = start_offset_;
  start_offset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::unsafe_arena_release_start_offset() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = start_offset_;
  start_offset_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::_internal_mutable_start_offset() {
  
  if (start_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    start_offset_ = p;
  }
  return start_offset_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::mutable_start_offset() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_mutable_start_offset();
}
inline void AdditionalPhonemeInfo::set_allocated_start_offset(PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset_);
  }
  if (start_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset)->GetArena();
    if (message_arena != submessage_arena) {
      start_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_offset, submessage_arena);
    }
    
  } else {
    
  }
  start_offset_ = start_offset;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}

// -------------------------------------------------------------------

// ActionEvent

// .ai.inworld.packets.NarratedAction narrated_action = 1;
inline bool ActionEvent::_internal_has_narrated_action() const {
  return action_case() == kNarratedAction;
}
inline bool ActionEvent::has_narrated_action() const {
  return _internal_has_narrated_action();
}
inline void ActionEvent::set_has_narrated_action() {
  _oneof_case_[0] = kNarratedAction;
}
inline void ActionEvent::clear_narrated_action() {
  if (_internal_has_narrated_action()) {
    if (GetArena() == nullptr) {
      delete action_.narrated_action_;
    }
    clear_has_action();
  }
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::release_narrated_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
      ::ai::inworld::packets::NarratedAction* temp = action_.narrated_action_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::_internal_narrated_action() const {
  return _internal_has_narrated_action()
      ? *action_.narrated_action_
      : reinterpret_cast< ::ai::inworld::packets::NarratedAction&>(::ai::inworld::packets::_NarratedAction_default_instance_);
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::narrated_action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_narrated_action();
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::unsafe_arena_release_narrated_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
    ::ai::inworld::packets::NarratedAction* temp = action_.narrated_action_;
    action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionEvent::unsafe_arena_set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action) {
  clear_action();
  if (narrated_action) {
    set_has_narrated_action();
    action_.narrated_action_ = narrated_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ActionEvent.narrated_action)
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::_internal_mutable_narrated_action() {
  if (!_internal_has_narrated_action()) {
    clear_action();
    set_has_narrated_action();
    action_.narrated_action_ = CreateMaybeMessage< ::ai::inworld::packets::NarratedAction >(GetArena());
  }
  return action_.narrated_action_;
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::mutable_narrated_action() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_mutable_narrated_action();
}

// .ai.inworld.packets.Playback playback = 2;
inline void ActionEvent::clear_playback() {
  playback_ = 0;
}
inline ::ai::inworld::packets::Playback ActionEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(playback_);
}
inline ::ai::inworld::packets::Playback ActionEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.playback)
  return _internal_playback();
}
inline void ActionEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  playback_ = value;
}
inline void ActionEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ActionEvent.playback)
}

inline bool ActionEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionEvent::ActionCase ActionEvent::action_case() const {
  return ActionEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NarratedAction

// string content = 1;
inline void NarratedAction::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& NarratedAction::content() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.NarratedAction.content)
  return _internal_content();
}
inline void NarratedAction::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::mutable_content() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.NarratedAction.content)
  return _internal_mutable_content();
}
inline const std::string& NarratedAction::_internal_content() const {
  return content_.Get();
}
inline void NarratedAction::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NarratedAction::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.NarratedAction.content)
}
inline void NarratedAction::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.NarratedAction.content)
}
inline void NarratedAction::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NarratedAction::release_content() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.NarratedAction.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NarratedAction::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.NarratedAction.content)
}

// -------------------------------------------------------------------

// RelationInfo_RelationAttributes

// int32 trust = 1;
inline void RelationInfo_RelationAttributes::clear_trust() {
  trust_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_trust() const {
  return trust_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
  return _internal_trust();
}
inline void RelationInfo_RelationAttributes::_internal_set_trust(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trust_ = value;
}
inline void RelationInfo_RelationAttributes::set_trust(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
}

// int32 respect = 2;
inline void RelationInfo_RelationAttributes::clear_respect() {
  respect_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_respect() const {
  return respect_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::respect() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
  return _internal_respect();
}
inline void RelationInfo_RelationAttributes::_internal_set_respect(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  respect_ = value;
}
inline void RelationInfo_RelationAttributes::set_respect(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_respect(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
}

// int32 familiar = 3;
inline void RelationInfo_RelationAttributes::clear_familiar() {
  familiar_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_familiar() const {
  return familiar_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::familiar() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
  return _internal_familiar();
}
inline void RelationInfo_RelationAttributes::_internal_set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  familiar_ = value;
}
inline void RelationInfo_RelationAttributes::set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_familiar(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
}

// int32 flirtatious = 4;
inline void RelationInfo_RelationAttributes::clear_flirtatious() {
  flirtatious_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_flirtatious() const {
  return flirtatious_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::flirtatious() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
  return _internal_flirtatious();
}
inline void RelationInfo_RelationAttributes::_internal_set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flirtatious_ = value;
}
inline void RelationInfo_RelationAttributes::set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flirtatious(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
}

// int32 attraction = 5;
inline void RelationInfo_RelationAttributes::clear_attraction() {
  attraction_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_attraction() const {
  return attraction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::attraction() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
  return _internal_attraction();
}
inline void RelationInfo_RelationAttributes::_internal_set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attraction_ = value;
}
inline void RelationInfo_RelationAttributes::set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attraction(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
}

// -------------------------------------------------------------------

// RelationInfo

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
inline bool RelationInfo::_internal_has_relation_state() const {
  return this != internal_default_instance() && relation_state_ != nullptr;
}
inline bool RelationInfo::has_relation_state() const {
  return _internal_has_relation_state();
}
inline void RelationInfo::clear_relation_state() {
  if (GetArena() == nullptr && relation_state_ != nullptr) {
    delete relation_state_;
  }
  relation_state_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_state() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = relation_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_state() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_relation_state();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_state(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relation_state_);
  }
  relation_state_ = relation_state;
  if (relation_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_state() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_state_;
  relation_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_state() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_state)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_state_;
  relation_state_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_state() {
  
  if (relation_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    relation_state_ = p;
  }
  return relation_state_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_state() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_mutable_relation_state();
}
inline void RelationInfo::set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relation_state_;
  }
  if (relation_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relation_state);
    if (message_arena != submessage_arena) {
      relation_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_state, submessage_arena);
    }
    
  } else {
    
  }
  relation_state_ = relation_state;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
inline bool RelationInfo::_internal_has_relation_update() const {
  return this != internal_default_instance() && relation_update_ != nullptr;
}
inline bool RelationInfo::has_relation_update() const {
  return _internal_has_relation_update();
}
inline void RelationInfo::clear_relation_update() {
  if (GetArena() == nullptr && relation_update_ != nullptr) {
    delete relation_update_;
  }
  relation_update_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_update() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = relation_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_update() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_relation_update();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_update(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relation_update_);
  }
  relation_update_ = relation_update;
  if (relation_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_update() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_update_;
  relation_update_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_update() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_update)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_update_;
  relation_update_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_update() {
  
  if (relation_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    relation_update_ = p;
  }
  return relation_update_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_update() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_mutable_relation_update();
}
inline void RelationInfo::set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relation_update_;
  }
  if (relation_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relation_update);
    if (message_arena != submessage_arena) {
      relation_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_update, submessage_arena);
    }
    
  } else {
    
  }
  relation_update_ = relation_update;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}

// -------------------------------------------------------------------

// LatencyReportEvent

// .ai.inworld.packets.PingPongReport ping_pong = 1;
inline bool LatencyReportEvent::_internal_has_ping_pong() const {
  return report_case() == kPingPong;
}
inline bool LatencyReportEvent::has_ping_pong() const {
  return _internal_has_ping_pong();
}
inline void LatencyReportEvent::set_has_ping_pong() {
  _oneof_case_[0] = kPingPong;
}
inline void LatencyReportEvent::clear_ping_pong() {
  if (_internal_has_ping_pong()) {
    if (GetArena() == nullptr) {
      delete report_.ping_pong_;
    }
    clear_has_report();
  }
}
inline ::ai::inworld::packets::PingPongReport* LatencyReportEvent::release_ping_pong() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LatencyReportEvent.ping_pong)
  if (_internal_has_ping_pong()) {
    clear_has_report();
      ::ai::inworld::packets::PingPongReport* temp = report_.ping_pong_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    report_.ping_pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::PingPongReport& LatencyReportEvent::_internal_ping_pong() const {
  return _internal_has_ping_pong()
      ? *report_.ping_pong_
      : reinterpret_cast< ::ai::inworld::packets::PingPongReport&>(::ai::inworld::packets::_PingPongReport_default_instance_);
}
inline const ::ai::inworld::packets::PingPongReport& LatencyReportEvent::ping_pong() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LatencyReportEvent.ping_pong)
  return _internal_ping_pong();
}
inline ::ai::inworld::packets::PingPongReport* LatencyReportEvent::unsafe_arena_release_ping_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.LatencyReportEvent.ping_pong)
  if (_internal_has_ping_pong()) {
    clear_has_report();
    ::ai::inworld::packets::PingPongReport* temp = report_.ping_pong_;
    report_.ping_pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LatencyReportEvent::unsafe_arena_set_allocated_ping_pong(::ai::inworld::packets::PingPongReport* ping_pong) {
  clear_report();
  if (ping_pong) {
    set_has_ping_pong();
    report_.ping_pong_ = ping_pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.LatencyReportEvent.ping_pong)
}
inline ::ai::inworld::packets::PingPongReport* LatencyReportEvent::_internal_mutable_ping_pong() {
  if (!_internal_has_ping_pong()) {
    clear_report();
    set_has_ping_pong();
    report_.ping_pong_ = CreateMaybeMessage< ::ai::inworld::packets::PingPongReport >(GetArena());
  }
  return report_.ping_pong_;
}
inline ::ai::inworld::packets::PingPongReport* LatencyReportEvent::mutable_ping_pong() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LatencyReportEvent.ping_pong)
  return _internal_mutable_ping_pong();
}

// .ai.inworld.packets.PerceivedLatencyReport perceived_latency = 2;
inline bool LatencyReportEvent::_internal_has_perceived_latency() const {
  return report_case() == kPerceivedLatency;
}
inline bool LatencyReportEvent::has_perceived_latency() const {
  return _internal_has_perceived_latency();
}
inline void LatencyReportEvent::set_has_perceived_latency() {
  _oneof_case_[0] = kPerceivedLatency;
}
inline void LatencyReportEvent::clear_perceived_latency() {
  if (_internal_has_perceived_latency()) {
    if (GetArena() == nullptr) {
      delete report_.perceived_latency_;
    }
    clear_has_report();
  }
}
inline ::ai::inworld::packets::PerceivedLatencyReport* LatencyReportEvent::release_perceived_latency() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LatencyReportEvent.perceived_latency)
  if (_internal_has_perceived_latency()) {
    clear_has_report();
      ::ai::inworld::packets::PerceivedLatencyReport* temp = report_.perceived_latency_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    report_.perceived_latency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::PerceivedLatencyReport& LatencyReportEvent::_internal_perceived_latency() const {
  return _internal_has_perceived_latency()
      ? *report_.perceived_latency_
      : reinterpret_cast< ::ai::inworld::packets::PerceivedLatencyReport&>(::ai::inworld::packets::_PerceivedLatencyReport_default_instance_);
}
inline const ::ai::inworld::packets::PerceivedLatencyReport& LatencyReportEvent::perceived_latency() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LatencyReportEvent.perceived_latency)
  return _internal_perceived_latency();
}
inline ::ai::inworld::packets::PerceivedLatencyReport* LatencyReportEvent::unsafe_arena_release_perceived_latency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.LatencyReportEvent.perceived_latency)
  if (_internal_has_perceived_latency()) {
    clear_has_report();
    ::ai::inworld::packets::PerceivedLatencyReport* temp = report_.perceived_latency_;
    report_.perceived_latency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LatencyReportEvent::unsafe_arena_set_allocated_perceived_latency(::ai::inworld::packets::PerceivedLatencyReport* perceived_latency) {
  clear_report();
  if (perceived_latency) {
    set_has_perceived_latency();
    report_.perceived_latency_ = perceived_latency;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.LatencyReportEvent.perceived_latency)
}
inline ::ai::inworld::packets::PerceivedLatencyReport* LatencyReportEvent::_internal_mutable_perceived_latency() {
  if (!_internal_has_perceived_latency()) {
    clear_report();
    set_has_perceived_latency();
    report_.perceived_latency_ = CreateMaybeMessage< ::ai::inworld::packets::PerceivedLatencyReport >(GetArena());
  }
  return report_.perceived_latency_;
}
inline ::ai::inworld::packets::PerceivedLatencyReport* LatencyReportEvent::mutable_perceived_latency() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LatencyReportEvent.perceived_latency)
  return _internal_mutable_perceived_latency();
}

inline bool LatencyReportEvent::has_report() const {
  return report_case() != REPORT_NOT_SET;
}
inline void LatencyReportEvent::clear_has_report() {
  _oneof_case_[0] = REPORT_NOT_SET;
}
inline LatencyReportEvent::ReportCase LatencyReportEvent::report_case() const {
  return LatencyReportEvent::ReportCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PingPongReport

// .ai.inworld.packets.PingPongReport.Type type = 1;
inline void PingPongReport::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::PingPongReport_Type PingPongReport::_internal_type() const {
  return static_cast< ::ai::inworld::packets::PingPongReport_Type >(type_);
}
inline ::ai::inworld::packets::PingPongReport_Type PingPongReport::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PingPongReport.type)
  return _internal_type();
}
inline void PingPongReport::_internal_set_type(::ai::inworld::packets::PingPongReport_Type value) {
  
  type_ = value;
}
inline void PingPongReport::set_type(::ai::inworld::packets::PingPongReport_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PingPongReport.type)
}

// .ai.inworld.packets.PacketId ping_packet_id = 2;
inline bool PingPongReport::_internal_has_ping_packet_id() const {
  return this != internal_default_instance() && ping_packet_id_ != nullptr;
}
inline bool PingPongReport::has_ping_packet_id() const {
  return _internal_has_ping_packet_id();
}
inline void PingPongReport::clear_ping_packet_id() {
  if (GetArena() == nullptr && ping_packet_id_ != nullptr) {
    delete ping_packet_id_;
  }
  ping_packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& PingPongReport::_internal_ping_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = ping_packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& PingPongReport::ping_packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PingPongReport.ping_packet_id)
  return _internal_ping_packet_id();
}
inline void PingPongReport::unsafe_arena_set_allocated_ping_packet_id(
    ::ai::inworld::packets::PacketId* ping_packet_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_packet_id_);
  }
  ping_packet_id_ = ping_packet_id;
  if (ping_packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.PingPongReport.ping_packet_id)
}
inline ::ai::inworld::packets::PacketId* PingPongReport::release_ping_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = ping_packet_id_;
  ping_packet_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::PacketId* PingPongReport::unsafe_arena_release_ping_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PingPongReport.ping_packet_id)
  
  ::ai::inworld::packets::PacketId* temp = ping_packet_id_;
  ping_packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* PingPongReport::_internal_mutable_ping_packet_id() {
  
  if (ping_packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    ping_packet_id_ = p;
  }
  return ping_packet_id_;
}
inline ::ai::inworld::packets::PacketId* PingPongReport::mutable_ping_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PingPongReport.ping_packet_id)
  return _internal_mutable_ping_packet_id();
}
inline void PingPongReport::set_allocated_ping_packet_id(::ai::inworld::packets::PacketId* ping_packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ping_packet_id_;
  }
  if (ping_packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ping_packet_id);
    if (message_arena != submessage_arena) {
      ping_packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping_packet_id, submessage_arena);
    }
    
  } else {
    
  }
  ping_packet_id_ = ping_packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PingPongReport.ping_packet_id)
}

// .google.protobuf.Timestamp ping_timestamp = 3;
inline bool PingPongReport::_internal_has_ping_timestamp() const {
  return this != internal_default_instance() && ping_timestamp_ != nullptr;
}
inline bool PingPongReport::has_ping_timestamp() const {
  return _internal_has_ping_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PingPongReport::_internal_ping_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = ping_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PingPongReport::ping_timestamp() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PingPongReport.ping_timestamp)
  return _internal_ping_timestamp();
}
inline void PingPongReport::unsafe_arena_set_allocated_ping_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* ping_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_timestamp_);
  }
  ping_timestamp_ = ping_timestamp;
  if (ping_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.PingPongReport.ping_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PingPongReport::release_ping_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = ping_timestamp_;
  ping_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PingPongReport::unsafe_arena_release_ping_timestamp() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PingPongReport.ping_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = ping_timestamp_;
  ping_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PingPongReport::_internal_mutable_ping_timestamp() {
  
  if (ping_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    ping_timestamp_ = p;
  }
  return ping_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PingPongReport::mutable_ping_timestamp() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PingPongReport.ping_timestamp)
  return _internal_mutable_ping_timestamp();
}
inline void PingPongReport::set_allocated_ping_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* ping_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_timestamp_);
  }
  if (ping_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      ping_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  ping_timestamp_ = ping_timestamp;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PingPongReport.ping_timestamp)
}

// -------------------------------------------------------------------

// PerceivedLatencyReport

// .ai.inworld.packets.PerceivedLatencyReport.Precision precision = 1;
inline void PerceivedLatencyReport::clear_precision() {
  precision_ = 0;
}
inline ::ai::inworld::packets::PerceivedLatencyReport_Precision PerceivedLatencyReport::_internal_precision() const {
  return static_cast< ::ai::inworld::packets::PerceivedLatencyReport_Precision >(precision_);
}
inline ::ai::inworld::packets::PerceivedLatencyReport_Precision PerceivedLatencyReport::precision() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PerceivedLatencyReport.precision)
  return _internal_precision();
}
inline void PerceivedLatencyReport::_internal_set_precision(::ai::inworld::packets::PerceivedLatencyReport_Precision value) {
  
  precision_ = value;
}
inline void PerceivedLatencyReport::set_precision(::ai::inworld::packets::PerceivedLatencyReport_Precision value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PerceivedLatencyReport.precision)
}

// .google.protobuf.Duration latency = 2;
inline bool PerceivedLatencyReport::_internal_has_latency() const {
  return this != internal_default_instance() && latency_ != nullptr;
}
inline bool PerceivedLatencyReport::has_latency() const {
  return _internal_has_latency();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& PerceivedLatencyReport::_internal_latency() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = latency_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration&>(
      PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& PerceivedLatencyReport::latency() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PerceivedLatencyReport.latency)
  return _internal_latency();
}
inline void PerceivedLatencyReport::unsafe_arena_set_allocated_latency(
    PROTOBUF_NAMESPACE_ID::Duration* latency) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_);
  }
  latency_ = latency;
  if (latency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.PerceivedLatencyReport.latency)
}
inline PROTOBUF_NAMESPACE_ID::Duration* PerceivedLatencyReport::release_latency() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = latency_;
  latency_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PerceivedLatencyReport::unsafe_arena_release_latency() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PerceivedLatencyReport.latency)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = latency_;
  latency_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PerceivedLatencyReport::_internal_mutable_latency() {
  
  if (latency_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    latency_ = p;
  }
  return latency_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PerceivedLatencyReport::mutable_latency() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PerceivedLatencyReport.latency)
  return _internal_mutable_latency();
}
inline void PerceivedLatencyReport::set_allocated_latency(PROTOBUF_NAMESPACE_ID::Duration* latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_);
  }
  if (latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency)->GetArena();
    if (message_arena != submessage_arena) {
      latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latency, submessage_arena);
    }
    
  } else {
    
  }
  latency_ = latency;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PerceivedLatencyReport.latency)
}

// -------------------------------------------------------------------

// LogsEvent_LogDetail

// string text = 1;
inline void LogsEvent_LogDetail::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& LogsEvent_LogDetail::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LogsEvent.LogDetail.text)
  return _internal_text();
}
inline void LogsEvent_LogDetail::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LogsEvent.LogDetail.text)
}
inline std::string* LogsEvent_LogDetail::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LogsEvent.LogDetail.text)
  return _internal_mutable_text();
}
inline const std::string& LogsEvent_LogDetail::_internal_text() const {
  return text_.Get();
}
inline void LogsEvent_LogDetail::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LogsEvent_LogDetail::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LogsEvent.LogDetail.text)
}
inline void LogsEvent_LogDetail::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LogsEvent.LogDetail.text)
}
inline void LogsEvent_LogDetail::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LogsEvent.LogDetail.text)
}
inline std::string* LogsEvent_LogDetail::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LogsEvent_LogDetail::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LogsEvent.LogDetail.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogsEvent_LogDetail::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LogsEvent.LogDetail.text)
}

// .google.protobuf.Value detail = 2;
inline bool LogsEvent_LogDetail::_internal_has_detail() const {
  return this != internal_default_instance() && detail_ != nullptr;
}
inline bool LogsEvent_LogDetail::has_detail() const {
  return _internal_has_detail();
}
inline const PROTOBUF_NAMESPACE_ID::Value& LogsEvent_LogDetail::_internal_detail() const {
  const PROTOBUF_NAMESPACE_ID::Value* p = detail_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Value&>(
      PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Value& LogsEvent_LogDetail::detail() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LogsEvent.LogDetail.detail)
  return _internal_detail();
}
inline void LogsEvent_LogDetail::unsafe_arena_set_allocated_detail(
    PROTOBUF_NAMESPACE_ID::Value* detail) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detail_);
  }
  detail_ = detail;
  if (detail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.LogsEvent.LogDetail.detail)
}
inline PROTOBUF_NAMESPACE_ID::Value* LogsEvent_LogDetail::release_detail() {
  
  PROTOBUF_NAMESPACE_ID::Value* temp = detail_;
  detail_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Value* LogsEvent_LogDetail::unsafe_arena_release_detail() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LogsEvent.LogDetail.detail)
  
  PROTOBUF_NAMESPACE_ID::Value* temp = detail_;
  detail_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Value* LogsEvent_LogDetail::_internal_mutable_detail() {
  
  if (detail_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Value>(GetArena());
    detail_ = p;
  }
  return detail_;
}
inline PROTOBUF_NAMESPACE_ID::Value* LogsEvent_LogDetail::mutable_detail() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LogsEvent.LogDetail.detail)
  return _internal_mutable_detail();
}
inline void LogsEvent_LogDetail::set_allocated_detail(PROTOBUF_NAMESPACE_ID::Value* detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(detail_);
  }
  if (detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detail)->GetArena();
    if (message_arena != submessage_arena) {
      detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LogsEvent.LogDetail.detail)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogsEvent

// string text = 1;
inline void LogsEvent::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& LogsEvent::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LogsEvent.text)
  return _internal_text();
}
inline void LogsEvent::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LogsEvent.text)
}
inline std::string* LogsEvent::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LogsEvent.text)
  return _internal_mutable_text();
}
inline const std::string& LogsEvent::_internal_text() const {
  return text_.Get();
}
inline void LogsEvent::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LogsEvent::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LogsEvent.text)
}
inline void LogsEvent::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LogsEvent.text)
}
inline void LogsEvent::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LogsEvent.text)
}
inline std::string* LogsEvent::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LogsEvent::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LogsEvent.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogsEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LogsEvent.text)
}

// .ai.inworld.packets.LogsEvent.LogLevel level = 2;
inline void LogsEvent::clear_level() {
  level_ = 0;
}
inline ::ai::inworld::packets::LogsEvent_LogLevel LogsEvent::_internal_level() const {
  return static_cast< ::ai::inworld::packets::LogsEvent_LogLevel >(level_);
}
inline ::ai::inworld::packets::LogsEvent_LogLevel LogsEvent::level() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LogsEvent.level)
  return _internal_level();
}
inline void LogsEvent::_internal_set_level(::ai::inworld::packets::LogsEvent_LogLevel value) {
  
  level_ = value;
}
inline void LogsEvent::set_level(::ai::inworld::packets::LogsEvent_LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LogsEvent.level)
}

// map<string, string> metadata = 3 [deprecated = true];
inline int LogsEvent::_internal_metadata_size() const {
  return metadata_.size();
}
inline int LogsEvent::metadata_size() const {
  return _internal_metadata_size();
}
inline void LogsEvent::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogsEvent::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LogsEvent::metadata() const {
  // @@protoc_insertion_point(field_map:ai.inworld.packets.LogsEvent.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogsEvent::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LogsEvent::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:ai.inworld.packets.LogsEvent.metadata)
  return _internal_mutable_metadata();
}

// repeated .ai.inworld.packets.LogsEvent.LogDetail details = 4;
inline int LogsEvent::_internal_details_size() const {
  return details_.size();
}
inline int LogsEvent::details_size() const {
  return _internal_details_size();
}
inline void LogsEvent::clear_details() {
  details_.Clear();
}
inline ::ai::inworld::packets::LogsEvent_LogDetail* LogsEvent::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LogsEvent.details)
  return details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LogsEvent_LogDetail >*
LogsEvent::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LogsEvent.details)
  return &details_;
}
inline const ::ai::inworld::packets::LogsEvent_LogDetail& LogsEvent::_internal_details(int index) const {
  return details_.Get(index);
}
inline const ::ai::inworld::packets::LogsEvent_LogDetail& LogsEvent::details(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LogsEvent.details)
  return _internal_details(index);
}
inline ::ai::inworld::packets::LogsEvent_LogDetail* LogsEvent::_internal_add_details() {
  return details_.Add();
}
inline ::ai::inworld::packets::LogsEvent_LogDetail* LogsEvent::add_details() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LogsEvent.details)
  return _internal_add_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LogsEvent_LogDetail >&
LogsEvent::details() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LogsEvent.details)
  return details_;
}

// -------------------------------------------------------------------

// MutationEvent

// .ai.inworld.packets.CancelResponses cancel_responses = 1;
inline bool MutationEvent::_internal_has_cancel_responses() const {
  return mutation_case() == kCancelResponses;
}
inline bool MutationEvent::has_cancel_responses() const {
  return _internal_has_cancel_responses();
}
inline void MutationEvent::set_has_cancel_responses() {
  _oneof_case_[0] = kCancelResponses;
}
inline void MutationEvent::clear_cancel_responses() {
  if (_internal_has_cancel_responses()) {
    if (GetArena() == nullptr) {
      delete mutation_.cancel_responses_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::release_cancel_responses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
      ::ai::inworld::packets::CancelResponses* temp = mutation_.cancel_responses_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::_internal_cancel_responses() const {
  return _internal_has_cancel_responses()
      ? *mutation_.cancel_responses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponses&>(::ai::inworld::packets::_CancelResponses_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::cancel_responses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_cancel_responses();
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::unsafe_arena_release_cancel_responses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
    ::ai::inworld::packets::CancelResponses* temp = mutation_.cancel_responses_;
    mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses) {
  clear_mutation();
  if (cancel_responses) {
    set_has_cancel_responses();
    mutation_.cancel_responses_ = cancel_responses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.cancel_responses)
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::_internal_mutable_cancel_responses() {
  if (!_internal_has_cancel_responses()) {
    clear_mutation();
    set_has_cancel_responses();
    mutation_.cancel_responses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponses >(GetArena());
  }
  return mutation_.cancel_responses_;
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::mutable_cancel_responses() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_mutable_cancel_responses();
}

// .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
inline bool MutationEvent::_internal_has_regenerate_response() const {
  return mutation_case() == kRegenerateResponse;
}
inline bool MutationEvent::has_regenerate_response() const {
  return _internal_has_regenerate_response();
}
inline void MutationEvent::set_has_regenerate_response() {
  _oneof_case_[0] = kRegenerateResponse;
}
inline void MutationEvent::clear_regenerate_response() {
  if (_internal_has_regenerate_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.regenerate_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::release_regenerate_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::RegenerateResponse* temp = mutation_.regenerate_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::_internal_regenerate_response() const {
  return _internal_has_regenerate_response()
      ? *mutation_.regenerate_response_
      : reinterpret_cast< ::ai::inworld::packets::RegenerateResponse&>(::ai::inworld::packets::_RegenerateResponse_default_instance_);
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::regenerate_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_regenerate_response();
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::unsafe_arena_release_regenerate_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::RegenerateResponse* temp = mutation_.regenerate_response_;
    mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response) {
  clear_mutation();
  if (regenerate_response) {
    set_has_regenerate_response();
    mutation_.regenerate_response_ = regenerate_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.regenerate_response)
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::_internal_mutable_regenerate_response() {
  if (!_internal_has_regenerate_response()) {
    clear_mutation();
    set_has_regenerate_response();
    mutation_.regenerate_response_ = CreateMaybeMessage< ::ai::inworld::packets::RegenerateResponse >(GetArena());
  }
  return mutation_.regenerate_response_;
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::mutable_regenerate_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_mutable_regenerate_response();
}

// .ai.inworld.packets.ApplyResponse apply_response = 3;
inline bool MutationEvent::_internal_has_apply_response() const {
  return mutation_case() == kApplyResponse;
}
inline bool MutationEvent::has_apply_response() const {
  return _internal_has_apply_response();
}
inline void MutationEvent::set_has_apply_response() {
  _oneof_case_[0] = kApplyResponse;
}
inline void MutationEvent::clear_apply_response() {
  if (_internal_has_apply_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.apply_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::release_apply_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::ApplyResponse* temp = mutation_.apply_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::_internal_apply_response() const {
  return _internal_has_apply_response()
      ? *mutation_.apply_response_
      : reinterpret_cast< ::ai::inworld::packets::ApplyResponse&>(::ai::inworld::packets::_ApplyResponse_default_instance_);
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::apply_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_apply_response();
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::unsafe_arena_release_apply_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ApplyResponse* temp = mutation_.apply_response_;
    mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response) {
  clear_mutation();
  if (apply_response) {
    set_has_apply_response();
    mutation_.apply_response_ = apply_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.apply_response)
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::_internal_mutable_apply_response() {
  if (!_internal_has_apply_response()) {
    clear_mutation();
    set_has_apply_response();
    mutation_.apply_response_ = CreateMaybeMessage< ::ai::inworld::packets::ApplyResponse >(GetArena());
  }
  return mutation_.apply_response_;
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::mutable_apply_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_mutable_apply_response();
}

// .ai.inworld.packets.LoadScene load_scene = 4;
inline bool MutationEvent::_internal_has_load_scene() const {
  return mutation_case() == kLoadScene;
}
inline bool MutationEvent::has_load_scene() const {
  return _internal_has_load_scene();
}
inline void MutationEvent::set_has_load_scene() {
  _oneof_case_[0] = kLoadScene;
}
inline void MutationEvent::clear_load_scene() {
  if (_internal_has_load_scene()) {
    if (GetArena() == nullptr) {
      delete mutation_.load_scene_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::release_load_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
      ::ai::inworld::packets::LoadScene* temp = mutation_.load_scene_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::_internal_load_scene() const {
  return _internal_has_load_scene()
      ? *mutation_.load_scene_
      : reinterpret_cast< ::ai::inworld::packets::LoadScene&>(::ai::inworld::packets::_LoadScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::load_scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_load_scene();
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::unsafe_arena_release_load_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
    ::ai::inworld::packets::LoadScene* temp = mutation_.load_scene_;
    mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene) {
  clear_mutation();
  if (load_scene) {
    set_has_load_scene();
    mutation_.load_scene_ = load_scene;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_scene)
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::_internal_mutable_load_scene() {
  if (!_internal_has_load_scene()) {
    clear_mutation();
    set_has_load_scene();
    mutation_.load_scene_ = CreateMaybeMessage< ::ai::inworld::packets::LoadScene >(GetArena());
  }
  return mutation_.load_scene_;
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::mutable_load_scene() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_mutable_load_scene();
}

// .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
inline bool MutationEvent::_internal_has_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse;
}
inline bool MutationEvent::has_modify_exact_response() const {
  return _internal_has_modify_exact_response();
}
inline void MutationEvent::set_has_modify_exact_response() {
  _oneof_case_[0] = kModifyExactResponse;
}
inline void MutationEvent::clear_modify_exact_response() {
  if (_internal_has_modify_exact_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.modify_exact_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::release_modify_exact_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::ModifyExactResponse* temp = mutation_.modify_exact_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::_internal_modify_exact_response() const {
  return _internal_has_modify_exact_response()
      ? *mutation_.modify_exact_response_
      : reinterpret_cast< ::ai::inworld::packets::ModifyExactResponse&>(::ai::inworld::packets::_ModifyExactResponse_default_instance_);
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::modify_exact_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_modify_exact_response();
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::unsafe_arena_release_modify_exact_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ModifyExactResponse* temp = mutation_.modify_exact_response_;
    mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response) {
  clear_mutation();
  if (modify_exact_response) {
    set_has_modify_exact_response();
    mutation_.modify_exact_response_ = modify_exact_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.modify_exact_response)
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::_internal_mutable_modify_exact_response() {
  if (!_internal_has_modify_exact_response()) {
    clear_mutation();
    set_has_modify_exact_response();
    mutation_.modify_exact_response_ = CreateMaybeMessage< ::ai::inworld::packets::ModifyExactResponse >(GetArena());
  }
  return mutation_.modify_exact_response_;
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::mutable_modify_exact_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_mutable_modify_exact_response();
}

// .ai.inworld.packets.LoadCharacters load_characters = 6;
inline bool MutationEvent::_internal_has_load_characters() const {
  return mutation_case() == kLoadCharacters;
}
inline bool MutationEvent::has_load_characters() const {
  return _internal_has_load_characters();
}
inline void MutationEvent::set_has_load_characters() {
  _oneof_case_[0] = kLoadCharacters;
}
inline void MutationEvent::clear_load_characters() {
  if (_internal_has_load_characters()) {
    if (GetArena() == nullptr) {
      delete mutation_.load_characters_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::release_load_characters() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_characters)
  if (_internal_has_load_characters()) {
    clear_has_mutation();
      ::ai::inworld::packets::LoadCharacters* temp = mutation_.load_characters_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.load_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadCharacters& MutationEvent::_internal_load_characters() const {
  return _internal_has_load_characters()
      ? *mutation_.load_characters_
      : reinterpret_cast< ::ai::inworld::packets::LoadCharacters&>(::ai::inworld::packets::_LoadCharacters_default_instance_);
}
inline const ::ai::inworld::packets::LoadCharacters& MutationEvent::load_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_characters)
  return _internal_load_characters();
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::unsafe_arena_release_load_characters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_characters)
  if (_internal_has_load_characters()) {
    clear_has_mutation();
    ::ai::inworld::packets::LoadCharacters* temp = mutation_.load_characters_;
    mutation_.load_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_characters(::ai::inworld::packets::LoadCharacters* load_characters) {
  clear_mutation();
  if (load_characters) {
    set_has_load_characters();
    mutation_.load_characters_ = load_characters;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_characters)
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::_internal_mutable_load_characters() {
  if (!_internal_has_load_characters()) {
    clear_mutation();
    set_has_load_characters();
    mutation_.load_characters_ = CreateMaybeMessage< ::ai::inworld::packets::LoadCharacters >(GetArena());
  }
  return mutation_.load_characters_;
}
inline ::ai::inworld::packets::LoadCharacters* MutationEvent::mutable_load_characters() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_characters)
  return _internal_mutable_load_characters();
}

// .ai.inworld.packets.UnloadCharacters unload_characters = 7;
inline bool MutationEvent::_internal_has_unload_characters() const {
  return mutation_case() == kUnloadCharacters;
}
inline bool MutationEvent::has_unload_characters() const {
  return _internal_has_unload_characters();
}
inline void MutationEvent::set_has_unload_characters() {
  _oneof_case_[0] = kUnloadCharacters;
}
inline void MutationEvent::clear_unload_characters() {
  if (_internal_has_unload_characters()) {
    if (GetArena() == nullptr) {
      delete mutation_.unload_characters_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::UnloadCharacters* MutationEvent::release_unload_characters() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.unload_characters)
  if (_internal_has_unload_characters()) {
    clear_has_mutation();
      ::ai::inworld::packets::UnloadCharacters* temp = mutation_.unload_characters_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.unload_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::UnloadCharacters& MutationEvent::_internal_unload_characters() const {
  return _internal_has_unload_characters()
      ? *mutation_.unload_characters_
      : reinterpret_cast< ::ai::inworld::packets::UnloadCharacters&>(::ai::inworld::packets::_UnloadCharacters_default_instance_);
}
inline const ::ai::inworld::packets::UnloadCharacters& MutationEvent::unload_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.unload_characters)
  return _internal_unload_characters();
}
inline ::ai::inworld::packets::UnloadCharacters* MutationEvent::unsafe_arena_release_unload_characters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.unload_characters)
  if (_internal_has_unload_characters()) {
    clear_has_mutation();
    ::ai::inworld::packets::UnloadCharacters* temp = mutation_.unload_characters_;
    mutation_.unload_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_unload_characters(::ai::inworld::packets::UnloadCharacters* unload_characters) {
  clear_mutation();
  if (unload_characters) {
    set_has_unload_characters();
    mutation_.unload_characters_ = unload_characters;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.unload_characters)
}
inline ::ai::inworld::packets::UnloadCharacters* MutationEvent::_internal_mutable_unload_characters() {
  if (!_internal_has_unload_characters()) {
    clear_mutation();
    set_has_unload_characters();
    mutation_.unload_characters_ = CreateMaybeMessage< ::ai::inworld::packets::UnloadCharacters >(GetArena());
  }
  return mutation_.unload_characters_;
}
inline ::ai::inworld::packets::UnloadCharacters* MutationEvent::mutable_unload_characters() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.unload_characters)
  return _internal_mutable_unload_characters();
}

inline bool MutationEvent::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void MutationEvent::clear_has_mutation() {
  _oneof_case_[0] = MUTATION_NOT_SET;
}
inline MutationEvent::MutationCase MutationEvent::mutation_case() const {
  return MutationEvent::MutationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionControlResponseEvent

// .ai.inworld.packets.LoadedScene loaded_scene = 1 [deprecated = true];
inline bool SessionControlResponseEvent::_internal_has_loaded_scene() const {
  return response_case() == kLoadedScene;
}
inline bool SessionControlResponseEvent::has_loaded_scene() const {
  return _internal_has_loaded_scene();
}
inline void SessionControlResponseEvent::set_has_loaded_scene() {
  _oneof_case_[0] = kLoadedScene;
}
inline void SessionControlResponseEvent::clear_loaded_scene() {
  if (_internal_has_loaded_scene()) {
    if (GetArena() == nullptr) {
      delete response_.loaded_scene_;
    }
    clear_has_response();
  }
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::release_loaded_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  if (_internal_has_loaded_scene()) {
    clear_has_response();
      ::ai::inworld::packets::LoadedScene* temp = response_.loaded_scene_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.loaded_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadedScene& SessionControlResponseEvent::_internal_loaded_scene() const {
  return _internal_has_loaded_scene()
      ? *response_.loaded_scene_
      : reinterpret_cast< ::ai::inworld::packets::LoadedScene&>(::ai::inworld::packets::_LoadedScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadedScene& SessionControlResponseEvent::loaded_scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  return _internal_loaded_scene();
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::unsafe_arena_release_loaded_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  if (_internal_has_loaded_scene()) {
    clear_has_response();
    ::ai::inworld::packets::LoadedScene* temp = response_.loaded_scene_;
    response_.loaded_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlResponseEvent::unsafe_arena_set_allocated_loaded_scene(::ai::inworld::packets::LoadedScene* loaded_scene) {
  clear_response();
  if (loaded_scene) {
    set_has_loaded_scene();
    response_.loaded_scene_ = loaded_scene;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::_internal_mutable_loaded_scene() {
  if (!_internal_has_loaded_scene()) {
    clear_response();
    set_has_loaded_scene();
    response_.loaded_scene_ = CreateMaybeMessage< ::ai::inworld::packets::LoadedScene >(GetArena());
  }
  return response_.loaded_scene_;
}
inline ::ai::inworld::packets::LoadedScene* SessionControlResponseEvent::mutable_loaded_scene() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlResponseEvent.loaded_scene)
  return _internal_mutable_loaded_scene();
}

// .ai.inworld.packets.LoadedCharacters loaded_characters = 2 [deprecated = true];
inline bool SessionControlResponseEvent::_internal_has_loaded_characters() const {
  return response_case() == kLoadedCharacters;
}
inline bool SessionControlResponseEvent::has_loaded_characters() const {
  return _internal_has_loaded_characters();
}
inline void SessionControlResponseEvent::set_has_loaded_characters() {
  _oneof_case_[0] = kLoadedCharacters;
}
inline void SessionControlResponseEvent::clear_loaded_characters() {
  if (_internal_has_loaded_characters()) {
    if (GetArena() == nullptr) {
      delete response_.loaded_characters_;
    }
    clear_has_response();
  }
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::release_loaded_characters() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  if (_internal_has_loaded_characters()) {
    clear_has_response();
      ::ai::inworld::packets::LoadedCharacters* temp = response_.loaded_characters_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.loaded_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadedCharacters& SessionControlResponseEvent::_internal_loaded_characters() const {
  return _internal_has_loaded_characters()
      ? *response_.loaded_characters_
      : reinterpret_cast< ::ai::inworld::packets::LoadedCharacters&>(::ai::inworld::packets::_LoadedCharacters_default_instance_);
}
inline const ::ai::inworld::packets::LoadedCharacters& SessionControlResponseEvent::loaded_characters() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  return _internal_loaded_characters();
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::unsafe_arena_release_loaded_characters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  if (_internal_has_loaded_characters()) {
    clear_has_response();
    ::ai::inworld::packets::LoadedCharacters* temp = response_.loaded_characters_;
    response_.loaded_characters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlResponseEvent::unsafe_arena_set_allocated_loaded_characters(::ai::inworld::packets::LoadedCharacters* loaded_characters) {
  clear_response();
  if (loaded_characters) {
    set_has_loaded_characters();
    response_.loaded_characters_ = loaded_characters;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::_internal_mutable_loaded_characters() {
  if (!_internal_has_loaded_characters()) {
    clear_response();
    set_has_loaded_characters();
    response_.loaded_characters_ = CreateMaybeMessage< ::ai::inworld::packets::LoadedCharacters >(GetArena());
  }
  return response_.loaded_characters_;
}
inline ::ai::inworld::packets::LoadedCharacters* SessionControlResponseEvent::mutable_loaded_characters() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlResponseEvent.loaded_characters)
  return _internal_mutable_loaded_characters();
}

// .ai.inworld.packets.SessionHistoryResponse session_history = 3;
inline bool SessionControlResponseEvent::_internal_has_session_history() const {
  return response_case() == kSessionHistory;
}
inline bool SessionControlResponseEvent::has_session_history() const {
  return _internal_has_session_history();
}
inline void SessionControlResponseEvent::set_has_session_history() {
  _oneof_case_[0] = kSessionHistory;
}
inline void SessionControlResponseEvent::clear_session_history() {
  if (_internal_has_session_history()) {
    if (GetArena() == nullptr) {
      delete response_.session_history_;
    }
    clear_has_response();
  }
}
inline ::ai::inworld::packets::SessionHistoryResponse* SessionControlResponseEvent::release_session_history() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlResponseEvent.session_history)
  if (_internal_has_session_history()) {
    clear_has_response();
      ::ai::inworld::packets::SessionHistoryResponse* temp = response_.session_history_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.session_history_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionHistoryResponse& SessionControlResponseEvent::_internal_session_history() const {
  return _internal_has_session_history()
      ? *response_.session_history_
      : reinterpret_cast< ::ai::inworld::packets::SessionHistoryResponse&>(::ai::inworld::packets::_SessionHistoryResponse_default_instance_);
}
inline const ::ai::inworld::packets::SessionHistoryResponse& SessionControlResponseEvent::session_history() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlResponseEvent.session_history)
  return _internal_session_history();
}
inline ::ai::inworld::packets::SessionHistoryResponse* SessionControlResponseEvent::unsafe_arena_release_session_history() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlResponseEvent.session_history)
  if (_internal_has_session_history()) {
    clear_has_response();
    ::ai::inworld::packets::SessionHistoryResponse* temp = response_.session_history_;
    response_.session_history_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlResponseEvent::unsafe_arena_set_allocated_session_history(::ai::inworld::packets::SessionHistoryResponse* session_history) {
  clear_response();
  if (session_history) {
    set_has_session_history();
    response_.session_history_ = session_history;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlResponseEvent.session_history)
}
inline ::ai::inworld::packets::SessionHistoryResponse* SessionControlResponseEvent::_internal_mutable_session_history() {
  if (!_internal_has_session_history()) {
    clear_response();
    set_has_session_history();
    response_.session_history_ = CreateMaybeMessage< ::ai::inworld::packets::SessionHistoryResponse >(GetArena());
  }
  return response_.session_history_;
}
inline ::ai::inworld::packets::SessionHistoryResponse* SessionControlResponseEvent::mutable_session_history() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlResponseEvent.session_history)
  return _internal_mutable_session_history();
}

inline bool SessionControlResponseEvent::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void SessionControlResponseEvent::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline SessionControlResponseEvent::ResponseCase SessionControlResponseEvent::response_case() const {
  return SessionControlResponseEvent::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CancelResponses

// string interaction_id = 1;
inline void CancelResponses::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponses::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_interaction_id();
}
inline void CancelResponses::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& CancelResponses::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void CancelResponses::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CancelResponses::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CancelResponses.interaction_id)
}
inline void CancelResponses::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.interaction_id)
}
inline void CancelResponses::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CancelResponses::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponses.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelResponses::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponses.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponses::_internal_utterance_id_size() const {
  return utterance_id_.size();
}
inline int CancelResponses::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponses::clear_utterance_id() {
  utterance_id_.Clear();
}
inline std::string* CancelResponses::add_utterance_id() {
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_add_utterance_id();
}
inline const std::string& CancelResponses::_internal_utterance_id(int index) const {
  return utterance_id_.Get(index);
}
inline const std::string& CancelResponses::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponses::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return utterance_id_.Mutable(index);
}
inline void CancelResponses::set_utterance_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
  utterance_id_.Mutable(index)->assign(value);
}
inline void CancelResponses::set_utterance_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
  utterance_id_.Mutable(index)->assign(std::move(value));
}
inline void CancelResponses::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value, size_t size) {
  utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline std::string* CancelResponses::_internal_add_utterance_id() {
  return utterance_id_.Add();
}
inline void CancelResponses::add_utterance_id(const std::string& value) {
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(std::string&& value) {
  utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value, size_t size) {
  utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponses::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponses.utterance_id)
  return utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponses::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponses.utterance_id)
  return &utterance_id_;
}

// -------------------------------------------------------------------

// RegenerateResponse

// string interaction_id = 1;
inline void RegenerateResponse::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& RegenerateResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_interaction_id();
}
inline void RegenerateResponse::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& RegenerateResponse::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void RegenerateResponse::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RegenerateResponse::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline void RegenerateResponse::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline void RegenerateResponse::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RegenerateResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RegenerateResponse.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegenerateResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RegenerateResponse.interaction_id)
}

// -------------------------------------------------------------------

// ApplyResponse

// .ai.inworld.packets.PacketId packet_id = 1;
inline bool ApplyResponse::_internal_has_packet_id() const {
  return this != internal_default_instance() && packet_id_ != nullptr;
}
inline bool ApplyResponse::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void ApplyResponse::clear_packet_id() {
  if (GetArena() == nullptr && packet_id_ != nullptr) {
    delete packet_id_;
  }
  packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_packet_id();
}
inline void ApplyResponse::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_id_);
  }
  packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ApplyResponse.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::_internal_mutable_packet_id() {
  
  if (packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    packet_id_ = p;
  }
  return packet_id_;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_mutable_packet_id();
}
inline void ApplyResponse::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}

// .ai.inworld.packets.ApplyResponse.ApplyResponseType apply_response_type = 2;
inline void ApplyResponse::clear_apply_response_type() {
  apply_response_type_ = 0;
}
inline ::ai::inworld::packets::ApplyResponse_ApplyResponseType ApplyResponse::_internal_apply_response_type() const {
  return static_cast< ::ai::inworld::packets::ApplyResponse_ApplyResponseType >(apply_response_type_);
}
inline ::ai::inworld::packets::ApplyResponse_ApplyResponseType ApplyResponse::apply_response_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ApplyResponse.apply_response_type)
  return _internal_apply_response_type();
}
inline void ApplyResponse::_internal_set_apply_response_type(::ai::inworld::packets::ApplyResponse_ApplyResponseType value) {
  
  apply_response_type_ = value;
}
inline void ApplyResponse::set_apply_response_type(::ai::inworld::packets::ApplyResponse_ApplyResponseType value) {
  _internal_set_apply_response_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ApplyResponse.apply_response_type)
}

// -------------------------------------------------------------------

// LoadScene

// string name = 1;
inline void LoadScene::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LoadScene::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadScene.name)
  return _internal_name();
}
inline void LoadScene::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadScene.name)
  return _internal_mutable_name();
}
inline const std::string& LoadScene::_internal_name() const {
  return name_.Get();
}
inline void LoadScene::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadScene::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadScene.name)
}
inline void LoadScene::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadScene.name)
}
inline void LoadScene::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadScene::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadScene.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadScene::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadScene.name)
}

// bool is_reset_scene = 2;
inline void LoadScene::clear_is_reset_scene() {
  is_reset_scene_ = false;
}
inline bool LoadScene::_internal_is_reset_scene() const {
  return is_reset_scene_;
}
inline bool LoadScene::is_reset_scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadScene.is_reset_scene)
  return _internal_is_reset_scene();
}
inline void LoadScene::_internal_set_is_reset_scene(bool value) {
  
  is_reset_scene_ = value;
}
inline void LoadScene::set_is_reset_scene(bool value) {
  _internal_set_is_reset_scene(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadScene.is_reset_scene)
}

// -------------------------------------------------------------------

// LoadedScene

// repeated .ai.inworld.packets.Agent agents = 1;
inline int LoadedScene::_internal_agents_size() const {
  return agents_.size();
}
inline int LoadedScene::agents_size() const {
  return _internal_agents_size();
}
inline void LoadedScene::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::Agent* LoadedScene::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedScene.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
LoadedScene::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadedScene.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::Agent& LoadedScene::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::Agent& LoadedScene::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedScene.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::Agent* LoadedScene::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::Agent* LoadedScene::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadedScene.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
LoadedScene::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadedScene.agents)
  return agents_;
}

// string scene_name = 2;
inline void LoadedScene::clear_scene_name() {
  scene_name_.ClearToEmpty();
}
inline const std::string& LoadedScene::scene_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedScene.scene_name)
  return _internal_scene_name();
}
inline void LoadedScene::set_scene_name(const std::string& value) {
  _internal_set_scene_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedScene.scene_name)
}
inline std::string* LoadedScene::mutable_scene_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedScene.scene_name)
  return _internal_mutable_scene_name();
}
inline const std::string& LoadedScene::_internal_scene_name() const {
  return scene_name_.Get();
}
inline void LoadedScene::_internal_set_scene_name(const std::string& value) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedScene::set_scene_name(std::string&& value) {
  
  scene_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedScene.scene_name)
}
inline void LoadedScene::set_scene_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedScene.scene_name)
}
inline void LoadedScene::set_scene_name(const char* value,
    size_t size) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedScene.scene_name)
}
inline std::string* LoadedScene::_internal_mutable_scene_name() {
  
  return scene_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedScene::release_scene_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedScene.scene_name)
  return scene_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedScene::set_allocated_scene_name(std::string* scene_name) {
  if (scene_name != nullptr) {
    
  } else {
    
  }
  scene_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedScene.scene_name)
}

// string scene_description = 3;
inline void LoadedScene::clear_scene_description() {
  scene_description_.ClearToEmpty();
}
inline const std::string& LoadedScene::scene_description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedScene.scene_description)
  return _internal_scene_description();
}
inline void LoadedScene::set_scene_description(const std::string& value) {
  _internal_set_scene_description(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedScene.scene_description)
}
inline std::string* LoadedScene::mutable_scene_description() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedScene.scene_description)
  return _internal_mutable_scene_description();
}
inline const std::string& LoadedScene::_internal_scene_description() const {
  return scene_description_.Get();
}
inline void LoadedScene::_internal_set_scene_description(const std::string& value) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedScene::set_scene_description(std::string&& value) {
  
  scene_description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedScene.scene_description)
}
inline void LoadedScene::set_scene_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedScene.scene_description)
}
inline void LoadedScene::set_scene_description(const char* value,
    size_t size) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedScene.scene_description)
}
inline std::string* LoadedScene::_internal_mutable_scene_description() {
  
  return scene_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedScene::release_scene_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedScene.scene_description)
  return scene_description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedScene::set_allocated_scene_description(std::string* scene_description) {
  if (scene_description != nullptr) {
    
  } else {
    
  }
  scene_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedScene.scene_description)
}

// string scene_display_name = 4;
inline void LoadedScene::clear_scene_display_name() {
  scene_display_name_.ClearToEmpty();
}
inline const std::string& LoadedScene::scene_display_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedScene.scene_display_name)
  return _internal_scene_display_name();
}
inline void LoadedScene::set_scene_display_name(const std::string& value) {
  _internal_set_scene_display_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedScene.scene_display_name)
}
inline std::string* LoadedScene::mutable_scene_display_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedScene.scene_display_name)
  return _internal_mutable_scene_display_name();
}
inline const std::string& LoadedScene::_internal_scene_display_name() const {
  return scene_display_name_.Get();
}
inline void LoadedScene::_internal_set_scene_display_name(const std::string& value) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedScene::set_scene_display_name(std::string&& value) {
  
  scene_display_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedScene.scene_display_name)
}
inline void LoadedScene::set_scene_display_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedScene.scene_display_name)
}
inline void LoadedScene::set_scene_display_name(const char* value,
    size_t size) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedScene.scene_display_name)
}
inline std::string* LoadedScene::_internal_mutable_scene_display_name() {
  
  return scene_display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedScene::release_scene_display_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedScene.scene_display_name)
  return scene_display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedScene::set_allocated_scene_display_name(std::string* scene_display_name) {
  if (scene_display_name != nullptr) {
    
  } else {
    
  }
  scene_display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_display_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedScene.scene_display_name)
}

// -------------------------------------------------------------------

// LoadCharacters_CharacterName

// string name = 1;
inline void LoadCharacters_CharacterName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LoadCharacters_CharacterName::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return _internal_name();
}
inline void LoadCharacters_CharacterName::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadCharacters.CharacterName.name)
}
inline std::string* LoadCharacters_CharacterName::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return _internal_mutable_name();
}
inline const std::string& LoadCharacters_CharacterName::_internal_name() const {
  return name_.Get();
}
inline void LoadCharacters_CharacterName::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadCharacters_CharacterName::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadCharacters.CharacterName.name)
}
inline void LoadCharacters_CharacterName::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadCharacters.CharacterName.name)
}
inline void LoadCharacters_CharacterName::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadCharacters.CharacterName.name)
}
inline std::string* LoadCharacters_CharacterName::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadCharacters_CharacterName::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadCharacters.CharacterName.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadCharacters_CharacterName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadCharacters.CharacterName.name)
}

// .ai.inworld.language_codes.LanguageCode language_code = 2;
inline void LoadCharacters_CharacterName::clear_language_code() {
  language_code_ = 0;
}
inline ::ai::inworld::language_codes::LanguageCode LoadCharacters_CharacterName::_internal_language_code() const {
  return static_cast< ::ai::inworld::language_codes::LanguageCode >(language_code_);
}
inline ::ai::inworld::language_codes::LanguageCode LoadCharacters_CharacterName::language_code() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.CharacterName.language_code)
  return _internal_language_code();
}
inline void LoadCharacters_CharacterName::_internal_set_language_code(::ai::inworld::language_codes::LanguageCode value) {
  
  language_code_ = value;
}
inline void LoadCharacters_CharacterName::set_language_code(::ai::inworld::language_codes::LanguageCode value) {
  _internal_set_language_code(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadCharacters.CharacterName.language_code)
}

// -------------------------------------------------------------------

// LoadCharacters

// repeated .ai.inworld.packets.LoadCharacters.CharacterName name = 1;
inline int LoadCharacters::_internal_name_size() const {
  return name_.size();
}
inline int LoadCharacters::name_size() const {
  return _internal_name_size();
}
inline void LoadCharacters::clear_name() {
  name_.Clear();
}
inline ::ai::inworld::packets::LoadCharacters_CharacterName* LoadCharacters::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadCharacters.name)
  return name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >*
LoadCharacters::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadCharacters.name)
  return &name_;
}
inline const ::ai::inworld::packets::LoadCharacters_CharacterName& LoadCharacters::_internal_name(int index) const {
  return name_.Get(index);
}
inline const ::ai::inworld::packets::LoadCharacters_CharacterName& LoadCharacters::name(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadCharacters.name)
  return _internal_name(index);
}
inline ::ai::inworld::packets::LoadCharacters_CharacterName* LoadCharacters::_internal_add_name() {
  return name_.Add();
}
inline ::ai::inworld::packets::LoadCharacters_CharacterName* LoadCharacters::add_name() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadCharacters.name)
  return _internal_add_name();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadCharacters_CharacterName >&
LoadCharacters::name() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadCharacters.name)
  return name_;
}

// -------------------------------------------------------------------

// LoadedCharacters

// repeated .ai.inworld.packets.Agent agents = 1;
inline int LoadedCharacters::_internal_agents_size() const {
  return agents_.size();
}
inline int LoadedCharacters::agents_size() const {
  return _internal_agents_size();
}
inline void LoadedCharacters::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::Agent* LoadedCharacters::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedCharacters.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
LoadedCharacters::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadedCharacters.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::Agent& LoadedCharacters::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::Agent& LoadedCharacters::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedCharacters.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::Agent* LoadedCharacters::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::Agent* LoadedCharacters::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadedCharacters.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
LoadedCharacters::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadedCharacters.agents)
  return agents_;
}

// string scene_name = 2;
inline void LoadedCharacters::clear_scene_name() {
  scene_name_.ClearToEmpty();
}
inline const std::string& LoadedCharacters::scene_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedCharacters.scene_name)
  return _internal_scene_name();
}
inline void LoadedCharacters::set_scene_name(const std::string& value) {
  _internal_set_scene_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedCharacters.scene_name)
}
inline std::string* LoadedCharacters::mutable_scene_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedCharacters.scene_name)
  return _internal_mutable_scene_name();
}
inline const std::string& LoadedCharacters::_internal_scene_name() const {
  return scene_name_.Get();
}
inline void LoadedCharacters::_internal_set_scene_name(const std::string& value) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedCharacters::set_scene_name(std::string&& value) {
  
  scene_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedCharacters.scene_name)
}
inline void LoadedCharacters::set_scene_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedCharacters.scene_name)
}
inline void LoadedCharacters::set_scene_name(const char* value,
    size_t size) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedCharacters.scene_name)
}
inline std::string* LoadedCharacters::_internal_mutable_scene_name() {
  
  return scene_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedCharacters::release_scene_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedCharacters.scene_name)
  return scene_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedCharacters::set_allocated_scene_name(std::string* scene_name) {
  if (scene_name != nullptr) {
    
  } else {
    
  }
  scene_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedCharacters.scene_name)
}

// string scene_description = 3;
inline void LoadedCharacters::clear_scene_description() {
  scene_description_.ClearToEmpty();
}
inline const std::string& LoadedCharacters::scene_description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedCharacters.scene_description)
  return _internal_scene_description();
}
inline void LoadedCharacters::set_scene_description(const std::string& value) {
  _internal_set_scene_description(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedCharacters.scene_description)
}
inline std::string* LoadedCharacters::mutable_scene_description() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedCharacters.scene_description)
  return _internal_mutable_scene_description();
}
inline const std::string& LoadedCharacters::_internal_scene_description() const {
  return scene_description_.Get();
}
inline void LoadedCharacters::_internal_set_scene_description(const std::string& value) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedCharacters::set_scene_description(std::string&& value) {
  
  scene_description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedCharacters.scene_description)
}
inline void LoadedCharacters::set_scene_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedCharacters.scene_description)
}
inline void LoadedCharacters::set_scene_description(const char* value,
    size_t size) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedCharacters.scene_description)
}
inline std::string* LoadedCharacters::_internal_mutable_scene_description() {
  
  return scene_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedCharacters::release_scene_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedCharacters.scene_description)
  return scene_description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedCharacters::set_allocated_scene_description(std::string* scene_description) {
  if (scene_description != nullptr) {
    
  } else {
    
  }
  scene_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedCharacters.scene_description)
}

// string scene_display_name = 4;
inline void LoadedCharacters::clear_scene_display_name() {
  scene_display_name_.ClearToEmpty();
}
inline const std::string& LoadedCharacters::scene_display_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadedCharacters.scene_display_name)
  return _internal_scene_display_name();
}
inline void LoadedCharacters::set_scene_display_name(const std::string& value) {
  _internal_set_scene_display_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadedCharacters.scene_display_name)
}
inline std::string* LoadedCharacters::mutable_scene_display_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadedCharacters.scene_display_name)
  return _internal_mutable_scene_display_name();
}
inline const std::string& LoadedCharacters::_internal_scene_display_name() const {
  return scene_display_name_.Get();
}
inline void LoadedCharacters::_internal_set_scene_display_name(const std::string& value) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadedCharacters::set_scene_display_name(std::string&& value) {
  
  scene_display_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadedCharacters.scene_display_name)
}
inline void LoadedCharacters::set_scene_display_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadedCharacters.scene_display_name)
}
inline void LoadedCharacters::set_scene_display_name(const char* value,
    size_t size) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadedCharacters.scene_display_name)
}
inline std::string* LoadedCharacters::_internal_mutable_scene_display_name() {
  
  return scene_display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadedCharacters::release_scene_display_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadedCharacters.scene_display_name)
  return scene_display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadedCharacters::set_allocated_scene_display_name(std::string* scene_display_name) {
  if (scene_display_name != nullptr) {
    
  } else {
    
  }
  scene_display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_display_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadedCharacters.scene_display_name)
}

// -------------------------------------------------------------------

// UnloadCharacters

// repeated .ai.inworld.packets.Agent agents = 1;
inline int UnloadCharacters::_internal_agents_size() const {
  return agents_.size();
}
inline int UnloadCharacters::agents_size() const {
  return _internal_agents_size();
}
inline void UnloadCharacters::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::Agent* UnloadCharacters::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.UnloadCharacters.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
UnloadCharacters::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.UnloadCharacters.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::Agent& UnloadCharacters::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::Agent& UnloadCharacters::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.UnloadCharacters.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::Agent* UnloadCharacters::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::Agent* UnloadCharacters::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.UnloadCharacters.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
UnloadCharacters::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.UnloadCharacters.agents)
  return agents_;
}

// -------------------------------------------------------------------

// CurrentSceneStatus

// repeated .ai.inworld.packets.Agent agents = 1;
inline int CurrentSceneStatus::_internal_agents_size() const {
  return agents_.size();
}
inline int CurrentSceneStatus::agents_size() const {
  return _internal_agents_size();
}
inline void CurrentSceneStatus::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::Agent* CurrentSceneStatus::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CurrentSceneStatus.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >*
CurrentSceneStatus::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CurrentSceneStatus.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::Agent& CurrentSceneStatus::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::Agent& CurrentSceneStatus::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CurrentSceneStatus.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::Agent* CurrentSceneStatus::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::Agent* CurrentSceneStatus::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CurrentSceneStatus.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Agent >&
CurrentSceneStatus::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CurrentSceneStatus.agents)
  return agents_;
}

// string scene_name = 2;
inline void CurrentSceneStatus::clear_scene_name() {
  scene_name_.ClearToEmpty();
}
inline const std::string& CurrentSceneStatus::scene_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CurrentSceneStatus.scene_name)
  return _internal_scene_name();
}
inline void CurrentSceneStatus::set_scene_name(const std::string& value) {
  _internal_set_scene_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CurrentSceneStatus.scene_name)
}
inline std::string* CurrentSceneStatus::mutable_scene_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CurrentSceneStatus.scene_name)
  return _internal_mutable_scene_name();
}
inline const std::string& CurrentSceneStatus::_internal_scene_name() const {
  return scene_name_.Get();
}
inline void CurrentSceneStatus::_internal_set_scene_name(const std::string& value) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CurrentSceneStatus::set_scene_name(std::string&& value) {
  
  scene_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CurrentSceneStatus.scene_name)
}
inline void CurrentSceneStatus::set_scene_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CurrentSceneStatus.scene_name)
}
inline void CurrentSceneStatus::set_scene_name(const char* value,
    size_t size) {
  
  scene_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CurrentSceneStatus.scene_name)
}
inline std::string* CurrentSceneStatus::_internal_mutable_scene_name() {
  
  return scene_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CurrentSceneStatus::release_scene_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CurrentSceneStatus.scene_name)
  return scene_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrentSceneStatus::set_allocated_scene_name(std::string* scene_name) {
  if (scene_name != nullptr) {
    
  } else {
    
  }
  scene_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CurrentSceneStatus.scene_name)
}

// string scene_description = 3;
inline void CurrentSceneStatus::clear_scene_description() {
  scene_description_.ClearToEmpty();
}
inline const std::string& CurrentSceneStatus::scene_description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CurrentSceneStatus.scene_description)
  return _internal_scene_description();
}
inline void CurrentSceneStatus::set_scene_description(const std::string& value) {
  _internal_set_scene_description(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CurrentSceneStatus.scene_description)
}
inline std::string* CurrentSceneStatus::mutable_scene_description() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CurrentSceneStatus.scene_description)
  return _internal_mutable_scene_description();
}
inline const std::string& CurrentSceneStatus::_internal_scene_description() const {
  return scene_description_.Get();
}
inline void CurrentSceneStatus::_internal_set_scene_description(const std::string& value) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CurrentSceneStatus::set_scene_description(std::string&& value) {
  
  scene_description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CurrentSceneStatus.scene_description)
}
inline void CurrentSceneStatus::set_scene_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CurrentSceneStatus.scene_description)
}
inline void CurrentSceneStatus::set_scene_description(const char* value,
    size_t size) {
  
  scene_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CurrentSceneStatus.scene_description)
}
inline std::string* CurrentSceneStatus::_internal_mutable_scene_description() {
  
  return scene_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CurrentSceneStatus::release_scene_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CurrentSceneStatus.scene_description)
  return scene_description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrentSceneStatus::set_allocated_scene_description(std::string* scene_description) {
  if (scene_description != nullptr) {
    
  } else {
    
  }
  scene_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CurrentSceneStatus.scene_description)
}

// string scene_display_name = 4;
inline void CurrentSceneStatus::clear_scene_display_name() {
  scene_display_name_.ClearToEmpty();
}
inline const std::string& CurrentSceneStatus::scene_display_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
  return _internal_scene_display_name();
}
inline void CurrentSceneStatus::set_scene_display_name(const std::string& value) {
  _internal_set_scene_display_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
}
inline std::string* CurrentSceneStatus::mutable_scene_display_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
  return _internal_mutable_scene_display_name();
}
inline const std::string& CurrentSceneStatus::_internal_scene_display_name() const {
  return scene_display_name_.Get();
}
inline void CurrentSceneStatus::_internal_set_scene_display_name(const std::string& value) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CurrentSceneStatus::set_scene_display_name(std::string&& value) {
  
  scene_display_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
}
inline void CurrentSceneStatus::set_scene_display_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
}
inline void CurrentSceneStatus::set_scene_display_name(const char* value,
    size_t size) {
  
  scene_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
}
inline std::string* CurrentSceneStatus::_internal_mutable_scene_display_name() {
  
  return scene_display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CurrentSceneStatus::release_scene_display_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
  return scene_display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CurrentSceneStatus::set_allocated_scene_display_name(std::string* scene_display_name) {
  if (scene_display_name != nullptr) {
    
  } else {
    
  }
  scene_display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scene_display_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CurrentSceneStatus.scene_display_name)
}

// -------------------------------------------------------------------

// ModifyExactResponse

// string interaction_id = 1;
inline void ModifyExactResponse::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_interaction_id();
}
inline void ModifyExactResponse::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& ModifyExactResponse::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void ModifyExactResponse::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModifyExactResponse::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline void ModifyExactResponse::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline void ModifyExactResponse::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModifyExactResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModifyExactResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.interaction_id)
}

// string exact_text = 2;
inline void ModifyExactResponse::clear_exact_text() {
  exact_text_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::exact_text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_exact_text();
}
inline void ModifyExactResponse::set_exact_text(const std::string& value) {
  _internal_set_exact_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::mutable_exact_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_mutable_exact_text();
}
inline const std::string& ModifyExactResponse::_internal_exact_text() const {
  return exact_text_.Get();
}
inline void ModifyExactResponse::_internal_set_exact_text(const std::string& value) {
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModifyExactResponse::set_exact_text(std::string&& value) {
  
  exact_text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline void ModifyExactResponse::set_exact_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline void ModifyExactResponse::set_exact_text(const char* value,
    size_t size) {
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::_internal_mutable_exact_text() {
  
  return exact_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModifyExactResponse::release_exact_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.exact_text)
  return exact_text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModifyExactResponse::set_allocated_exact_text(std::string* exact_text) {
  if (exact_text != nullptr) {
    
  } else {
    
  }
  exact_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exact_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.exact_text)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent_Agent

// string agent_id = 1;
inline void LoadSceneOutputEvent_Agent::clear_agent_id() {
  agent_id_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::agent_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_agent_id();
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const std::string& value) {
  _internal_set_agent_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_agent_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_mutable_agent_id();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_agent_id() const {
  return agent_id_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_agent_id(const std::string& value) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(std::string&& value) {
  
  agent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const char* value,
    size_t size) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_agent_id() {
  
  return agent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_agent_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return agent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  agent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}

// string brain_name = 2;
inline void LoadSceneOutputEvent_Agent::clear_brain_name() {
  brain_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::brain_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_brain_name();
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const std::string& value) {
  _internal_set_brain_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_brain_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_mutable_brain_name();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_brain_name() const {
  return brain_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_brain_name(const std::string& value) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(std::string&& value) {
  
  brain_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const char* value,
    size_t size) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_brain_name() {
  
  return brain_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_brain_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return brain_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_brain_name(std::string* brain_name) {
  if (brain_name != nullptr) {
    
  } else {
    
  }
  brain_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brain_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}

// string given_name = 3;
inline void LoadSceneOutputEvent_Agent::clear_given_name() {
  given_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::given_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_given_name();
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const std::string& value) {
  _internal_set_given_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_given_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_mutable_given_name();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_given_name() const {
  return given_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_given_name(const std::string& value) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_given_name(std::string&& value) {
  
  given_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const char* value,
    size_t size) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_given_name() {
  
  return given_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_given_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return given_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_given_name(std::string* given_name) {
  if (given_name != nullptr) {
    
  } else {
    
  }
  given_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), given_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent

// repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
inline int LoadSceneOutputEvent::_internal_agents_size() const {
  return agents_.size();
}
inline int LoadSceneOutputEvent::agents_size() const {
  return _internal_agents_size();
}
inline void LoadSceneOutputEvent::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
LoadSceneOutputEvent::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
LoadSceneOutputEvent::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return agents_;
}

// -------------------------------------------------------------------

// Agent_CharacterAssets

// string rpm_model_uri = 1;
inline void Agent_CharacterAssets::clear_rpm_model_uri() {
  rpm_model_uri_.ClearToEmpty();
}
inline const std::string& Agent_CharacterAssets::rpm_model_uri() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
  return _internal_rpm_model_uri();
}
inline void Agent_CharacterAssets::set_rpm_model_uri(const std::string& value) {
  _internal_set_rpm_model_uri(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
}
inline std::string* Agent_CharacterAssets::mutable_rpm_model_uri() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
  return _internal_mutable_rpm_model_uri();
}
inline const std::string& Agent_CharacterAssets::_internal_rpm_model_uri() const {
  return rpm_model_uri_.Get();
}
inline void Agent_CharacterAssets::_internal_set_rpm_model_uri(const std::string& value) {
  
  rpm_model_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent_CharacterAssets::set_rpm_model_uri(std::string&& value) {
  
  rpm_model_uri_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
}
inline void Agent_CharacterAssets::set_rpm_model_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rpm_model_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
}
inline void Agent_CharacterAssets::set_rpm_model_uri(const char* value,
    size_t size) {
  
  rpm_model_uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
}
inline std::string* Agent_CharacterAssets::_internal_mutable_rpm_model_uri() {
  
  return rpm_model_uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent_CharacterAssets::release_rpm_model_uri() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
  return rpm_model_uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent_CharacterAssets::set_allocated_rpm_model_uri(std::string* rpm_model_uri) {
  if (rpm_model_uri != nullptr) {
    
  } else {
    
  }
  rpm_model_uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rpm_model_uri,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.CharacterAssets.rpm_model_uri)
}

// string rpm_image_uri_portrait = 2;
inline void Agent_CharacterAssets::clear_rpm_image_uri_portrait() {
  rpm_image_uri_portrait_.ClearToEmpty();
}
inline const std::string& Agent_CharacterAssets::rpm_image_uri_portrait() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
  return _internal_rpm_image_uri_portrait();
}
inline void Agent_CharacterAssets::set_rpm_image_uri_portrait(const std::string& value) {
  _internal_set_rpm_image_uri_portrait(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
}
inline std::string* Agent_CharacterAssets::mutable_rpm_image_uri_portrait() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
  return _internal_mutable_rpm_image_uri_portrait();
}
inline const std::string& Agent_CharacterAssets::_internal_rpm_image_uri_portrait() const {
  return rpm_image_uri_portrait_.Get();
}
inline void Agent_CharacterAssets::_internal_set_rpm_image_uri_portrait(const std::string& value) {
  
  rpm_image_uri_portrait_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent_CharacterAssets::set_rpm_image_uri_portrait(std::string&& value) {
  
  rpm_image_uri_portrait_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
}
inline void Agent_CharacterAssets::set_rpm_image_uri_portrait(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rpm_image_uri_portrait_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
}
inline void Agent_CharacterAssets::set_rpm_image_uri_portrait(const char* value,
    size_t size) {
  
  rpm_image_uri_portrait_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
}
inline std::string* Agent_CharacterAssets::_internal_mutable_rpm_image_uri_portrait() {
  
  return rpm_image_uri_portrait_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent_CharacterAssets::release_rpm_image_uri_portrait() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
  return rpm_image_uri_portrait_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent_CharacterAssets::set_allocated_rpm_image_uri_portrait(std::string* rpm_image_uri_portrait) {
  if (rpm_image_uri_portrait != nullptr) {
    
  } else {
    
  }
  rpm_image_uri_portrait_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rpm_image_uri_portrait,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_portrait)
}

// string rpm_image_uri_posture = 3;
inline void Agent_CharacterAssets::clear_rpm_image_uri_posture() {
  rpm_image_uri_posture_.ClearToEmpty();
}
inline const std::string& Agent_CharacterAssets::rpm_image_uri_posture() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
  return _internal_rpm_image_uri_posture();
}
inline void Agent_CharacterAssets::set_rpm_image_uri_posture(const std::string& value) {
  _internal_set_rpm_image_uri_posture(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
}
inline std::string* Agent_CharacterAssets::mutable_rpm_image_uri_posture() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
  return _internal_mutable_rpm_image_uri_posture();
}
inline const std::string& Agent_CharacterAssets::_internal_rpm_image_uri_posture() const {
  return rpm_image_uri_posture_.Get();
}
inline void Agent_CharacterAssets::_internal_set_rpm_image_uri_posture(const std::string& value) {
  
  rpm_image_uri_posture_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent_CharacterAssets::set_rpm_image_uri_posture(std::string&& value) {
  
  rpm_image_uri_posture_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
}
inline void Agent_CharacterAssets::set_rpm_image_uri_posture(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rpm_image_uri_posture_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
}
inline void Agent_CharacterAssets::set_rpm_image_uri_posture(const char* value,
    size_t size) {
  
  rpm_image_uri_posture_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
}
inline std::string* Agent_CharacterAssets::_internal_mutable_rpm_image_uri_posture() {
  
  return rpm_image_uri_posture_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent_CharacterAssets::release_rpm_image_uri_posture() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
  return rpm_image_uri_posture_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent_CharacterAssets::set_allocated_rpm_image_uri_posture(std::string* rpm_image_uri_posture) {
  if (rpm_image_uri_posture != nullptr) {
    
  } else {
    
  }
  rpm_image_uri_posture_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rpm_image_uri_posture,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.CharacterAssets.rpm_image_uri_posture)
}

// string avatar_img = 4;
inline void Agent_CharacterAssets::clear_avatar_img() {
  avatar_img_.ClearToEmpty();
}
inline const std::string& Agent_CharacterAssets::avatar_img() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
  return _internal_avatar_img();
}
inline void Agent_CharacterAssets::set_avatar_img(const std::string& value) {
  _internal_set_avatar_img(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
}
inline std::string* Agent_CharacterAssets::mutable_avatar_img() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
  return _internal_mutable_avatar_img();
}
inline const std::string& Agent_CharacterAssets::_internal_avatar_img() const {
  return avatar_img_.Get();
}
inline void Agent_CharacterAssets::_internal_set_avatar_img(const std::string& value) {
  
  avatar_img_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent_CharacterAssets::set_avatar_img(std::string&& value) {
  
  avatar_img_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
}
inline void Agent_CharacterAssets::set_avatar_img(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  avatar_img_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
}
inline void Agent_CharacterAssets::set_avatar_img(const char* value,
    size_t size) {
  
  avatar_img_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
}
inline std::string* Agent_CharacterAssets::_internal_mutable_avatar_img() {
  
  return avatar_img_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent_CharacterAssets::release_avatar_img() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
  return avatar_img_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent_CharacterAssets::set_allocated_avatar_img(std::string* avatar_img) {
  if (avatar_img != nullptr) {
    
  } else {
    
  }
  avatar_img_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_img,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.CharacterAssets.avatar_img)
}

// string avatar_img_original = 5;
inline void Agent_CharacterAssets::clear_avatar_img_original() {
  avatar_img_original_.ClearToEmpty();
}
inline const std::string& Agent_CharacterAssets::avatar_img_original() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
  return _internal_avatar_img_original();
}
inline void Agent_CharacterAssets::set_avatar_img_original(const std::string& value) {
  _internal_set_avatar_img_original(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
}
inline std::string* Agent_CharacterAssets::mutable_avatar_img_original() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
  return _internal_mutable_avatar_img_original();
}
inline const std::string& Agent_CharacterAssets::_internal_avatar_img_original() const {
  return avatar_img_original_.Get();
}
inline void Agent_CharacterAssets::_internal_set_avatar_img_original(const std::string& value) {
  
  avatar_img_original_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent_CharacterAssets::set_avatar_img_original(std::string&& value) {
  
  avatar_img_original_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
}
inline void Agent_CharacterAssets::set_avatar_img_original(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  avatar_img_original_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
}
inline void Agent_CharacterAssets::set_avatar_img_original(const char* value,
    size_t size) {
  
  avatar_img_original_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
}
inline std::string* Agent_CharacterAssets::_internal_mutable_avatar_img_original() {
  
  return avatar_img_original_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent_CharacterAssets::release_avatar_img_original() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
  return avatar_img_original_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent_CharacterAssets::set_allocated_avatar_img_original(std::string* avatar_img_original) {
  if (avatar_img_original != nullptr) {
    
  } else {
    
  }
  avatar_img_original_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_img_original,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.CharacterAssets.avatar_img_original)
}

// -------------------------------------------------------------------

// Agent

// string agent_id = 1;
inline void Agent::clear_agent_id() {
  agent_id_.ClearToEmpty();
}
inline const std::string& Agent::agent_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.agent_id)
  return _internal_agent_id();
}
inline void Agent::set_agent_id(const std::string& value) {
  _internal_set_agent_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.agent_id)
}
inline std::string* Agent::mutable_agent_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.agent_id)
  return _internal_mutable_agent_id();
}
inline const std::string& Agent::_internal_agent_id() const {
  return agent_id_.Get();
}
inline void Agent::_internal_set_agent_id(const std::string& value) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent::set_agent_id(std::string&& value) {
  
  agent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.agent_id)
}
inline void Agent::set_agent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.agent_id)
}
inline void Agent::set_agent_id(const char* value,
    size_t size) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.agent_id)
}
inline std::string* Agent::_internal_mutable_agent_id() {
  
  return agent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent::release_agent_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.agent_id)
  return agent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  agent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.agent_id)
}

// string brain_name = 2;
inline void Agent::clear_brain_name() {
  brain_name_.ClearToEmpty();
}
inline const std::string& Agent::brain_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.brain_name)
  return _internal_brain_name();
}
inline void Agent::set_brain_name(const std::string& value) {
  _internal_set_brain_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.brain_name)
}
inline std::string* Agent::mutable_brain_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.brain_name)
  return _internal_mutable_brain_name();
}
inline const std::string& Agent::_internal_brain_name() const {
  return brain_name_.Get();
}
inline void Agent::_internal_set_brain_name(const std::string& value) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent::set_brain_name(std::string&& value) {
  
  brain_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.brain_name)
}
inline void Agent::set_brain_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.brain_name)
}
inline void Agent::set_brain_name(const char* value,
    size_t size) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.brain_name)
}
inline std::string* Agent::_internal_mutable_brain_name() {
  
  return brain_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent::release_brain_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.brain_name)
  return brain_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent::set_allocated_brain_name(std::string* brain_name) {
  if (brain_name != nullptr) {
    
  } else {
    
  }
  brain_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brain_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.brain_name)
}

// string given_name = 3;
inline void Agent::clear_given_name() {
  given_name_.ClearToEmpty();
}
inline const std::string& Agent::given_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.given_name)
  return _internal_given_name();
}
inline void Agent::set_given_name(const std::string& value) {
  _internal_set_given_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Agent.given_name)
}
inline std::string* Agent::mutable_given_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.given_name)
  return _internal_mutable_given_name();
}
inline const std::string& Agent::_internal_given_name() const {
  return given_name_.Get();
}
inline void Agent::_internal_set_given_name(const std::string& value) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Agent::set_given_name(std::string&& value) {
  
  given_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Agent.given_name)
}
inline void Agent::set_given_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Agent.given_name)
}
inline void Agent::set_given_name(const char* value,
    size_t size) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Agent.given_name)
}
inline std::string* Agent::_internal_mutable_given_name() {
  
  return given_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Agent::release_given_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.given_name)
  return given_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Agent::set_allocated_given_name(std::string* given_name) {
  if (given_name != nullptr) {
    
  } else {
    
  }
  given_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), given_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.given_name)
}

// .ai.inworld.packets.Agent.CharacterAssets character_assets = 4;
inline bool Agent::_internal_has_character_assets() const {
  return this != internal_default_instance() && character_assets_ != nullptr;
}
inline bool Agent::has_character_assets() const {
  return _internal_has_character_assets();
}
inline void Agent::clear_character_assets() {
  if (GetArena() == nullptr && character_assets_ != nullptr) {
    delete character_assets_;
  }
  character_assets_ = nullptr;
}
inline const ::ai::inworld::packets::Agent_CharacterAssets& Agent::_internal_character_assets() const {
  const ::ai::inworld::packets::Agent_CharacterAssets* p = character_assets_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Agent_CharacterAssets&>(
      ::ai::inworld::packets::_Agent_CharacterAssets_default_instance_);
}
inline const ::ai::inworld::packets::Agent_CharacterAssets& Agent::character_assets() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Agent.character_assets)
  return _internal_character_assets();
}
inline void Agent::unsafe_arena_set_allocated_character_assets(
    ::ai::inworld::packets::Agent_CharacterAssets* character_assets) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(character_assets_);
  }
  character_assets_ = character_assets;
  if (character_assets) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Agent.character_assets)
}
inline ::ai::inworld::packets::Agent_CharacterAssets* Agent::release_character_assets() {
  
  ::ai::inworld::packets::Agent_CharacterAssets* temp = character_assets_;
  character_assets_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Agent_CharacterAssets* Agent::unsafe_arena_release_character_assets() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Agent.character_assets)
  
  ::ai::inworld::packets::Agent_CharacterAssets* temp = character_assets_;
  character_assets_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Agent_CharacterAssets* Agent::_internal_mutable_character_assets() {
  
  if (character_assets_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Agent_CharacterAssets>(GetArena());
    character_assets_ = p;
  }
  return character_assets_;
}
inline ::ai::inworld::packets::Agent_CharacterAssets* Agent::mutable_character_assets() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Agent.character_assets)
  return _internal_mutable_character_assets();
}
inline void Agent::set_allocated_character_assets(::ai::inworld::packets::Agent_CharacterAssets* character_assets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete character_assets_;
  }
  if (character_assets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(character_assets);
    if (message_arena != submessage_arena) {
      character_assets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character_assets, submessage_arena);
    }
    
  } else {
    
  }
  character_assets_ = character_assets;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Agent.character_assets)
}

// -------------------------------------------------------------------

// DebugInfoEvent

// .ai.inworld.packets.RelationInfo relation = 1;
inline bool DebugInfoEvent::_internal_has_relation() const {
  return info_case() == kRelation;
}
inline bool DebugInfoEvent::has_relation() const {
  return _internal_has_relation();
}
inline void DebugInfoEvent::set_has_relation() {
  _oneof_case_[0] = kRelation;
}
inline void DebugInfoEvent::clear_relation() {
  if (_internal_has_relation()) {
    if (GetArena() == nullptr) {
      delete info_.relation_;
    }
    clear_has_info();
  }
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::release_relation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
      ::ai::inworld::packets::RelationInfo* temp = info_.relation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::_internal_relation() const {
  return _internal_has_relation()
      ? *info_.relation_
      : reinterpret_cast< ::ai::inworld::packets::RelationInfo&>(::ai::inworld::packets::_RelationInfo_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::relation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_relation();
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::unsafe_arena_release_relation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
    ::ai::inworld::packets::RelationInfo* temp = info_.relation_;
    info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugInfoEvent::unsafe_arena_set_allocated_relation(::ai::inworld::packets::RelationInfo* relation) {
  clear_info();
  if (relation) {
    set_has_relation();
    info_.relation_ = relation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DebugInfoEvent.relation)
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::_internal_mutable_relation() {
  if (!_internal_has_relation()) {
    clear_info();
    set_has_relation();
    info_.relation_ = CreateMaybeMessage< ::ai::inworld::packets::RelationInfo >(GetArena());
  }
  return info_.relation_;
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::mutable_relation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_mutable_relation();
}

inline bool DebugInfoEvent::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void DebugInfoEvent::clear_has_info() {
  _oneof_case_[0] = INFO_NOT_SET;
}
inline DebugInfoEvent::InfoCase DebugInfoEvent::info_case() const {
  return DebugInfoEvent::InfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionControlEvent

// .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
inline bool SessionControlEvent::_internal_has_session_configuration() const {
  return session_control_case() == kSessionConfiguration;
}
inline bool SessionControlEvent::has_session_configuration() const {
  return _internal_has_session_configuration();
}
inline void SessionControlEvent::set_has_session_configuration() {
  _oneof_case_[0] = kSessionConfiguration;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::release_session_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.session_configuration)
  if (_internal_has_session_configuration()) {
    clear_has_session_control();
      ::ai::inworld::engine::configuration::SessionConfiguration* temp = session_control_.session_configuration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionControlEvent::_internal_session_configuration() const {
  return _internal_has_session_configuration()
      ? *session_control_.session_configuration_
      : reinterpret_cast< ::ai::inworld::engine::configuration::SessionConfiguration&>(::ai::inworld::engine::configuration::_SessionConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionControlEvent::session_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.session_configuration)
  return _internal_session_configuration();
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::unsafe_arena_release_session_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.session_configuration)
  if (_internal_has_session_configuration()) {
    clear_has_session_control();
    ::ai::inworld::engine::configuration::SessionConfiguration* temp = session_control_.session_configuration_;
    session_control_.session_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* session_configuration) {
  clear_session_control();
  if (session_configuration) {
    set_has_session_configuration();
    session_control_.session_configuration_ = session_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.session_configuration)
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::_internal_mutable_session_configuration() {
  if (!_internal_has_session_configuration()) {
    clear_session_control();
    set_has_session_configuration();
    session_control_.session_configuration_ = CreateMaybeMessage< ::ai::inworld::engine::configuration::SessionConfiguration >(GetArena());
  }
  return session_control_.session_configuration_;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionControlEvent::mutable_session_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.session_configuration)
  return _internal_mutable_session_configuration();
}

// .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
inline bool SessionControlEvent::_internal_has_user_configuration() const {
  return session_control_case() == kUserConfiguration;
}
inline bool SessionControlEvent::has_user_configuration() const {
  return _internal_has_user_configuration();
}
inline void SessionControlEvent::set_has_user_configuration() {
  _oneof_case_[0] = kUserConfiguration;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::release_user_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.user_configuration)
  if (_internal_has_user_configuration()) {
    clear_has_session_control();
      ::ai::inworld::engine::configuration::UserConfiguration* temp = session_control_.user_configuration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.user_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionControlEvent::_internal_user_configuration() const {
  return _internal_has_user_configuration()
      ? *session_control_.user_configuration_
      : reinterpret_cast< ::ai::inworld::engine::configuration::UserConfiguration&>(::ai::inworld::engine::configuration::_UserConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionControlEvent::user_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.user_configuration)
  return _internal_user_configuration();
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::unsafe_arena_release_user_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.user_configuration)
  if (_internal_has_user_configuration()) {
    clear_has_session_control();
    ::ai::inworld::engine::configuration::UserConfiguration* temp = session_control_.user_configuration_;
    session_control_.user_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* user_configuration) {
  clear_session_control();
  if (user_configuration) {
    set_has_user_configuration();
    session_control_.user_configuration_ = user_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.user_configuration)
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::_internal_mutable_user_configuration() {
  if (!_internal_has_user_configuration()) {
    clear_session_control();
    set_has_user_configuration();
    session_control_.user_configuration_ = CreateMaybeMessage< ::ai::inworld::engine::configuration::UserConfiguration >(GetArena());
  }
  return session_control_.user_configuration_;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionControlEvent::mutable_user_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.user_configuration)
  return _internal_mutable_user_configuration();
}

// .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
inline bool SessionControlEvent::_internal_has_client_configuration() const {
  return session_control_case() == kClientConfiguration;
}
inline bool SessionControlEvent::has_client_configuration() const {
  return _internal_has_client_configuration();
}
inline void SessionControlEvent::set_has_client_configuration() {
  _oneof_case_[0] = kClientConfiguration;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::release_client_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.client_configuration)
  if (_internal_has_client_configuration()) {
    clear_has_session_control();
      ::ai::inworld::engine::configuration::ClientConfiguration* temp = session_control_.client_configuration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.client_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionControlEvent::_internal_client_configuration() const {
  return _internal_has_client_configuration()
      ? *session_control_.client_configuration_
      : reinterpret_cast< ::ai::inworld::engine::configuration::ClientConfiguration&>(::ai::inworld::engine::configuration::_ClientConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionControlEvent::client_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.client_configuration)
  return _internal_client_configuration();
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.client_configuration)
  if (_internal_has_client_configuration()) {
    clear_has_session_control();
    ::ai::inworld::engine::configuration::ClientConfiguration* temp = session_control_.client_configuration_;
    session_control_.client_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* client_configuration) {
  clear_session_control();
  if (client_configuration) {
    set_has_client_configuration();
    session_control_.client_configuration_ = client_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.client_configuration)
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::_internal_mutable_client_configuration() {
  if (!_internal_has_client_configuration()) {
    clear_session_control();
    set_has_client_configuration();
    session_control_.client_configuration_ = CreateMaybeMessage< ::ai::inworld::engine::configuration::ClientConfiguration >(GetArena());
  }
  return session_control_.client_configuration_;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionControlEvent::mutable_client_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.client_configuration)
  return _internal_mutable_client_configuration();
}

// .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
inline bool SessionControlEvent::_internal_has_capabilities_configuration() const {
  return session_control_case() == kCapabilitiesConfiguration;
}
inline bool SessionControlEvent::has_capabilities_configuration() const {
  return _internal_has_capabilities_configuration();
}
inline void SessionControlEvent::set_has_capabilities_configuration() {
  _oneof_case_[0] = kCapabilitiesConfiguration;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::release_capabilities_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  if (_internal_has_capabilities_configuration()) {
    clear_has_session_control();
      ::ai::inworld::engine::configuration::CapabilitiesConfiguration* temp = session_control_.capabilities_configuration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.capabilities_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionControlEvent::_internal_capabilities_configuration() const {
  return _internal_has_capabilities_configuration()
      ? *session_control_.capabilities_configuration_
      : reinterpret_cast< ::ai::inworld::engine::configuration::CapabilitiesConfiguration&>(::ai::inworld::engine::configuration::_CapabilitiesConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionControlEvent::capabilities_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  return _internal_capabilities_configuration();
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::unsafe_arena_release_capabilities_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  if (_internal_has_capabilities_configuration()) {
    clear_has_session_control();
    ::ai::inworld::engine::configuration::CapabilitiesConfiguration* temp = session_control_.capabilities_configuration_;
    session_control_.capabilities_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration) {
  clear_session_control();
  if (capabilities_configuration) {
    set_has_capabilities_configuration();
    session_control_.capabilities_configuration_ = capabilities_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::_internal_mutable_capabilities_configuration() {
  if (!_internal_has_capabilities_configuration()) {
    clear_session_control();
    set_has_capabilities_configuration();
    session_control_.capabilities_configuration_ = CreateMaybeMessage< ::ai::inworld::engine::configuration::CapabilitiesConfiguration >(GetArena());
  }
  return session_control_.capabilities_configuration_;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionControlEvent::mutable_capabilities_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.capabilities_configuration)
  return _internal_mutable_capabilities_configuration();
}

// .ai.inworld.packets.Continuation continuation = 5;
inline bool SessionControlEvent::_internal_has_continuation() const {
  return session_control_case() == kContinuation;
}
inline bool SessionControlEvent::has_continuation() const {
  return _internal_has_continuation();
}
inline void SessionControlEvent::set_has_continuation() {
  _oneof_case_[0] = kContinuation;
}
inline void SessionControlEvent::clear_continuation() {
  if (_internal_has_continuation()) {
    if (GetArena() == nullptr) {
      delete session_control_.continuation_;
    }
    clear_has_session_control();
  }
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::release_continuation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.continuation)
  if (_internal_has_continuation()) {
    clear_has_session_control();
      ::ai::inworld::packets::Continuation* temp = session_control_.continuation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.continuation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::Continuation& SessionControlEvent::_internal_continuation() const {
  return _internal_has_continuation()
      ? *session_control_.continuation_
      : reinterpret_cast< ::ai::inworld::packets::Continuation&>(::ai::inworld::packets::_Continuation_default_instance_);
}
inline const ::ai::inworld::packets::Continuation& SessionControlEvent::continuation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.continuation)
  return _internal_continuation();
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::unsafe_arena_release_continuation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.continuation)
  if (_internal_has_continuation()) {
    clear_has_session_control();
    ::ai::inworld::packets::Continuation* temp = session_control_.continuation_;
    session_control_.continuation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_continuation(::ai::inworld::packets::Continuation* continuation) {
  clear_session_control();
  if (continuation) {
    set_has_continuation();
    session_control_.continuation_ = continuation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.continuation)
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::_internal_mutable_continuation() {
  if (!_internal_has_continuation()) {
    clear_session_control();
    set_has_continuation();
    session_control_.continuation_ = CreateMaybeMessage< ::ai::inworld::packets::Continuation >(GetArena());
  }
  return session_control_.continuation_;
}
inline ::ai::inworld::packets::Continuation* SessionControlEvent::mutable_continuation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.continuation)
  return _internal_mutable_continuation();
}

// .ai.inworld.packets.SessionHistoryRequest session_history_request = 6;
inline bool SessionControlEvent::_internal_has_session_history_request() const {
  return session_control_case() == kSessionHistoryRequest;
}
inline bool SessionControlEvent::has_session_history_request() const {
  return _internal_has_session_history_request();
}
inline void SessionControlEvent::set_has_session_history_request() {
  _oneof_case_[0] = kSessionHistoryRequest;
}
inline void SessionControlEvent::clear_session_history_request() {
  if (_internal_has_session_history_request()) {
    if (GetArena() == nullptr) {
      delete session_control_.session_history_request_;
    }
    clear_has_session_control();
  }
}
inline ::ai::inworld::packets::SessionHistoryRequest* SessionControlEvent::release_session_history_request() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.session_history_request)
  if (_internal_has_session_history_request()) {
    clear_has_session_control();
      ::ai::inworld::packets::SessionHistoryRequest* temp = session_control_.session_history_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.session_history_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionHistoryRequest& SessionControlEvent::_internal_session_history_request() const {
  return _internal_has_session_history_request()
      ? *session_control_.session_history_request_
      : reinterpret_cast< ::ai::inworld::packets::SessionHistoryRequest&>(::ai::inworld::packets::_SessionHistoryRequest_default_instance_);
}
inline const ::ai::inworld::packets::SessionHistoryRequest& SessionControlEvent::session_history_request() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.session_history_request)
  return _internal_session_history_request();
}
inline ::ai::inworld::packets::SessionHistoryRequest* SessionControlEvent::unsafe_arena_release_session_history_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.session_history_request)
  if (_internal_has_session_history_request()) {
    clear_has_session_control();
    ::ai::inworld::packets::SessionHistoryRequest* temp = session_control_.session_history_request_;
    session_control_.session_history_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_session_history_request(::ai::inworld::packets::SessionHistoryRequest* session_history_request) {
  clear_session_control();
  if (session_history_request) {
    set_has_session_history_request();
    session_control_.session_history_request_ = session_history_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.session_history_request)
}
inline ::ai::inworld::packets::SessionHistoryRequest* SessionControlEvent::_internal_mutable_session_history_request() {
  if (!_internal_has_session_history_request()) {
    clear_session_control();
    set_has_session_history_request();
    session_control_.session_history_request_ = CreateMaybeMessage< ::ai::inworld::packets::SessionHistoryRequest >(GetArena());
  }
  return session_control_.session_history_request_;
}
inline ::ai::inworld::packets::SessionHistoryRequest* SessionControlEvent::mutable_session_history_request() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.session_history_request)
  return _internal_mutable_session_history_request();
}

// .ai.inworld.packets.SessionConfigurationPayload session_configuration_payload = 7;
inline bool SessionControlEvent::_internal_has_session_configuration_payload() const {
  return session_control_case() == kSessionConfigurationPayload;
}
inline bool SessionControlEvent::has_session_configuration_payload() const {
  return _internal_has_session_configuration_payload();
}
inline void SessionControlEvent::set_has_session_configuration_payload() {
  _oneof_case_[0] = kSessionConfigurationPayload;
}
inline void SessionControlEvent::clear_session_configuration_payload() {
  if (_internal_has_session_configuration_payload()) {
    if (GetArena() == nullptr) {
      delete session_control_.session_configuration_payload_;
    }
    clear_has_session_control();
  }
}
inline ::ai::inworld::packets::SessionConfigurationPayload* SessionControlEvent::release_session_configuration_payload() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionControlEvent.session_configuration_payload)
  if (_internal_has_session_configuration_payload()) {
    clear_has_session_control();
      ::ai::inworld::packets::SessionConfigurationPayload* temp = session_control_.session_configuration_payload_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    session_control_.session_configuration_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::SessionConfigurationPayload& SessionControlEvent::_internal_session_configuration_payload() const {
  return _internal_has_session_configuration_payload()
      ? *session_control_.session_configuration_payload_
      : reinterpret_cast< ::ai::inworld::packets::SessionConfigurationPayload&>(::ai::inworld::packets::_SessionConfigurationPayload_default_instance_);
}
inline const ::ai::inworld::packets::SessionConfigurationPayload& SessionControlEvent::session_configuration_payload() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionControlEvent.session_configuration_payload)
  return _internal_session_configuration_payload();
}
inline ::ai::inworld::packets::SessionConfigurationPayload* SessionControlEvent::unsafe_arena_release_session_configuration_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.SessionControlEvent.session_configuration_payload)
  if (_internal_has_session_configuration_payload()) {
    clear_has_session_control();
    ::ai::inworld::packets::SessionConfigurationPayload* temp = session_control_.session_configuration_payload_;
    session_control_.session_configuration_payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionControlEvent::unsafe_arena_set_allocated_session_configuration_payload(::ai::inworld::packets::SessionConfigurationPayload* session_configuration_payload) {
  clear_session_control();
  if (session_configuration_payload) {
    set_has_session_configuration_payload();
    session_control_.session_configuration_payload_ = session_configuration_payload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionControlEvent.session_configuration_payload)
}
inline ::ai::inworld::packets::SessionConfigurationPayload* SessionControlEvent::_internal_mutable_session_configuration_payload() {
  if (!_internal_has_session_configuration_payload()) {
    clear_session_control();
    set_has_session_configuration_payload();
    session_control_.session_configuration_payload_ = CreateMaybeMessage< ::ai::inworld::packets::SessionConfigurationPayload >(GetArena());
  }
  return session_control_.session_configuration_payload_;
}
inline ::ai::inworld::packets::SessionConfigurationPayload* SessionControlEvent::mutable_session_configuration_payload() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionControlEvent.session_configuration_payload)
  return _internal_mutable_session_configuration_payload();
}

inline bool SessionControlEvent::has_session_control() const {
  return session_control_case() != SESSION_CONTROL_NOT_SET;
}
inline void SessionControlEvent::clear_has_session_control() {
  _oneof_case_[0] = SESSION_CONTROL_NOT_SET;
}
inline SessionControlEvent::SessionControlCase SessionControlEvent::session_control_case() const {
  return SessionControlEvent::SessionControlCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionConfigurationPayload

// .ai.inworld.engine.configuration.SessionConfiguration session_configuration = 1;
inline bool SessionConfigurationPayload::_internal_has_session_configuration() const {
  return this != internal_default_instance() && session_configuration_ != nullptr;
}
inline bool SessionConfigurationPayload::has_session_configuration() const {
  return _internal_has_session_configuration();
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionConfigurationPayload::_internal_session_configuration() const {
  const ::ai::inworld::engine::configuration::SessionConfiguration* p = session_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::engine::configuration::SessionConfiguration&>(
      ::ai::inworld::engine::configuration::_SessionConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::SessionConfiguration& SessionConfigurationPayload::session_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionConfigurationPayload.session_configuration)
  return _internal_session_configuration();
}
inline void SessionConfigurationPayload::unsafe_arena_set_allocated_session_configuration(
    ::ai::inworld::engine::configuration::SessionConfiguration* session_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_configuration_);
  }
  session_configuration_ = session_configuration;
  if (session_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionConfigurationPayload.session_configuration)
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionConfigurationPayload::release_session_configuration() {
  
  ::ai::inworld::engine::configuration::SessionConfiguration* temp = session_configuration_;
  session_configuration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionConfigurationPayload::unsafe_arena_release_session_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionConfigurationPayload.session_configuration)
  
  ::ai::inworld::engine::configuration::SessionConfiguration* temp = session_configuration_;
  session_configuration_ = nullptr;
  return temp;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionConfigurationPayload::_internal_mutable_session_configuration() {
  
  if (session_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::engine::configuration::SessionConfiguration>(GetArena());
    session_configuration_ = p;
  }
  return session_configuration_;
}
inline ::ai::inworld::engine::configuration::SessionConfiguration* SessionConfigurationPayload::mutable_session_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionConfigurationPayload.session_configuration)
  return _internal_mutable_session_configuration();
}
inline void SessionConfigurationPayload::set_allocated_session_configuration(::ai::inworld::engine::configuration::SessionConfiguration* session_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_configuration_);
  }
  if (session_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_configuration)->GetArena();
    if (message_arena != submessage_arena) {
      session_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_configuration, submessage_arena);
    }
    
  } else {
    
  }
  session_configuration_ = session_configuration;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionConfigurationPayload.session_configuration)
}

// .ai.inworld.engine.configuration.UserConfiguration user_configuration = 2;
inline bool SessionConfigurationPayload::_internal_has_user_configuration() const {
  return this != internal_default_instance() && user_configuration_ != nullptr;
}
inline bool SessionConfigurationPayload::has_user_configuration() const {
  return _internal_has_user_configuration();
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionConfigurationPayload::_internal_user_configuration() const {
  const ::ai::inworld::engine::configuration::UserConfiguration* p = user_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::engine::configuration::UserConfiguration&>(
      ::ai::inworld::engine::configuration::_UserConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::UserConfiguration& SessionConfigurationPayload::user_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionConfigurationPayload.user_configuration)
  return _internal_user_configuration();
}
inline void SessionConfigurationPayload::unsafe_arena_set_allocated_user_configuration(
    ::ai::inworld::engine::configuration::UserConfiguration* user_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_configuration_);
  }
  user_configuration_ = user_configuration;
  if (user_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionConfigurationPayload.user_configuration)
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionConfigurationPayload::release_user_configuration() {
  
  ::ai::inworld::engine::configuration::UserConfiguration* temp = user_configuration_;
  user_configuration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionConfigurationPayload::unsafe_arena_release_user_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionConfigurationPayload.user_configuration)
  
  ::ai::inworld::engine::configuration::UserConfiguration* temp = user_configuration_;
  user_configuration_ = nullptr;
  return temp;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionConfigurationPayload::_internal_mutable_user_configuration() {
  
  if (user_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::engine::configuration::UserConfiguration>(GetArena());
    user_configuration_ = p;
  }
  return user_configuration_;
}
inline ::ai::inworld::engine::configuration::UserConfiguration* SessionConfigurationPayload::mutable_user_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionConfigurationPayload.user_configuration)
  return _internal_mutable_user_configuration();
}
inline void SessionConfigurationPayload::set_allocated_user_configuration(::ai::inworld::engine::configuration::UserConfiguration* user_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_configuration_);
  }
  if (user_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_configuration)->GetArena();
    if (message_arena != submessage_arena) {
      user_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_configuration, submessage_arena);
    }
    
  } else {
    
  }
  user_configuration_ = user_configuration;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionConfigurationPayload.user_configuration)
}

// .ai.inworld.engine.configuration.ClientConfiguration client_configuration = 3;
inline bool SessionConfigurationPayload::_internal_has_client_configuration() const {
  return this != internal_default_instance() && client_configuration_ != nullptr;
}
inline bool SessionConfigurationPayload::has_client_configuration() const {
  return _internal_has_client_configuration();
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionConfigurationPayload::_internal_client_configuration() const {
  const ::ai::inworld::engine::configuration::ClientConfiguration* p = client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::engine::configuration::ClientConfiguration&>(
      ::ai::inworld::engine::configuration::_ClientConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::ClientConfiguration& SessionConfigurationPayload::client_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionConfigurationPayload.client_configuration)
  return _internal_client_configuration();
}
inline void SessionConfigurationPayload::unsafe_arena_set_allocated_client_configuration(
    ::ai::inworld::engine::configuration::ClientConfiguration* client_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration_);
  }
  client_configuration_ = client_configuration;
  if (client_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionConfigurationPayload.client_configuration)
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionConfigurationPayload::release_client_configuration() {
  
  ::ai::inworld::engine::configuration::ClientConfiguration* temp = client_configuration_;
  client_configuration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionConfigurationPayload::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionConfigurationPayload.client_configuration)
  
  ::ai::inworld::engine::configuration::ClientConfiguration* temp = client_configuration_;
  client_configuration_ = nullptr;
  return temp;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionConfigurationPayload::_internal_mutable_client_configuration() {
  
  if (client_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::engine::configuration::ClientConfiguration>(GetArena());
    client_configuration_ = p;
  }
  return client_configuration_;
}
inline ::ai::inworld::engine::configuration::ClientConfiguration* SessionConfigurationPayload::mutable_client_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionConfigurationPayload.client_configuration)
  return _internal_mutable_client_configuration();
}
inline void SessionConfigurationPayload::set_allocated_client_configuration(::ai::inworld::engine::configuration::ClientConfiguration* client_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration_);
  }
  if (client_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration)->GetArena();
    if (message_arena != submessage_arena) {
      client_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_configuration, submessage_arena);
    }
    
  } else {
    
  }
  client_configuration_ = client_configuration;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionConfigurationPayload.client_configuration)
}

// .ai.inworld.engine.configuration.CapabilitiesConfiguration capabilities_configuration = 4;
inline bool SessionConfigurationPayload::_internal_has_capabilities_configuration() const {
  return this != internal_default_instance() && capabilities_configuration_ != nullptr;
}
inline bool SessionConfigurationPayload::has_capabilities_configuration() const {
  return _internal_has_capabilities_configuration();
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionConfigurationPayload::_internal_capabilities_configuration() const {
  const ::ai::inworld::engine::configuration::CapabilitiesConfiguration* p = capabilities_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::engine::configuration::CapabilitiesConfiguration&>(
      ::ai::inworld::engine::configuration::_CapabilitiesConfiguration_default_instance_);
}
inline const ::ai::inworld::engine::configuration::CapabilitiesConfiguration& SessionConfigurationPayload::capabilities_configuration() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionConfigurationPayload.capabilities_configuration)
  return _internal_capabilities_configuration();
}
inline void SessionConfigurationPayload::unsafe_arena_set_allocated_capabilities_configuration(
    ::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilities_configuration_);
  }
  capabilities_configuration_ = capabilities_configuration;
  if (capabilities_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionConfigurationPayload.capabilities_configuration)
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionConfigurationPayload::release_capabilities_configuration() {
  
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* temp = capabilities_configuration_;
  capabilities_configuration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionConfigurationPayload::unsafe_arena_release_capabilities_configuration() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionConfigurationPayload.capabilities_configuration)
  
  ::ai::inworld::engine::configuration::CapabilitiesConfiguration* temp = capabilities_configuration_;
  capabilities_configuration_ = nullptr;
  return temp;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionConfigurationPayload::_internal_mutable_capabilities_configuration() {
  
  if (capabilities_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::engine::configuration::CapabilitiesConfiguration>(GetArena());
    capabilities_configuration_ = p;
  }
  return capabilities_configuration_;
}
inline ::ai::inworld::engine::configuration::CapabilitiesConfiguration* SessionConfigurationPayload::mutable_capabilities_configuration() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionConfigurationPayload.capabilities_configuration)
  return _internal_mutable_capabilities_configuration();
}
inline void SessionConfigurationPayload::set_allocated_capabilities_configuration(::ai::inworld::engine::configuration::CapabilitiesConfiguration* capabilities_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilities_configuration_);
  }
  if (capabilities_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capabilities_configuration)->GetArena();
    if (message_arena != submessage_arena) {
      capabilities_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities_configuration, submessage_arena);
    }
    
  } else {
    
  }
  capabilities_configuration_ = capabilities_configuration;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionConfigurationPayload.capabilities_configuration)
}

// .ai.inworld.packets.Continuation continuation = 5;
inline bool SessionConfigurationPayload::_internal_has_continuation() const {
  return this != internal_default_instance() && continuation_ != nullptr;
}
inline bool SessionConfigurationPayload::has_continuation() const {
  return _internal_has_continuation();
}
inline void SessionConfigurationPayload::clear_continuation() {
  if (GetArena() == nullptr && continuation_ != nullptr) {
    delete continuation_;
  }
  continuation_ = nullptr;
}
inline const ::ai::inworld::packets::Continuation& SessionConfigurationPayload::_internal_continuation() const {
  const ::ai::inworld::packets::Continuation* p = continuation_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Continuation&>(
      ::ai::inworld::packets::_Continuation_default_instance_);
}
inline const ::ai::inworld::packets::Continuation& SessionConfigurationPayload::continuation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionConfigurationPayload.continuation)
  return _internal_continuation();
}
inline void SessionConfigurationPayload::unsafe_arena_set_allocated_continuation(
    ::ai::inworld::packets::Continuation* continuation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(continuation_);
  }
  continuation_ = continuation;
  if (continuation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionConfigurationPayload.continuation)
}
inline ::ai::inworld::packets::Continuation* SessionConfigurationPayload::release_continuation() {
  
  ::ai::inworld::packets::Continuation* temp = continuation_;
  continuation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Continuation* SessionConfigurationPayload::unsafe_arena_release_continuation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionConfigurationPayload.continuation)
  
  ::ai::inworld::packets::Continuation* temp = continuation_;
  continuation_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Continuation* SessionConfigurationPayload::_internal_mutable_continuation() {
  
  if (continuation_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Continuation>(GetArena());
    continuation_ = p;
  }
  return continuation_;
}
inline ::ai::inworld::packets::Continuation* SessionConfigurationPayload::mutable_continuation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionConfigurationPayload.continuation)
  return _internal_mutable_continuation();
}
inline void SessionConfigurationPayload::set_allocated_continuation(::ai::inworld::packets::Continuation* continuation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete continuation_;
  }
  if (continuation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(continuation);
    if (message_arena != submessage_arena) {
      continuation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, continuation, submessage_arena);
    }
    
  } else {
    
  }
  continuation_ = continuation;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionConfigurationPayload.continuation)
}

// -------------------------------------------------------------------

// Continuation_ContinuationInfo

// .google.protobuf.Timestamp passed_time = 1;
inline bool Continuation_ContinuationInfo::_internal_has_passed_time() const {
  return this != internal_default_instance() && passed_time_ != nullptr;
}
inline bool Continuation_ContinuationInfo::has_passed_time() const {
  return _internal_has_passed_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Continuation_ContinuationInfo::_internal_passed_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = passed_time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Continuation_ContinuationInfo::passed_time() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
  return _internal_passed_time();
}
inline void Continuation_ContinuationInfo::unsafe_arena_set_allocated_passed_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* passed_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passed_time_);
  }
  passed_time_ = passed_time;
  if (passed_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Continuation_ContinuationInfo::release_passed_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = passed_time_;
  passed_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Continuation_ContinuationInfo::unsafe_arena_release_passed_time() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = passed_time_;
  passed_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Continuation_ContinuationInfo::_internal_mutable_passed_time() {
  
  if (passed_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    passed_time_ = p;
  }
  return passed_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Continuation_ContinuationInfo::mutable_passed_time() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
  return _internal_mutable_passed_time();
}
inline void Continuation_ContinuationInfo::set_allocated_passed_time(PROTOBUF_NAMESPACE_ID::Timestamp* passed_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(passed_time_);
  }
  if (passed_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(passed_time)->GetArena();
    if (message_arena != submessage_arena) {
      passed_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, passed_time, submessage_arena);
    }
    
  } else {
    
  }
  passed_time_ = passed_time;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.ContinuationInfo.passed_time)
}

// -------------------------------------------------------------------

// Continuation

// .ai.inworld.packets.Continuation.ContinuationInfo continuation_info = 1;
inline bool Continuation::_internal_has_continuation_info() const {
  return this != internal_default_instance() && continuation_info_ != nullptr;
}
inline bool Continuation::has_continuation_info() const {
  return _internal_has_continuation_info();
}
inline void Continuation::clear_continuation_info() {
  if (GetArena() == nullptr && continuation_info_ != nullptr) {
    delete continuation_info_;
  }
  continuation_info_ = nullptr;
}
inline const ::ai::inworld::packets::Continuation_ContinuationInfo& Continuation::_internal_continuation_info() const {
  const ::ai::inworld::packets::Continuation_ContinuationInfo* p = continuation_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Continuation_ContinuationInfo&>(
      ::ai::inworld::packets::_Continuation_ContinuationInfo_default_instance_);
}
inline const ::ai::inworld::packets::Continuation_ContinuationInfo& Continuation::continuation_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.continuation_info)
  return _internal_continuation_info();
}
inline void Continuation::unsafe_arena_set_allocated_continuation_info(
    ::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(continuation_info_);
  }
  continuation_info_ = continuation_info;
  if (continuation_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.continuation_info)
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::release_continuation_info() {
  
  ::ai::inworld::packets::Continuation_ContinuationInfo* temp = continuation_info_;
  continuation_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::unsafe_arena_release_continuation_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.continuation_info)
  
  ::ai::inworld::packets::Continuation_ContinuationInfo* temp = continuation_info_;
  continuation_info_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::_internal_mutable_continuation_info() {
  
  if (continuation_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Continuation_ContinuationInfo>(GetArena());
    continuation_info_ = p;
  }
  return continuation_info_;
}
inline ::ai::inworld::packets::Continuation_ContinuationInfo* Continuation::mutable_continuation_info() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.continuation_info)
  return _internal_mutable_continuation_info();
}
inline void Continuation::set_allocated_continuation_info(::ai::inworld::packets::Continuation_ContinuationInfo* continuation_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete continuation_info_;
  }
  if (continuation_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(continuation_info);
    if (message_arena != submessage_arena) {
      continuation_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, continuation_info, submessage_arena);
    }
    
  } else {
    
  }
  continuation_info_ = continuation_info;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.continuation_info)
}

// .ai.inworld.packets.Continuation.ContinuationType continuation_type = 2;
inline void Continuation::clear_continuation_type() {
  continuation_type_ = 0;
}
inline ::ai::inworld::packets::Continuation_ContinuationType Continuation::_internal_continuation_type() const {
  return static_cast< ::ai::inworld::packets::Continuation_ContinuationType >(continuation_type_);
}
inline ::ai::inworld::packets::Continuation_ContinuationType Continuation::continuation_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.continuation_type)
  return _internal_continuation_type();
}
inline void Continuation::_internal_set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value) {
  
  continuation_type_ = value;
}
inline void Continuation::set_continuation_type(::ai::inworld::packets::Continuation_ContinuationType value) {
  _internal_set_continuation_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Continuation.continuation_type)
}

// .ai.inworld.packets.DialogHistory dialog_history = 3;
inline bool Continuation::_internal_has_dialog_history() const {
  return this != internal_default_instance() && dialog_history_ != nullptr;
}
inline bool Continuation::has_dialog_history() const {
  return _internal_has_dialog_history();
}
inline void Continuation::clear_dialog_history() {
  if (GetArena() == nullptr && dialog_history_ != nullptr) {
    delete dialog_history_;
  }
  dialog_history_ = nullptr;
}
inline const ::ai::inworld::packets::DialogHistory& Continuation::_internal_dialog_history() const {
  const ::ai::inworld::packets::DialogHistory* p = dialog_history_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::DialogHistory&>(
      ::ai::inworld::packets::_DialogHistory_default_instance_);
}
inline const ::ai::inworld::packets::DialogHistory& Continuation::dialog_history() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.dialog_history)
  return _internal_dialog_history();
}
inline void Continuation::unsafe_arena_set_allocated_dialog_history(
    ::ai::inworld::packets::DialogHistory* dialog_history) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dialog_history_);
  }
  dialog_history_ = dialog_history;
  if (dialog_history) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Continuation.dialog_history)
}
inline ::ai::inworld::packets::DialogHistory* Continuation::release_dialog_history() {
  
  ::ai::inworld::packets::DialogHistory* temp = dialog_history_;
  dialog_history_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::unsafe_arena_release_dialog_history() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.dialog_history)
  
  ::ai::inworld::packets::DialogHistory* temp = dialog_history_;
  dialog_history_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::_internal_mutable_dialog_history() {
  
  if (dialog_history_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::DialogHistory>(GetArena());
    dialog_history_ = p;
  }
  return dialog_history_;
}
inline ::ai::inworld::packets::DialogHistory* Continuation::mutable_dialog_history() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.dialog_history)
  return _internal_mutable_dialog_history();
}
inline void Continuation::set_allocated_dialog_history(::ai::inworld::packets::DialogHistory* dialog_history) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dialog_history_;
  }
  if (dialog_history) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dialog_history);
    if (message_arena != submessage_arena) {
      dialog_history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dialog_history, submessage_arena);
    }
    
  } else {
    
  }
  dialog_history_ = dialog_history;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.dialog_history)
}

// bytes externally_saved_state = 4;
inline void Continuation::clear_externally_saved_state() {
  externally_saved_state_.ClearToEmpty();
}
inline const std::string& Continuation::externally_saved_state() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Continuation.externally_saved_state)
  return _internal_externally_saved_state();
}
inline void Continuation::set_externally_saved_state(const std::string& value) {
  _internal_set_externally_saved_state(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Continuation.externally_saved_state)
}
inline std::string* Continuation::mutable_externally_saved_state() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Continuation.externally_saved_state)
  return _internal_mutable_externally_saved_state();
}
inline const std::string& Continuation::_internal_externally_saved_state() const {
  return externally_saved_state_.Get();
}
inline void Continuation::_internal_set_externally_saved_state(const std::string& value) {
  
  externally_saved_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Continuation::set_externally_saved_state(std::string&& value) {
  
  externally_saved_state_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Continuation.externally_saved_state)
}
inline void Continuation::set_externally_saved_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  externally_saved_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Continuation.externally_saved_state)
}
inline void Continuation::set_externally_saved_state(const void* value,
    size_t size) {
  
  externally_saved_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Continuation.externally_saved_state)
}
inline std::string* Continuation::_internal_mutable_externally_saved_state() {
  
  return externally_saved_state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Continuation::release_externally_saved_state() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Continuation.externally_saved_state)
  return externally_saved_state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Continuation::set_allocated_externally_saved_state(std::string* externally_saved_state) {
  if (externally_saved_state != nullptr) {
    
  } else {
    
  }
  externally_saved_state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), externally_saved_state,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Continuation.externally_saved_state)
}

// -------------------------------------------------------------------

// DialogHistory_HistoryItem

// .ai.inworld.packets.Actor actor = 1;
inline bool DialogHistory_HistoryItem::_internal_has_actor() const {
  return this != internal_default_instance() && actor_ != nullptr;
}
inline bool DialogHistory_HistoryItem::has_actor() const {
  return _internal_has_actor();
}
inline void DialogHistory_HistoryItem::clear_actor() {
  if (GetArena() == nullptr && actor_ != nullptr) {
    delete actor_;
  }
  actor_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& DialogHistory_HistoryItem::_internal_actor() const {
  const ::ai::inworld::packets::Actor* p = actor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& DialogHistory_HistoryItem::actor() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.HistoryItem.actor)
  return _internal_actor();
}
inline void DialogHistory_HistoryItem::unsafe_arena_set_allocated_actor(
    ::ai::inworld::packets::Actor* actor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actor_);
  }
  actor_ = actor;
  if (actor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.actor)
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::release_actor() {
  
  ::ai::inworld::packets::Actor* temp = actor_;
  actor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::unsafe_arena_release_actor() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DialogHistory.HistoryItem.actor)
  
  ::ai::inworld::packets::Actor* temp = actor_;
  actor_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::_internal_mutable_actor() {
  
  if (actor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    actor_ = p;
  }
  return actor_;
}
inline ::ai::inworld::packets::Actor* DialogHistory_HistoryItem::mutable_actor() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.HistoryItem.actor)
  return _internal_mutable_actor();
}
inline void DialogHistory_HistoryItem::set_allocated_actor(::ai::inworld::packets::Actor* actor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete actor_;
  }
  if (actor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(actor);
    if (message_arena != submessage_arena) {
      actor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actor, submessage_arena);
    }
    
  } else {
    
  }
  actor_ = actor;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.actor)
}

// string text = 2;
inline void DialogHistory_HistoryItem::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& DialogHistory_HistoryItem::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return _internal_text();
}
inline void DialogHistory_HistoryItem::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DialogHistory.HistoryItem.text)
}
inline std::string* DialogHistory_HistoryItem::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return _internal_mutable_text();
}
inline const std::string& DialogHistory_HistoryItem::_internal_text() const {
  return text_.Get();
}
inline void DialogHistory_HistoryItem::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DialogHistory_HistoryItem::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.DialogHistory.HistoryItem.text)
}
inline void DialogHistory_HistoryItem::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.DialogHistory.HistoryItem.text)
}
inline void DialogHistory_HistoryItem::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.DialogHistory.HistoryItem.text)
}
inline std::string* DialogHistory_HistoryItem::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DialogHistory_HistoryItem::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DialogHistory.HistoryItem.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DialogHistory_HistoryItem::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DialogHistory.HistoryItem.text)
}

// -------------------------------------------------------------------

// DialogHistory

// repeated .ai.inworld.packets.DialogHistory.HistoryItem history = 1;
inline int DialogHistory::_internal_history_size() const {
  return history_.size();
}
inline int DialogHistory::history_size() const {
  return _internal_history_size();
}
inline void DialogHistory::clear_history() {
  history_.Clear();
}
inline ::ai::inworld::packets::DialogHistory_HistoryItem* DialogHistory::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DialogHistory.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >*
DialogHistory::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DialogHistory.history)
  return &history_;
}
inline const ::ai::inworld::packets::DialogHistory_HistoryItem& DialogHistory::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::ai::inworld::packets::DialogHistory_HistoryItem& DialogHistory::history(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DialogHistory.history)
  return _internal_history(index);
}
inline ::ai::inworld::packets::DialogHistory_HistoryItem* DialogHistory::_internal_add_history() {
  return history_.Add();
}
inline ::ai::inworld::packets::DialogHistory_HistoryItem* DialogHistory::add_history() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DialogHistory.history)
  return _internal_add_history();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::DialogHistory_HistoryItem >&
DialogHistory::history() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DialogHistory.history)
  return history_;
}

// -------------------------------------------------------------------

// Relations_Relation

// string type = 1;
inline void Relations_Relation::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Relations_Relation::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.Relation.type)
  return _internal_type();
}
inline void Relations_Relation::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Relations.Relation.type)
}
inline std::string* Relations_Relation::mutable_type() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.Relation.type)
  return _internal_mutable_type();
}
inline const std::string& Relations_Relation::_internal_type() const {
  return type_.Get();
}
inline void Relations_Relation::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Relations_Relation::set_type(std::string&& value) {
  
  type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Relations.Relation.type)
}
inline void Relations_Relation::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Relations.Relation.type)
}
inline void Relations_Relation::set_type(const char* value,
    size_t size) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Relations.Relation.type)
}
inline std::string* Relations_Relation::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Relations_Relation::release_type() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.Relation.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Relations_Relation::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.Relation.type)
}

// string label = 2;
inline void Relations_Relation::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& Relations_Relation::label() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.Relation.label)
  return _internal_label();
}
inline void Relations_Relation::set_label(const std::string& value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Relations.Relation.label)
}
inline std::string* Relations_Relation::mutable_label() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.Relation.label)
  return _internal_mutable_label();
}
inline const std::string& Relations_Relation::_internal_label() const {
  return label_.Get();
}
inline void Relations_Relation::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Relations_Relation::set_label(std::string&& value) {
  
  label_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Relations.Relation.label)
}
inline void Relations_Relation::set_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Relations.Relation.label)
}
inline void Relations_Relation::set_label(const char* value,
    size_t size) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Relations.Relation.label)
}
inline std::string* Relations_Relation::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Relations_Relation::release_label() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.Relation.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Relations_Relation::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.Relation.label)
}

// -------------------------------------------------------------------

// Relations

// .ai.inworld.packets.Actor actor = 1;
inline bool Relations::_internal_has_actor() const {
  return this != internal_default_instance() && actor_ != nullptr;
}
inline bool Relations::has_actor() const {
  return _internal_has_actor();
}
inline void Relations::clear_actor() {
  if (GetArena() == nullptr && actor_ != nullptr) {
    delete actor_;
  }
  actor_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Relations::_internal_actor() const {
  const ::ai::inworld::packets::Actor* p = actor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Relations::actor() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.actor)
  return _internal_actor();
}
inline void Relations::unsafe_arena_set_allocated_actor(
    ::ai::inworld::packets::Actor* actor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actor_);
  }
  actor_ = actor;
  if (actor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Relations.actor)
}
inline ::ai::inworld::packets::Actor* Relations::release_actor() {
  
  ::ai::inworld::packets::Actor* temp = actor_;
  actor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* Relations::unsafe_arena_release_actor() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Relations.actor)
  
  ::ai::inworld::packets::Actor* temp = actor_;
  actor_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Relations::_internal_mutable_actor() {
  
  if (actor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    actor_ = p;
  }
  return actor_;
}
inline ::ai::inworld::packets::Actor* Relations::mutable_actor() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.actor)
  return _internal_mutable_actor();
}
inline void Relations::set_allocated_actor(::ai::inworld::packets::Actor* actor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete actor_;
  }
  if (actor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(actor);
    if (message_arena != submessage_arena) {
      actor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actor, submessage_arena);
    }
    
  } else {
    
  }
  actor_ = actor;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Relations.actor)
}

// repeated .ai.inworld.packets.Relations.Relation relations = 2;
inline int Relations::_internal_relations_size() const {
  return relations_.size();
}
inline int Relations::relations_size() const {
  return _internal_relations_size();
}
inline void Relations::clear_relations() {
  relations_.Clear();
}
inline ::ai::inworld::packets::Relations_Relation* Relations::mutable_relations(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Relations.relations)
  return relations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >*
Relations::mutable_relations() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.Relations.relations)
  return &relations_;
}
inline const ::ai::inworld::packets::Relations_Relation& Relations::_internal_relations(int index) const {
  return relations_.Get(index);
}
inline const ::ai::inworld::packets::Relations_Relation& Relations::relations(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Relations.relations)
  return _internal_relations(index);
}
inline ::ai::inworld::packets::Relations_Relation* Relations::_internal_add_relations() {
  return relations_.Add();
}
inline ::ai::inworld::packets::Relations_Relation* Relations::add_relations() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.Relations.relations)
  return _internal_add_relations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Relations_Relation >&
Relations::relations() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.Relations.relations)
  return relations_;
}

// -------------------------------------------------------------------

// SessionHistoryRequest

// -------------------------------------------------------------------

// SessionHistoryResponse_SessionHistoryItem

// .ai.inworld.packets.Agent agent = 1;
inline bool SessionHistoryResponse_SessionHistoryItem::_internal_has_agent() const {
  return this != internal_default_instance() && agent_ != nullptr;
}
inline bool SessionHistoryResponse_SessionHistoryItem::has_agent() const {
  return _internal_has_agent();
}
inline void SessionHistoryResponse_SessionHistoryItem::clear_agent() {
  if (GetArena() == nullptr && agent_ != nullptr) {
    delete agent_;
  }
  agent_ = nullptr;
}
inline const ::ai::inworld::packets::Agent& SessionHistoryResponse_SessionHistoryItem::_internal_agent() const {
  const ::ai::inworld::packets::Agent* p = agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Agent&>(
      ::ai::inworld::packets::_Agent_default_instance_);
}
inline const ::ai::inworld::packets::Agent& SessionHistoryResponse_SessionHistoryItem::agent() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.agent)
  return _internal_agent();
}
inline void SessionHistoryResponse_SessionHistoryItem::unsafe_arena_set_allocated_agent(
    ::ai::inworld::packets::Agent* agent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(agent_);
  }
  agent_ = agent;
  if (agent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.agent)
}
inline ::ai::inworld::packets::Agent* SessionHistoryResponse_SessionHistoryItem::release_agent() {
  
  ::ai::inworld::packets::Agent* temp = agent_;
  agent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Agent* SessionHistoryResponse_SessionHistoryItem::unsafe_arena_release_agent() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.agent)
  
  ::ai::inworld::packets::Agent* temp = agent_;
  agent_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Agent* SessionHistoryResponse_SessionHistoryItem::_internal_mutable_agent() {
  
  if (agent_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Agent>(GetArena());
    agent_ = p;
  }
  return agent_;
}
inline ::ai::inworld::packets::Agent* SessionHistoryResponse_SessionHistoryItem::mutable_agent() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.agent)
  return _internal_mutable_agent();
}
inline void SessionHistoryResponse_SessionHistoryItem::set_allocated_agent(::ai::inworld::packets::Agent* agent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete agent_;
  }
  if (agent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(agent);
    if (message_arena != submessage_arena) {
      agent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agent, submessage_arena);
    }
    
  } else {
    
  }
  agent_ = agent;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.agent)
}

// repeated .ai.inworld.packets.InworldPacket packets = 2;
inline int SessionHistoryResponse_SessionHistoryItem::_internal_packets_size() const {
  return packets_.size();
}
inline int SessionHistoryResponse_SessionHistoryItem::packets_size() const {
  return _internal_packets_size();
}
inline void SessionHistoryResponse_SessionHistoryItem::clear_packets() {
  packets_.Clear();
}
inline ::ai::inworld::packets::InworldPacket* SessionHistoryResponse_SessionHistoryItem::mutable_packets(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.packets)
  return packets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::InworldPacket >*
SessionHistoryResponse_SessionHistoryItem::mutable_packets() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.packets)
  return &packets_;
}
inline const ::ai::inworld::packets::InworldPacket& SessionHistoryResponse_SessionHistoryItem::_internal_packets(int index) const {
  return packets_.Get(index);
}
inline const ::ai::inworld::packets::InworldPacket& SessionHistoryResponse_SessionHistoryItem::packets(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.packets)
  return _internal_packets(index);
}
inline ::ai::inworld::packets::InworldPacket* SessionHistoryResponse_SessionHistoryItem::_internal_add_packets() {
  return packets_.Add();
}
inline ::ai::inworld::packets::InworldPacket* SessionHistoryResponse_SessionHistoryItem::add_packets() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.packets)
  return _internal_add_packets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::InworldPacket >&
SessionHistoryResponse_SessionHistoryItem::packets() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem.packets)
  return packets_;
}

// -------------------------------------------------------------------

// SessionHistoryResponse

// repeated .ai.inworld.packets.SessionHistoryResponse.SessionHistoryItem session_history_items = 1;
inline int SessionHistoryResponse::_internal_session_history_items_size() const {
  return session_history_items_.size();
}
inline int SessionHistoryResponse::session_history_items_size() const {
  return _internal_session_history_items_size();
}
inline void SessionHistoryResponse::clear_session_history_items() {
  session_history_items_.Clear();
}
inline ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* SessionHistoryResponse::mutable_session_history_items(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.SessionHistoryResponse.session_history_items)
  return session_history_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem >*
SessionHistoryResponse::mutable_session_history_items() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.SessionHistoryResponse.session_history_items)
  return &session_history_items_;
}
inline const ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem& SessionHistoryResponse::_internal_session_history_items(int index) const {
  return session_history_items_.Get(index);
}
inline const ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem& SessionHistoryResponse::session_history_items(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.SessionHistoryResponse.session_history_items)
  return _internal_session_history_items(index);
}
inline ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* SessionHistoryResponse::_internal_add_session_history_items() {
  return session_history_items_.Add();
}
inline ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem* SessionHistoryResponse::add_session_history_items() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.SessionHistoryResponse.session_history_items)
  return _internal_add_session_history_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::SessionHistoryResponse_SessionHistoryItem >&
SessionHistoryResponse::session_history_items() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.SessionHistoryResponse.session_history_items)
  return session_history_items_;
}

// -------------------------------------------------------------------

// ConversationUpdatePayload

// repeated .ai.inworld.packets.Actor participants = 1;
inline int ConversationUpdatePayload::_internal_participants_size() const {
  return participants_.size();
}
inline int ConversationUpdatePayload::participants_size() const {
  return _internal_participants_size();
}
inline void ConversationUpdatePayload::clear_participants() {
  participants_.Clear();
}
inline ::ai::inworld::packets::Actor* ConversationUpdatePayload::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ConversationUpdatePayload.participants)
  return participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
ConversationUpdatePayload::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.ConversationUpdatePayload.participants)
  return &participants_;
}
inline const ::ai::inworld::packets::Actor& ConversationUpdatePayload::_internal_participants(int index) const {
  return participants_.Get(index);
}
inline const ::ai::inworld::packets::Actor& ConversationUpdatePayload::participants(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ConversationUpdatePayload.participants)
  return _internal_participants(index);
}
inline ::ai::inworld::packets::Actor* ConversationUpdatePayload::_internal_add_participants() {
  return participants_.Add();
}
inline ::ai::inworld::packets::Actor* ConversationUpdatePayload::add_participants() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.ConversationUpdatePayload.participants)
  return _internal_add_participants();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
ConversationUpdatePayload::participants() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.ConversationUpdatePayload.participants)
  return participants_;
}

// -------------------------------------------------------------------

// ConversationEventPayload

// repeated .ai.inworld.packets.Actor participants = 1;
inline int ConversationEventPayload::_internal_participants_size() const {
  return participants_.size();
}
inline int ConversationEventPayload::participants_size() const {
  return _internal_participants_size();
}
inline void ConversationEventPayload::clear_participants() {
  participants_.Clear();
}
inline ::ai::inworld::packets::Actor* ConversationEventPayload::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ConversationEventPayload.participants)
  return participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >*
ConversationEventPayload::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.ConversationEventPayload.participants)
  return &participants_;
}
inline const ::ai::inworld::packets::Actor& ConversationEventPayload::_internal_participants(int index) const {
  return participants_.Get(index);
}
inline const ::ai::inworld::packets::Actor& ConversationEventPayload::participants(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ConversationEventPayload.participants)
  return _internal_participants(index);
}
inline ::ai::inworld::packets::Actor* ConversationEventPayload::_internal_add_participants() {
  return participants_.Add();
}
inline ::ai::inworld::packets::Actor* ConversationEventPayload::add_participants() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.ConversationEventPayload.participants)
  return _internal_add_participants();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::Actor >&
ConversationEventPayload::participants() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.ConversationEventPayload.participants)
  return participants_;
}

// .ai.inworld.packets.ConversationEventPayload.ConversationEventType event_type = 2;
inline void ConversationEventPayload::clear_event_type() {
  event_type_ = 0;
}
inline ::ai::inworld::packets::ConversationEventPayload_ConversationEventType ConversationEventPayload::_internal_event_type() const {
  return static_cast< ::ai::inworld::packets::ConversationEventPayload_ConversationEventType >(event_type_);
}
inline ::ai::inworld::packets::ConversationEventPayload_ConversationEventType ConversationEventPayload::event_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ConversationEventPayload.event_type)
  return _internal_event_type();
}
inline void ConversationEventPayload::_internal_set_event_type(::ai::inworld::packets::ConversationEventPayload_ConversationEventType value) {
  
  event_type_ = value;
}
inline void ConversationEventPayload::set_event_type(::ai::inworld::packets::ConversationEventPayload_ConversationEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ConversationEventPayload.event_type)
}

// -------------------------------------------------------------------

// OperationStatusEvent

// .google.rpc.Status status = 1;
inline bool OperationStatusEvent::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool OperationStatusEvent::has_status() const {
  return _internal_has_status();
}
inline const ::google::rpc::Status& OperationStatusEvent::_internal_status() const {
  const ::google::rpc::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& OperationStatusEvent::status() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.OperationStatusEvent.status)
  return _internal_status();
}
inline void OperationStatusEvent::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.OperationStatusEvent.status)
}
inline ::google::rpc::Status* OperationStatusEvent::release_status() {
  
  ::google::rpc::Status* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::google::rpc::Status* OperationStatusEvent::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.OperationStatusEvent.status)
  
  ::google::rpc::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* OperationStatusEvent::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::google::rpc::Status* OperationStatusEvent::mutable_status() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.OperationStatusEvent.status)
  return _internal_mutable_status();
}
inline void OperationStatusEvent::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.OperationStatusEvent.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace inworld
}  // namespace ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ai::inworld::packets::Actor_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Actor_Type>() {
  return ::ai::inworld::packets::Actor_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::TextEvent_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::TextEvent_SourceType>() {
  return ::ai::inworld::packets::TextEvent_SourceType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ControlEvent_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ControlEvent_Action>() {
  return ::ai::inworld::packets::ControlEvent_Action_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode>() {
  return ::ai::inworld::packets::AudioSessionStartPayload_MicrophoneMode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode>() {
  return ::ai::inworld::packets::AudioSessionStartPayload_UnderstandingMode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::CustomEvent_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::CustomEvent_Type>() {
  return ::ai::inworld::packets::CustomEvent_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_SpaffCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_SpaffCode>() {
  return ::ai::inworld::packets::EmotionEvent_SpaffCode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_Strength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_Strength>() {
  return ::ai::inworld::packets::EmotionEvent_Strength_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_DataType>() {
  return ::ai::inworld::packets::DataChunk_DataType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_AudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_AudioFormat>() {
  return ::ai::inworld::packets::DataChunk_AudioFormat_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::PingPongReport_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::PingPongReport_Type>() {
  return ::ai::inworld::packets::PingPongReport_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::PerceivedLatencyReport_Precision> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::PerceivedLatencyReport_Precision>() {
  return ::ai::inworld::packets::PerceivedLatencyReport_Precision_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::LogsEvent_LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::LogsEvent_LogLevel>() {
  return ::ai::inworld::packets::LogsEvent_LogLevel_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ApplyResponse_ApplyResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ApplyResponse_ApplyResponseType>() {
  return ::ai::inworld::packets::ApplyResponse_ApplyResponseType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::Continuation_ContinuationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Continuation_ContinuationType>() {
  return ::ai::inworld::packets::Continuation_ContinuationType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ConversationEventPayload_ConversationEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ConversationEventPayload_ConversationEventType>() {
  return ::ai::inworld::packets::ConversationEventPayload_ConversationEventType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::Playback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Playback>() {
  return ::ai::inworld::packets::Playback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ai_2finworld_2fpackets_2fpackets_2eproto
